"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports, module2) {
    var EventEmitter = require("events").EventEmitter;
    var spawn2 = require("child_process").spawn;
    var path7 = require("path");
    var fs8 = require("fs");
    var Option = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} description
       * @api public
       */
      constructor(flags, description) {
        this.flags = flags;
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = _parseOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.description = description || "";
        this.defaultValue = void 0;
      }
      /**
       * Return option name.
       *
       * @return {string}
       * @api private
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       * @api private
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @api private
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
    };
    var CommanderError = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @constructor
       */
      constructor(exitCode, code2, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code2;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var Command = class extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       * @api public
       */
      constructor(name2) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._args = [];
        this.rawArgs = null;
        this._scriptPath = null;
        this._name = name2 || "";
        this._optionValues = {};
        this._storeOptionsAsProperties = true;
        this._storeOptionsAsPropertiesCalled = false;
        this._passCommandToAction = true;
        this._actionResults = [];
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._hasImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * Examples:
       *
       *      // Command implemented using action handler (description is supplied separately to `.command`)
       *      program
       *        .command('clone <source> [destination]')
       *        .description('clone a repository into a newly created directory')
       *        .action((source, destination) => {
       *          console.log('clone command called');
       *        });
       *
       *      // Command implemented using separate executable file (description is second parameter to `.command`)
       *      program
       *        .command('start <service>', 'start named service')
       *        .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {Object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       * @api public
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const args = nameAndArgs.split(/ +/);
        const cmd = this.createCommand(args.shift());
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._hasHelpOption = this._hasHelpOption;
        cmd._helpFlags = this._helpFlags;
        cmd._helpDescription = this._helpDescription;
        cmd._helpShortFlag = this._helpShortFlag;
        cmd._helpLongFlag = this._helpLongFlag;
        cmd._helpCommandName = this._helpCommandName;
        cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;
        cmd._helpCommandDescription = this._helpCommandDescription;
        cmd._exitCallback = this._exitCallback;
        cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;
        cmd._passCommandToAction = this._passCommandToAction;
        cmd._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue;
        cmd._executableFile = opts.executableFile || null;
        this.commands.push(cmd);
        cmd._parseExpectedArgs(args);
        cmd.parent = this;
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       * @api public
       */
      createCommand(name2) {
        return new Command(name2);
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {Object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       * @api public
       */
      addCommand(cmd, opts) {
        if (!cmd._name)
          throw new Error("Command passed to .addCommand() must have a name");
        function checkExplicitNames(commandArray) {
          commandArray.forEach((cmd2) => {
            if (cmd2._executableHandler && !cmd2._executableFile) {
              throw new Error(`Must specify executableFile for deeply nested executable: ${cmd2.name()}`);
            }
            checkExplicitNames(cmd2.commands);
          });
        }
        checkExplicitNames(cmd.commands);
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      /**
       * Define argument syntax for the command.
       *
       * @api public
       */
      arguments(desc) {
        return this._parseExpectedArgs(desc.split(/ +/));
      }
      /**
       * Override default decision whether to add implicit help command.
       *
       *    addHelpCommand() // force on
       *    addHelpCommand(false); // force off
       *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
       *
       * @return {Command} `this` command for chaining
       * @api public
       */
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._hasImplicitHelpCommand = false;
        } else {
          this._hasImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      /**
       * @return {boolean}
       * @api private
       */
      _lazyHasImplicitHelpCommand() {
        if (this._hasImplicitHelpCommand === void 0) {
          this._hasImplicitHelpCommand = this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._hasImplicitHelpCommand;
      }
      /**
       * Parse expected `args`.
       *
       * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
       *
       * @param {Array} args
       * @return {Command} `this` command for chaining
       * @api private
       */
      _parseExpectedArgs(args) {
        if (!args.length)
          return;
        args.forEach((arg) => {
          const argDetails = {
            required: false,
            name: "",
            variadic: false
          };
          switch (arg[0]) {
            case "<":
              argDetails.required = true;
              argDetails.name = arg.slice(1, -1);
              break;
            case "[":
              argDetails.name = arg.slice(1, -1);
              break;
          }
          if (argDetails.name.length > 3 && argDetails.name.slice(-3) === "...") {
            argDetails.variadic = true;
            argDetails.name = argDetails.name.slice(0, -3);
          }
          if (argDetails.name) {
            this._args.push(argDetails);
          }
        });
        this._args.forEach((arg, i) => {
          if (arg.variadic && i < this._args.length - 1) {
            throw new Error(`only the last argument can be variadic '${arg.name}'`);
          }
        });
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       * @api public
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @api private
       */
      _exit(exitCode, code2, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError(exitCode, code2, message));
        }
        process.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * Examples:
       *
       *      program
       *        .command('help')
       *        .description('display verbose help')
       *        .action(function() {
       *           // output help here
       *        });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       * @api public
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._passCommandToAction) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          if (args.length > expectedArgsCount) {
            actionArgs.push(args.slice(expectedArgsCount));
          }
          const actionResult = fn.apply(this, actionArgs);
          let rootCommand = this;
          while (rootCommand.parent) {
            rootCommand = rootCommand.parent;
          }
          rootCommand._actionResults.push(actionResult);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Internal routine to check whether there is a clash storing option value with a Command property.
       *
       * @param {Option} option
       * @api private
       */
      _checkForOptionNameClash(option) {
        if (!this._storeOptionsAsProperties || this._storeOptionsAsPropertiesCalled) {
          return;
        }
        if (option.name() === "help") {
          return;
        }
        const commandProperty = this._getOptionValue(option.attributeName());
        if (commandProperty === void 0) {
          return;
        }
        let foundClash = true;
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          foundClash = !this._findOption(positiveLongFlag);
        } else if (option.long) {
          const negativeLongFlag = option.long.replace(/^--/, "--no-");
          foundClash = !this._findOption(negativeLongFlag);
        }
        if (foundClash) {
          throw new Error(`option '${option.name()}' clashes with existing property '${option.attributeName()}' on Command
- call storeOptionsAsProperties(false) to store option values safely,
- or call storeOptionsAsProperties(true) to suppress this check,
- or change option name

Read more on https://git.io/JJc0W`);
        }
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @param {Object} config
       * @param {string} flags
       * @param {string} description
       * @param {Function|*} [fn] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       * @api private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        const option = new Option(flags, description);
        const oname = option.name();
        const name2 = option.attributeName();
        option.mandatory = !!config.mandatory;
        this._checkForOptionNameClash(option);
        if (typeof fn !== "function") {
          if (fn instanceof RegExp) {
            const regex = fn;
            fn = (val, def) => {
              const m = regex.exec(val);
              return m ? m[0] : def;
            };
          } else {
            defaultValue = fn;
            fn = null;
          }
        }
        if (option.negate || option.optional || option.required || typeof defaultValue === "boolean") {
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name2) : true;
          }
          if (defaultValue !== void 0) {
            this._setOptionValue(name2, defaultValue);
            option.defaultValue = defaultValue;
          }
        }
        this.options.push(option);
        this.on("option:" + oname, (val) => {
          const oldValue = this._getOptionValue(name2);
          if (val !== null && fn) {
            val = fn(val, oldValue === void 0 ? defaultValue : oldValue);
          } else if (val !== null && option.variadic) {
            if (oldValue === defaultValue || !Array.isArray(oldValue)) {
              val = [val];
            } else {
              val = oldValue.concat(val);
            }
          }
          if (typeof oldValue === "boolean" || typeof oldValue === "undefined") {
            if (val == null) {
              this._setOptionValue(name2, option.negate ? false : defaultValue || true);
            } else {
              this._setOptionValue(name2, val);
            }
          } else if (val !== null) {
            this._setOptionValue(name2, option.negate ? false : val);
          }
        });
        return this;
      }
      /**
       * Define option with `flags`, `description` and optional
       * coercion `fn`.
       *
       * The `flags` string should contain both the short and long flags,
       * separated by comma, a pipe or space. The following are all valid
       * all will output this way when `--help` is used.
       *
       *    "-p, --pepper"
       *    "-p|--pepper"
       *    "-p --pepper"
       *
       * Examples:
       *
       *     // simple boolean defaulting to undefined
       *     program.option('-p, --pepper', 'add pepper');
       *
       *     program.pepper
       *     // => undefined
       *
       *     --pepper
       *     program.pepper
       *     // => true
       *
       *     // simple boolean defaulting to true (unless non-negated option is also defined)
       *     program.option('-C, --no-cheese', 'remove cheese');
       *
       *     program.cheese
       *     // => true
       *
       *     --no-cheese
       *     program.cheese
       *     // => false
       *
       *     // required argument
       *     program.option('-C, --chdir <path>', 'change the working directory');
       *
       *     --chdir /tmp
       *     program.chdir
       *     // => "/tmp"
       *
       *     // optional argument
       *     program.option('-c, --cheese [type]', 'add cheese [marble]');
       *
       * @param {string} flags
       * @param {string} description
       * @param {Function|*} [fn] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       * @api public
       */
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      /**
      * Add a required option which must have a value after parsing. This usually means
      * the option must be specified on the command line. (Otherwise the same as .option().)
      *
      * The `flags` string should contain both the short and long flags, separated by comma, a pipe or space.
      *
      * @param {string} flags
      * @param {string} description
      * @param {Function|*} [fn] - custom option processing function or default value
      * @param {*} [defaultValue]
      * @return {Command} `this` command for chaining
      * @api public
      */
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * Examples:
       *
       *    // for `.option('-f,--flag [value]'):
       *    .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour
       *    .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {Boolean} [arg] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @api public
       */
      combineFlagAndOptionalValue(arg) {
        this._combineFlagAndOptionalValue = arg === void 0 || arg;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {Boolean} [arg] - if `true` or omitted, no error will be thrown
       * for unknown options.
       * @api public
       */
      allowUnknownOption(arg) {
        this._allowUnknownOption = arg === void 0 || arg;
        return this;
      }
      /**
        * Whether to store option values as properties on command object,
        * or store separately (specify false). In both cases the option values can be accessed using .opts().
        *
        * @param {boolean} value
        * @return {Command} `this` command for chaining
        * @api public
        */
      storeOptionsAsProperties(value) {
        this._storeOptionsAsPropertiesCalled = true;
        this._storeOptionsAsProperties = value === void 0 || value;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      /**
        * Whether to pass command to action handler,
        * or just the options (specify false).
        *
        * @param {boolean} value
        * @return {Command} `this` command for chaining
        * @api public
        */
      passCommandToAction(value) {
        this._passCommandToAction = value === void 0 || value;
        return this;
      }
      /**
       * Store option value
       *
       * @param {string} key
       * @param {Object} value
       * @api private
       */
      _setOptionValue(key, value) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
      }
      /**
       * Retrieve option value
       *
       * @param {string} key
       * @return {Object} value
       * @api private
       */
      _getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * Examples:
       *
       *      program.parse(process.argv);
       *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       * @api public
       */
      parse(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process.argv;
          if (process.versions && process.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._scriptPath && process.mainModule) {
          this._scriptPath = process.mainModule.filename;
        }
        this._name = this._name || this._scriptPath && path7.basename(this._scriptPath, path7.extname(this._scriptPath));
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * Examples:
       *
       *      program.parseAsync(process.argv);
       *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
       *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {Object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       * @api public
       */
      parseAsync(argv, parseOptions) {
        this.parse(argv, parseOptions);
        return Promise.all(this._actionResults).then(() => this);
      }
      /**
       * Execute a sub-command executable.
       *
       * @api private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs"];
        this._checkForMissingMandatoryOptions();
        let scriptPath = this._scriptPath;
        if (!scriptPath && process.mainModule) {
          scriptPath = process.mainModule.filename;
        }
        let baseDir;
        try {
          const resolvedLink = fs8.realpathSync(scriptPath);
          baseDir = path7.dirname(resolvedLink);
        } catch (e) {
          baseDir = ".";
        }
        let bin = path7.basename(scriptPath, path7.extname(scriptPath)) + "-" + subcommand._name;
        if (subcommand._executableFile) {
          bin = subcommand._executableFile;
        }
        const localBin = path7.join(baseDir, bin);
        if (fs8.existsSync(localBin)) {
          bin = localBin;
        } else {
          sourceExt.forEach((ext) => {
            if (fs8.existsSync(`${localBin}${ext}`)) {
              bin = `${localBin}${ext}`;
            }
          });
        }
        launchWithNode = sourceExt.includes(path7.extname(bin));
        let proc;
        if (process.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(bin);
            args = incrementNodeInspectorPort(process.execArgv).concat(args);
            proc = spawn2(process.argv[0], args, { stdio: "inherit" });
          } else {
            proc = spawn2(bin, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(bin);
          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = spawn2(process.execPath, args, { stdio: "inherit" });
        }
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process.exit.bind(process));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError(process.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${bin}' not executable`);
          }
          if (!exitCallback) {
            process.exit(1);
          } else {
            const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @api private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this._helpAndError();
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          subCommand._parseCommand(operands, unknown);
        }
      }
      /**
       * Process arguments in context of this command.
       *
       * @api private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        } else if (this._lazyHasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          } else {
            this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
          }
        } else if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        } else {
          if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
            this._helpAndError();
          }
          outputHelpIfRequested(this, parsed.unknown);
          this._checkForMissingMandatoryOptions();
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
          if (this._actionHandler) {
            const args = this.args.slice();
            this._args.forEach((arg, i) => {
              if (arg.required && args[i] == null) {
                this.missingArgument(arg.name);
              } else if (arg.variadic) {
                args[i] = args.splice(i);
              }
            });
            this._actionHandler(args);
            this.emit("command:" + this.name(), operands, unknown);
          } else if (operands.length) {
            if (this._findCommand("*")) {
              this._dispatchSubcommand("*", operands, unknown);
            } else if (this.listenerCount("command:*")) {
              this.emit("command:*", operands, unknown);
            } else if (this.commands.length) {
              this.unknownCommand();
            }
          } else if (this.commands.length) {
            this._helpAndError();
          } else {
          }
        }
      }
      /**
       * Find matching command.
       *
       * @api private
       */
      _findCommand(name2) {
        if (!name2)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name2 || cmd._aliases.includes(name2));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @api private
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Lazy calling after checking for help flags from leaf subcommand.
       *
       * @api private
       */
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd._getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *    argv => operands, unknown
       *    --known kkk op => [op], []
       *    op --known kkk => [op], []
       *    sub --unknown uuu op => [sub], [--unknown uuu op]
       *    sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {String[]} argv
       * @return {{operands: String[], unknown: String[]}}
       * @api public
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (arg.length > 1 && arg[0] === "-") {
            dest = unknown;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing options as key-value pairs
       *
       * @return {Object}
       * @api public
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @api private
       */
      missingArgument(name2) {
        const message = `error: missing required argument '${name2}'`;
        console.error(message);
        this._exit(1, "commander.missingArgument", message);
      }
      /**
       * `Option` is missing an argument, but received `flag` or nothing.
       *
       * @param {Option} option
       * @param {string} [flag]
       * @api private
       */
      optionMissingArgument(option, flag) {
        let message;
        if (flag) {
          message = `error: option '${option.flags}' argument missing, got '${flag}'`;
        } else {
          message = `error: option '${option.flags}' argument missing`;
        }
        console.error(message);
        this._exit(1, "commander.optionMissingArgument", message);
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @api private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        console.error(message);
        this._exit(1, "commander.missingMandatoryOptionValue", message);
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @api private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        const message = `error: unknown option '${flag}'`;
        console.error(message);
        this._exit(1, "commander.unknownOption", message);
      }
      /**
       * Unknown command.
       *
       * @api private
       */
      unknownCommand() {
        const partCommands = [this.name()];
        for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
          partCommands.unshift(parentCmd.name());
        }
        const fullCommand = partCommands.join(" ");
        const message = `error: unknown command '${this.args[0]}'.` + (this._hasHelpOption ? ` See '${fullCommand} ${this._helpLongFlag}'.` : "");
        console.error(message);
        this._exit(1, "commander.unknownCommand", message);
      }
      /**
       * Set the program version to `str`.
       *
       * This method auto-registers the "-V, --version" flag
       * which will print the version number when passed.
       *
       * You can optionally supply the  flags and description to override the defaults.
       *
       * @param {string} str
       * @param {string} [flags]
       * @param {string} [description]
       * @return {this | string} `this` command for chaining, or version string if no arguments
       * @api public
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = new Option(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          process.stdout.write(str + "\n");
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description to `str`.
       *
       * @param {string} str
       * @param {Object} [argsDescription]
       * @return {string|Command}
       * @api public
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        this._argsDescription = argsDescription;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {string|Command}
       * @api public
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {string[]|Command}
       * @api public
       */
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {String|Command}
       * @api public
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this._args.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command
       *
       * @param {string} [str]
       * @return {String|Command}
       * @api public
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Return prepared commands.
       *
       * @return {Array}
       * @api private
       */
      prepareCommands() {
        const commandDetails = this.commands.filter((cmd) => {
          return !cmd._hidden;
        }).map((cmd) => {
          const args = cmd._args.map((arg) => {
            return humanReadableArgName(arg);
          }).join(" ");
          return [
            cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : ""),
            cmd._description
          ];
        });
        if (this._lazyHasImplicitHelpCommand()) {
          commandDetails.push([this._helpCommandnameAndArgs, this._helpCommandDescription]);
        }
        return commandDetails;
      }
      /**
       * Return the largest command length.
       *
       * @return {number}
       * @api private
       */
      largestCommandLength() {
        const commands = this.prepareCommands();
        return commands.reduce((max, command) => {
          return Math.max(max, command[0].length);
        }, 0);
      }
      /**
       * Return the largest option length.
       *
       * @return {number}
       * @api private
       */
      largestOptionLength() {
        const options = [].slice.call(this.options);
        options.push({
          flags: this._helpFlags
        });
        return options.reduce((max, option) => {
          return Math.max(max, option.flags.length);
        }, 0);
      }
      /**
       * Return the largest arg length.
       *
       * @return {number}
       * @api private
       */
      largestArgLength() {
        return this._args.reduce((max, arg) => {
          return Math.max(max, arg.name.length);
        }, 0);
      }
      /**
       * Return the pad width.
       *
       * @return {number}
       * @api private
       */
      padWidth() {
        let width = this.largestOptionLength();
        if (this._argsDescription && this._args.length) {
          if (this.largestArgLength() > width) {
            width = this.largestArgLength();
          }
        }
        if (this.commands && this.commands.length) {
          if (this.largestCommandLength() > width) {
            width = this.largestCommandLength();
          }
        }
        return width;
      }
      /**
       * Return help for options.
       *
       * @return {string}
       * @api private
       */
      optionHelp() {
        const width = this.padWidth();
        const columns = process.stdout.columns || 80;
        const descriptionWidth = columns - width - 4;
        function padOptionDetails(flags, description) {
          return pad(flags, width) + "  " + optionalWrap(description, descriptionWidth, width + 2);
        }
        ;
        const help = this.options.map((option) => {
          const fullDesc = option.description + (!option.negate && option.defaultValue !== void 0 ? " (default: " + JSON.stringify(option.defaultValue) + ")" : "");
          return padOptionDetails(option.flags, fullDesc);
        });
        const showShortHelpFlag = this._hasHelpOption && this._helpShortFlag && !this._findOption(this._helpShortFlag);
        const showLongHelpFlag = this._hasHelpOption && !this._findOption(this._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpFlags = this._helpFlags;
          if (!showShortHelpFlag) {
            helpFlags = this._helpLongFlag;
          } else if (!showLongHelpFlag) {
            helpFlags = this._helpShortFlag;
          }
          help.push(padOptionDetails(helpFlags, this._helpDescription));
        }
        return help.join("\n");
      }
      /**
       * Return command help documentation.
       *
       * @return {string}
       * @api private
       */
      commandHelp() {
        if (!this.commands.length && !this._lazyHasImplicitHelpCommand())
          return "";
        const commands = this.prepareCommands();
        const width = this.padWidth();
        const columns = process.stdout.columns || 80;
        const descriptionWidth = columns - width - 4;
        return [
          "Commands:",
          commands.map((cmd) => {
            const desc = cmd[1] ? "  " + cmd[1] : "";
            return (desc ? pad(cmd[0], width) : cmd[0]) + optionalWrap(desc, descriptionWidth, width + 2);
          }).join("\n").replace(/^/gm, "  "),
          ""
        ].join("\n");
      }
      /**
       * Return program help documentation.
       *
       * @return {string}
       * @api public
       */
      helpInformation() {
        let desc = [];
        if (this._description) {
          desc = [
            this._description,
            ""
          ];
          const argsDescription = this._argsDescription;
          if (argsDescription && this._args.length) {
            const width = this.padWidth();
            const columns = process.stdout.columns || 80;
            const descriptionWidth = columns - width - 5;
            desc.push("Arguments:");
            this._args.forEach((arg) => {
              desc.push("  " + pad(arg.name, width) + "  " + wrap(argsDescription[arg.name] || "", descriptionWidth, width + 4));
            });
            desc.push("");
          }
        }
        let cmdName = this._name;
        if (this._aliases[0]) {
          cmdName = cmdName + "|" + this._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        const usage = [
          "Usage: " + parentCmdNames + cmdName + " " + this.usage(),
          ""
        ];
        let cmds = [];
        const commandHelp = this.commandHelp();
        if (commandHelp)
          cmds = [commandHelp];
        let options = [];
        if (this._hasHelpOption || this.options.length > 0) {
          options = [
            "Options:",
            "" + this.optionHelp().replace(/^/gm, "  "),
            ""
          ];
        }
        return usage.concat(desc).concat(options).concat(cmds).join("\n");
      }
      /**
       * Output help information for this command.
       *
       * When listener(s) are available for the helpLongFlag
       * those callbacks are invoked.
       *
       * @api public
       */
      outputHelp(cb) {
        if (!cb) {
          cb = (passthru) => {
            return passthru;
          };
        }
        const cbOutput = cb(this.helpInformation());
        if (typeof cbOutput !== "string" && !Buffer.isBuffer(cbOutput)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
        process.stdout.write(cbOutput);
        this.emit(this._helpLongFlag);
      }
      /**
       * You can pass in flags and a description to override the help
       * flags and help description for your command. Pass in false to
       * disable the built-in help option.
       *
       * @param {string | boolean} [flags]
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       * @api public
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = _parseOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * @param {Function} [cb]
       * @api public
       */
      help(cb) {
        this.outputHelp(cb);
        this._exit(process.exitCode || 0, "commander.help", "(outputHelp)");
      }
      /**
       * Output help information and exit. Display for error situations.
       *
       * @api private
       */
      _helpAndError() {
        this.outputHelp();
        this._exit(1, "commander.help", "(outputHelp)");
      }
    };
    exports = module2.exports = new Command();
    exports.program = exports;
    exports.Command = Command;
    exports.Option = Option;
    exports.CommanderError = CommanderError;
    function camelcase(flag) {
      return flag.split("-").reduce((str, word) => {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    function pad(str, width) {
      const len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(" ");
    }
    function wrap(str, width, indent) {
      const regex = new RegExp(".{1," + (width - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
      const lines = str.match(regex) || [];
      return lines.map((line, i) => {
        if (line.slice(-1) === "\n") {
          line = line.slice(0, line.length - 1);
        }
        return (i > 0 && indent ? Array(indent + 1).join(" ") : "") + line.trimRight();
      }).join("\n");
    }
    function optionalWrap(str, width, indent) {
      if (str.match(/[\n]\s+/))
        return str;
      const minWidth = 40;
      if (width < minWidth)
        return str;
      return wrap(str, width, indent);
    }
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function humanReadableArgName(arg) {
      const nameOutput = arg.name + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    function _parseOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs8 = require("fs");
    function checkPathExt(path7, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path7.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path7, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path7, options);
    }
    function isexe(path7, options, cb) {
      fs8.stat(path7, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path7, options));
      });
    }
    function sync(path7, options) {
      return checkStat(fs8.statSync(path7), path7, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs8 = require("fs");
    function isexe(path7, options, cb) {
      fs8.stat(path7, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path7, options) {
      return checkStat(fs8.statSync(path7), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs8 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path7, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe(path7, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path7, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path7, options) {
      try {
        return core.sync(path7, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path7 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve2, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path7.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve2, reject) => {
        if (ii === pathExt.length)
          return resolve2(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve2(p + ext);
          }
          return resolve2(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path7.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path7 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path7.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path7;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${code2 + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${38 + offset};5;${code2}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name2, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name2 = matches[1];
        if (matches[2]) {
          const args = parseArguments(name2, matches[2]);
          results.push([name2].concat(args));
        } else {
          results.push([name2]);
        }
      }
      return results;
    }
    function buildStyle(chalk5, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk5;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk5, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk5, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk5, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk6 = {};
      applyOptions(chalk6, options);
      chalk6.template = (...arguments_) => chalkTag(chalk6.template, ...arguments_);
      Object.setPrototypeOf(chalk6, Chalk.prototype);
      Object.setPrototypeOf(chalk6.template, chalk6);
      chalk6.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk6.template.Instance = ChalkClass;
      return chalk6.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk6, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk6, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk5 = Chalk();
    chalk5.supportsColor = stdoutColor;
    chalk5.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk5.stderr.supportsColor = stderrColor;
    module2.exports = chalk5;
  }
});

// node_modules/min-indent/index.js
var require_min_indent = __commonJS({
  "node_modules/min-indent/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string) => {
      const match = string.match(/^[ \t]*(?=\S)/gm);
      if (!match) {
        return 0;
      }
      return match.reduce((r, a) => Math.min(r, a.length), Infinity);
    };
  }
});

// node_modules/strip-indent/index.js
var require_strip_indent = __commonJS({
  "node_modules/strip-indent/index.js"(exports, module2) {
    "use strict";
    var minIndent = require_min_indent();
    module2.exports = (string) => {
      const indent = minIndent(string);
      if (indent === 0) {
        return string;
      }
      const regex = new RegExp(`^[ \\t]{${indent}}`, "gm");
      return string.replace(regex, "");
    };
  }
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/indent-string/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      }
      if (typeof count !== "number") {
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
        );
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  }
});

// node_modules/redent/index.js
var require_redent = __commonJS({
  "node_modules/redent/index.js"(exports, module2) {
    "use strict";
    var stripIndent = require_strip_indent();
    var indentString = require_indent_string();
    module2.exports = (string, count = 0, options) => indentString(stripIndent(string), count, options);
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports = module2.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "node_modules/jszip/lib/support.js"(exports) {
    "use strict";
    exports.base64 = true;
    exports.array = true;
    exports.string = true;
    exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports.nodebuffer = typeof Buffer !== "undefined";
    exports.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports.nodestream = false;
    }
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/jszip/lib/base64.js"(exports) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "node_modules/jszip/lib/nodejsUtils.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size) {
        if (Buffer.alloc) {
          return Buffer.alloc(size);
        } else {
          var buf = new Buffer(size);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  }
});

// node_modules/set-immediate-shim/index.js
var require_set_immediate_shim = __commonJS({
  "node_modules/set-immediate-shim/index.js"(exports, module2) {
    "use strict";
    module2.exports = typeof setImmediate === "function" ? setImmediate : function setImmediate2() {
      var args = [].slice.apply(arguments);
      args.splice(1, 0, 0);
      setTimeout.apply(null, args);
    };
  }
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "node_modules/immediate/lib/index.js"(exports, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/lie/lib/index.js"(exports, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve3, reject2);
      function resolve3(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject2(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result = tryCatch(getThen, value);
      if (result.status === "error") {
        return handlers.reject(self2, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result = tryCatch(tryToUnwrap);
      if (result.status === "error") {
        onError(result.value);
      }
    }
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve2;
    function resolve2(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise2.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "node_modules/jszip/lib/external.js"(exports, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "node_modules/jszip/lib/utils.js"(exports) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var setImmediate2 = require_set_immediate_shim();
    var external = require_external();
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports.newBlob = function(part, type) {
      exports.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = "", code2, i;
      for (i = 0; i < (str || "").length; i++) {
        code2 = str.charCodeAt(i);
        res += "\\x" + (code2 < 16 ? "0" : "") + code2.toString(16).toUpperCase();
      }
      return res;
    };
    exports.delay = function(callback, args, self2) {
      setImmediate2(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports.prepareContent = function(name2, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve2, reject) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve2(e.target.result);
            };
            reader.onerror = function(e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "node_modules/jszip/lib/stream/GenericWorker.js"(exports, module2) {
    "use strict";
    function GenericWorker(name2) {
      this.name = name2 || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk) {
        this.emit("data", chunk);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name2, listener) {
        this._listeners[name2].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name2, arg) {
        if (this._listeners[name2]) {
          for (var i = 0; i < this._listeners[name2].length; i++) {
            this._listeners[name2][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk) {
        this.push(chunk);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!this.extraStreamInfo.hasOwnProperty(key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/jszip/lib/utf8.js"(exports) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var buf2string = function(buf) {
      var str, i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "node_modules/jszip/lib/stream/ConvertWorker.js"(exports, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "node_modules/jszip/lib/stream/StreamHelper.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve2, reject) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject(err);
        }).on("end", function() {
          try {
            var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve2(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk) {
            fn.call(self2, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/jszip/lib/defaults.js"(exports) {
    "use strict";
    exports.base64 = false;
    exports.binary = false;
    exports.dir = false;
    exports.createFolders = true;
    exports.date = null;
    exports.compression = null;
    exports.compressionOptions = null;
    exports.comment = null;
    exports.unixPermissions = null;
    exports.dosPermissions = null;
  }
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "node_modules/jszip/lib/stream/DataWorker.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/jszip/lib/crc32.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "node_modules/jszip/lib/stream/Crc32Probe.js"(exports, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk) {
      this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
      this.push(chunk);
    };
    module2.exports = Crc32Probe;
  }
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "node_modules/jszip/lib/stream/DataLengthProbe.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk) {
      if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk);
    };
    module2.exports = DataLengthProbe;
  }
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/jszip/lib/compressedObject.js"(exports, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/jszip/lib/zipObject.js"(exports, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name2, data, options) {
      this.name = name2;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result = new GenericWorker("error");
          result.error(e);
        }
        return new StreamHelper(result, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code2, len) {
      var res = 0;
      do {
        res |= code2 & 1;
        code2 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code2 = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code2;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code2 = 0; code2 < LENGTH_CODES - 1; code2++) {
        base_length[code2] = length;
        for (n = 0; n < 1 << extra_lbits[code2]; n++) {
          _length_code[length++] = code2;
        }
      }
      _length_code[length - 1] = code2;
      dist = 0;
      for (code2 = 0; code2 < 16; code2++) {
        base_dist[code2] = dist;
        for (n = 0; n < 1 << extra_dbits[code2]; n++) {
          _dist_code[dist++] = code2;
        }
      }
      dist >>= 7;
      for (; code2 < D_CODES; code2++) {
        base_dist[code2] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
          _dist_code[256 + dist++] = code2;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header2) {
      bi_windup(s);
      if (header2) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code2;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code2 = _length_code[lc];
            send_code(s, code2 + LITERALS + 1, ltree);
            extra = extra_lbits[code2];
            if (extra !== 0) {
              lc -= base_length[code2];
              send_bits(s, lc, extra);
            }
            dist--;
            code2 = d_code(dist);
            send_code(s, code2, dtree);
            extra = extra_dbits[code2];
            if (extra !== 0) {
              dist -= base_dist[code2];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header2 = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header2 |= level_flags << 6;
          if (s.strstart !== 0) {
            header2 |= PRESET_DICT;
          }
          header2 += 31 - header2 % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header2);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "node_modules/jszip/lib/flate.js"(exports) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk) {
      this.meta = chunk.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "node_modules/jszip/lib/compressions.js"(exports) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports.STORE = {
      magic: "\0\0",
      compressWorker: function(compressionOptions) {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports.DEFLATE = require_flate();
  }
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "node_modules/jszip/lib/signature.js"(exports) {
    "use strict";
    exports.LOCAL_FILE_HEADER = "PK";
    exports.CENTRAL_FILE_HEADER = "PK";
    exports.CENTRAL_DIRECTORY_END = "PK";
    exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "node_modules/jszip/lib/generate/ZipFileWorker.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions, isDir) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header2 = "";
      header2 += "\n\0";
      header2 += decToHex(bitflag, 2);
      header2 += compression.magic;
      header2 += decToHex(dosTime, 2);
      header2 += decToHex(dosDate, 2);
      header2 += decToHex(dataInfo.crc32, 4);
      header2 += decToHex(dataInfo.compressedSize, 4);
      header2 += decToHex(dataInfo.uncompressedSize, 4);
      header2 += decToHex(encodedFileName.length, 2);
      header2 += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header2 + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header2 + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk) {
      var currentFilePercent = chunk.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk);
      } else {
        this.bytesWritten += chunk.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "node_modules/jszip/lib/generate/index.js"(exports) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports.generateWorker = function(zip2, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip2.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk) {
        self2.push({
          data: chunk,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "node_modules/jszip/lib/object.js"(exports, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name2, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name2 = forceTrailingSlash(name2);
      }
      if (o.createFolders && (parent = parentFolder(name2))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name2, data);
      } else {
        zipObjectContent = utils.prepareContent(name2, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name2, zipObjectContent, o);
      this.files[name2] = object;
    };
    var parentFolder = function(path7) {
      if (path7.slice(-1) === "/") {
        path7 = path7.substring(0, path7.length - 1);
      }
      var lastSlash = path7.lastIndexOf("/");
      return lastSlash > 0 ? path7.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path7) {
      if (path7.slice(-1) !== "/") {
        path7 += "/";
      }
      return path7;
    };
    var folderAdd = function(name2, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name2 = forceTrailingSlash(name2);
      if (!this.files[name2]) {
        fileAdd.call(this, name2, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name2];
    };
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name2, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name2)) {
            var regexp = name2;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name2];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name2 = this.root + name2;
          fileAdd.call(this, name2, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name2 = this.root + arg;
        var newFolder = folderAdd.call(this, name2);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name2) {
        name2 = this.root + name2;
        var file = this.files[name2];
        if (!file) {
          if (name2.slice(-1) !== "/") {
            name2 += "/";
          }
          file = this.files[name2];
        }
        if (file && !file.dir) {
          delete this.files[name2];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name2.length) === name2;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * Generate the complete zip file
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
       */
      generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "node_modules/jszip/lib/reader/DataReader.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function(i) {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size) {
        var result = 0, i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size) {
        return utils.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function(size) {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function(sig) {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function(sig) {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          (dostime >> 21 & 15) - 1,
          dostime >> 16 & 31,
          dostime >> 11 & 31,
          dostime >> 5 & 63,
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/ArrayReader.js"(exports, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = ArrayReader;
  }
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "node_modules/jszip/lib/reader/StringReader.js"(exports, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = StringReader;
  }
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "node_modules/jszip/lib/reader/NodeBufferReader.js"(exports, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = NodeBufferReader;
  }
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "node_modules/jszip/lib/reader/readerFor.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/jszip/lib/zipEntry.js"(exports, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function(reader) {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/jszip/lib/zipEntries.js"(exports, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var utf8 = require_utf8();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "node_modules/jszip/lib/load.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve2, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve2();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip2 = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          zip2.file(input.fileNameStr, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
        }
        if (zipEntries.zipComment.length) {
          zip2.comment = zipEntries.zipComment;
        }
        return zip2;
      });
    };
  }
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jszip/lib/index.js"(exports, module2) {
    "use strict";
    function JSZip() {
      if (!(this instanceof JSZip)) {
        return new JSZip();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip.prototype = require_object();
    JSZip.prototype.loadAsync = require_load();
    JSZip.support = require_support();
    JSZip.defaults = require_defaults();
    JSZip.version = "3.7.0";
    JSZip.loadAsync = function(content, options) {
      return new JSZip().loadAsync(content, options);
    };
    JSZip.external = require_external();
    module2.exports = JSZip;
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs8 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync2(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs8.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs8.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs8.statSync(base);
            linkTarget = fs8.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs8.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs8.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs8.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs8.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync2;
    realpath.realpathSync = realpathSync2;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs8 = require("fs");
    var origRealpath = fs8.realpath;
    var origRealpathSync = fs8.realpathSync;
    var version2 = process.version;
    var ok = /^v[0-5]\./.test(version2);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync2(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs8.realpath = realpath;
      fs8.realpathSync = realpathSync2;
    }
    function unmonkeypatch() {
      fs8.realpath = origRealpath;
      fs8.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path7 = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path7.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path7.sep !== "/") {
        pattern = pattern.split(path7.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path7.sep !== "/") {
        f = f.split(path7.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path7) {
      return path7.charAt(0) === "/";
    }
    function win32(path7) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path7);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/glob/common.js"(exports) {
    exports.alphasort = alphasort;
    exports.alphasorti = alphasorti;
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path7 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path7.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path7.resolve(self2.cwd, "/");
      self2.root = path7.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path7.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path7.resolve(self2.cwd, f);
      } else {
        abs = path7.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path8) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path8) || !!(item.gmatcher && item.gmatcher.match(path8));
      });
    }
    function childrenIgnored(self2, path8) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path8));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync2;
    var fs8 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path7 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync2(pattern, options).found;
    }
    function GlobSync2(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync2))
        return new GlobSync2(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync2.prototype._finish = function() {
      assert(this instanceof GlobSync2);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync2.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync2);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync2.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path7.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync2.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync2.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs8.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync2.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs8.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync2.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync2.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync2.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync2.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path7.join(this.root, prefix);
        } else {
          prefix = path7.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync2.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs8.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = fs8.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync2.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync2.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name2 = fn.name || "Function wrapped with `once`";
      f.onceError = name2 + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob;
    var fs8 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path7 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync2 = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync2(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path7.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs8.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs8.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path7.join(this.root, prefix);
        } else {
          prefix = path7.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs8.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs8.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// src/main.ts
var import_commander = __toESM(require_commander());
var import_path5 = __toESM(require("path"));

// src/constants.ts
var import_path = __toESM(require("path"));
var PATH = {
  INSTALL_DIR: import_path.default.resolve(__dirname, ".."),
  PACKAGE: "package.json",
  TSCONFIG: "tsconfig.json"
};
var CONFIG_KEY = {
  NASHORN: "nashorn"
};

// src/utils.ts
var import_child_process = require("child_process");
var fs = __toESM(require("fs"));
var path2 = __toESM(require("path"));
var import_which = __toESM(require_which());
function listFilesByExt(dirname, ext) {
  if (fs.existsSync(dirname)) {
    if (fs.lstatSync(dirname).isDirectory()) {
      return fs.readdirSync(dirname).filter((it) => it.endsWith(ext)).map((it) => path2.join(dirname, it));
    } else {
      return [];
    }
  } else {
    return [];
  }
}
function readJSON(path7) {
  if (fs.existsSync(path7)) {
    const content = fs.readFileSync(path7, "utf-8");
    return JSON.parse(content);
  } else {
    return {};
  }
}
function realPath(command) {
  const fullPath = import_which.default.sync(command);
  if (fs.lstatSync(fullPath).isSymbolicLink()) {
    return fs.realpathSync(fullPath);
  } else {
    return fullPath;
  }
}
function javap(classPaths, classList) {
  const child = (0, import_child_process.spawnSync)("javap", ["-package", "-cp", ":" + classPaths.join(":"), ...classList]);
  if (child.status === 0) {
    return child.stdout.toString();
  } else {
    throw new Error(child.stderr.toString());
  }
}
function locateJdk(runtime) {
  const fullPath = realPath(runtime);
  const child = (0, import_child_process.spawnSync)(runtime, ["--version:graalvm"]);
  if (child.status === 0) {
    return ["graaljs", path2.resolve(fullPath, "..", "..", "..", "..")];
  } else {
    return ["nashorn", path2.resolve(fullPath, "..", "..")];
  }
}

// src/errors.ts
var code = {
  BROKEN_ENV: 1,
  UNKNOWN_RUNTIME: 2,
  INVALID_ARGUMENT: 3,
  BUILD_ERROR: 4,
  INIT_CONFLICT: 5,
  PROJECT_NOT_FOUND: 6
};

// src/commands/build.ts
function build_default(entries, outDir, watch) {
  const compiler = getCompiler(entries, outDir);
  const printStats = (stats) => console.log(
    stats?.toString({
      colors: true,
      chunks: false,
      entrypoints: true,
      modules: false
    })
  );
  if (watch) {
    compiler.watch({ poll: true }, (err, stats) => {
      printStats(stats);
    });
  } else {
    compiler.run((err, stats) => {
      printStats(stats);
      if (stats?.hasErrors())
        process.exit(code.BUILD_ERROR);
    });
  }
}

// src/commands/init.ts
var import_child_process2 = require("child_process");
var import_chalk = __toESM(require_source());
var import_fs = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
function init_default() {
  console.log("Checking prerequisites...\n");
  if (!check("node", ["-v"]) || !check("npm", ["-v"]) || !check("gradle", ["-v"])) {
    console.error(import_chalk.default.red("You should add node, npm and gradle in `PATH` env."));
    process.exit(code.BROKEN_ENV);
  }
  if (import_fs.default.existsSync(PATH.PACKAGE)) {
    console.error(import_chalk.default.yellow(PATH.PACKAGE + " already exists."));
    process.exit(code.INIT_CONFLICT);
  } else if (import_fs.default.existsSync(PATH.TSCONFIG)) {
    console.error(import_chalk.default.yellow(PATH.TSCONFIG + " already exists."));
    process.exit(code.INIT_CONFLICT);
  } else {
    createFiles();
    console.log(`Initialized project in ${process.cwd()}`);
  }
}
function createFiles() {
  import_fs.default.writeFileSync(
    PATH.PACKAGE,
    JSON.stringify(
      {
        dependencies: {},
        mvnDependencies: {},
        config: {
          [CONFIG_KEY.NASHORN]: "jjs"
        }
      },
      null,
      2
    )
  );
  import_fs.default.writeFileSync(
    PATH.TSCONFIG,
    JSON.stringify(
      {
        compilerOptions: {
          typeRoots: [import_path2.default.join(PATH.INSTALL_DIR, "@types"), "lib", "node_modules/@types"]
        },
        include: ["**/*.ts"]
      },
      null,
      2
    )
  );
  import_fs.default.mkdirSync("src", { recursive: true });
  if (!import_fs.default.existsSync(import_path2.default.join("src", "main.ts"))) {
    const src = 'java.lang.System.out.println("Hello")';
    import_fs.default.writeFileSync(import_path2.default.join("src", "main.ts"), src);
  }
}
function check(command, args) {
  const { status, stdout, stderr } = (0, import_child_process2.spawnSync)(command, args);
  if (status === 0) {
    console.log(import_chalk.default.green(`[${command}]`));
    console.log(stdout.toString().replace(/\n+/g, "\n").trim() + "\n");
    return true;
  } else {
    console.log(import_chalk.default.red(`[${command}]`));
    const message = stderr?.toString().trim() || stdout?.toString().trim();
    if (message) {
      console.log(message + "\n");
    } else {
      console.log(import_chalk.default.gray("NOT FOUND\n"));
    }
    return false;
  }
}

// src/commands/install.ts
var import_chalk3 = __toESM(require_source());
var import_fs5 = __toESM(require("fs"));
var import_path4 = __toESM(require("path"));
var import_redent = __toESM(require_redent());
var import_jszip = __toESM(require_lib3());
var import_glob = __toESM(require_glob());
var import_child_process3 = require("child_process");

// node_modules/antlr4/src/antlr4/utils/stringHashCode.js
String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));
String.prototype.hashCode = function() {
  const key = this.toString();
  let h1b, k1;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  let h1 = String.prototype.seed;
  const c1 = 3432918353;
  const c2 = 461845907;
  let i = 0;
  while (i < bytes) {
    k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(++i) & 255) << 8 | (key.charCodeAt(++i) & 255) << 16 | (key.charCodeAt(++i) & 255) << 24;
    ++i;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(i + 2) & 255) << 16;
    case 2:
      k1 ^= (key.charCodeAt(i + 1) & 255) << 8;
    case 1:
      k1 ^= key.charCodeAt(i) & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
};

// node_modules/antlr4/src/antlr4/polyfills/codepointat.js
if (!String.prototype.codePointAt) {
  (function() {
    "use strict";
    var defineProperty = function() {
      let result;
      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    const codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      const string = String(this);
      const size = string.length;
      let index = position ? Number(position) : 0;
      if (index !== index) {
        index = 0;
      }
      if (index < 0 || index >= size) {
        return void 0;
      }
      const first = string.charCodeAt(index);
      let second;
      if (// check if its the start of a surrogate pair
      first >= 55296 && first <= 56319 && // high surrogate
      size > index + 1) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}

// node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js
if (!String.fromCodePoint) {
  (function() {
    const defineProperty = function() {
      let result;
      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    const stringFromCharCode = String.fromCharCode;
    const floor = Math.floor;
    const fromCodePoint = function(_) {
      const MAX_SIZE = 16384;
      const codeUnits = [];
      let highSurrogate;
      let lowSurrogate;
      let index = -1;
      const length = arguments.length;
      if (!length) {
        return "";
      }
      let result = "";
      while (++index < length) {
        let codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 1114111 || // not a valid Unicode code point
        floor(codePoint) !== codePoint) {
          throw RangeError("Invalid code point: " + codePoint);
        }
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          highSurrogate = (codePoint >> 10) + 55296;
          lowSurrogate = codePoint % 1024 + 56320;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    if (defineProperty) {
      defineProperty(String, "fromCodePoint", {
        "value": fromCodePoint,
        "configurable": true,
        "writable": true
      });
    } else {
      String.fromCodePoint = fromCodePoint;
    }
  })();
}

// node_modules/antlr4/src/antlr4/Token.js
var Token = class {
  constructor() {
    this.source = null;
    this.type = null;
    this.channel = null;
    this.start = null;
    this.stop = null;
    this.tokenIndex = null;
    this.line = null;
    this.column = null;
    this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(text) {
    this._text = text;
  }
};
Token.INVALID_TYPE = 0;
Token.EPSILON = -2;
Token.MIN_USER_TOKEN_TYPE = 1;
Token.EOF = -1;
Token.DEFAULT_CHANNEL = 0;
Token.HIDDEN_CHANNEL = 1;

// node_modules/antlr4/src/antlr4/utils/equalArrays.js
function equalArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b))
    return false;
  if (a === b)
    return true;
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] === b[i])
      continue;
    if (!a[i].equals || !a[i].equals(b[i]))
      return false;
  }
  return true;
}

// node_modules/antlr4/src/antlr4/misc/HashCode.js
var HashCode = class {
  constructor() {
    this.count = 0;
    this.hash = 0;
  }
  update() {
    for (let i = 0; i < arguments.length; i++) {
      const value = arguments[i];
      if (value == null)
        continue;
      if (Array.isArray(value))
        this.update.apply(this, value);
      else {
        let k = 0;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
          case "boolean":
            k = value;
            break;
          case "string":
            k = value.hashCode();
            break;
          default:
            if (value.updateHashCode)
              value.updateHashCode(this);
            else
              console.log("No updateHashCode for " + value.toString());
            continue;
        }
        k = k * 3432918353;
        k = k << 15 | k >>> 32 - 15;
        k = k * 461845907;
        this.count = this.count + 1;
        let hash = this.hash ^ k;
        hash = hash << 13 | hash >>> 32 - 13;
        hash = hash * 5 + 3864292196;
        this.hash = hash;
      }
    }
  }
  finish() {
    let hash = this.hash ^ this.count * 4;
    hash = hash ^ hash >>> 16;
    hash = hash * 2246822507;
    hash = hash ^ hash >>> 13;
    hash = hash * 3266489909;
    hash = hash ^ hash >>> 16;
    return hash;
  }
  static hashStuff() {
    const hash = new HashCode();
    hash.update.apply(hash, arguments);
    return hash.finish();
  }
};

// node_modules/antlr4/src/antlr4/utils/standardHashCodeFunction.js
function standardHashCodeFunction(a) {
  return a ? a.hashCode() : -1;
}

// node_modules/antlr4/src/antlr4/utils/standardEqualsFunction.js
function standardEqualsFunction(a, b) {
  return a ? a.equals(b) : a === b;
}

// node_modules/antlr4/src/antlr4/utils/valueToString.js
function valueToString(v) {
  return v === null ? "null" : v;
}

// node_modules/antlr4/src/antlr4/utils/arrayToString.js
function arrayToString(a) {
  return Array.isArray(a) ? "[" + a.map(valueToString).join(", ") + "]" : "null";
}

// node_modules/antlr4/src/antlr4/misc/HashSet.js
var HASH_KEY_PREFIX = "h-";
var HashSet = class {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  add(value) {
    const key = HASH_KEY_PREFIX + this.hashFunction(value);
    if (key in this.data) {
      const values = this.data[key];
      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }
      values.push(value);
      return value;
    } else {
      this.data[key] = [value];
      return value;
    }
  }
  has(value) {
    return this.get(value) != null;
  }
  get(value) {
    const key = HASH_KEY_PREFIX + this.hashFunction(value);
    if (key in this.data) {
      const values = this.data[key];
      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }
    }
    return null;
  }
  values() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX)).flatMap((key) => this.data[key], this);
  }
  toString() {
    return arrayToString(this.values());
  }
  get length() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX)).map((key) => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
  }
};

// node_modules/antlr4/src/antlr4/atn/SemanticContext.js
var SemanticContext = class {
  hashCode() {
    const hash = new HashCode();
    this.updateHashCode(hash);
    return hash.finish();
  }
  /**
   * For context independent predicates, we evaluate them without a local
   * context (i.e., null context). That way, we can evaluate them without
   * having to create proper rule-specific context during prediction (as
   * opposed to the parser, which creates them naturally). In a practical
   * sense, this avoids a cast exception from RuleContext to myruleContext.
   *
   * <p>For context dependent predicates, we must pass in a local context so that
   * references such as $arg evaluate properly as _localctx.arg. We only
   * capture context dependent predicates in the context in which we begin
   * prediction, so we passed in the outer context here in case of context
   * dependent predicate evaluation.</p>
   */
  evaluate(parser, outerContext) {
  }
  /**
   * Evaluate the precedence predicates for the context and reduce the result.
   *
   * @param parser The parser instance.
   * @param outerContext The current parser context object.
   * @return The simplified semantic context after precedence predicates are
   * evaluated, which will be one of the following values.
   * <ul>
   * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
   * precedence predicates are evaluated.</li>
   * <li>{@code null}: if the predicate simplifies to {@code false} after
   * precedence predicates are evaluated.</li>
   * <li>{@code this}: if the semantic context is not changed as a result of
   * precedence predicate evaluation.</li>
   * <li>A non-{@code null} {@link SemanticContext}: the new simplified
   * semantic context after precedence predicates are evaluated.</li>
   * </ul>
   */
  evalPrecedence(parser, outerContext) {
    return this;
  }
  static andContext(a, b) {
    if (a === null || a === SemanticContext.NONE) {
      return b;
    }
    if (b === null || b === SemanticContext.NONE) {
      return a;
    }
    const result = new AND(a, b);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
  static orContext(a, b) {
    if (a === null) {
      return b;
    }
    if (b === null) {
      return a;
    }
    if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
      return SemanticContext.NONE;
    }
    const result = new OR(a, b);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
};
var AND = class extends SemanticContext {
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false
   */
  constructor(a, b) {
    super();
    const operands = new HashSet();
    if (a instanceof AND) {
      a.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof AND) {
      b.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      let reduced = null;
      precedencePredicates.map(function(p) {
        if (reduced === null || p.precedence < reduced.precedence) {
          reduced = p;
        }
      });
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof AND)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash) {
    hash.update(this.opnds, "AND");
  }
  /**
   * {@inheritDoc}
   *
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (!this.opnds[i].evaluate(parser, outerContext)) {
        return false;
      }
    }
    return true;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === null) {
        return null;
      } else if (evaluated !== SemanticContext.NONE) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return SemanticContext.NONE;
    }
    let result = null;
    operands.map(function(o) {
      result = result === null ? o : SemanticContext.andContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.opnds.map((o) => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("&&");
  }
};
var OR = class extends SemanticContext {
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true
   */
  constructor(a, b) {
    super();
    const operands = new HashSet();
    if (a instanceof OR) {
      a.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof OR) {
      b.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      const s = precedencePredicates.sort(function(a2, b2) {
        return a2.compareTo(b2);
      });
      const reduced = s[s.length - 1];
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof OR)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash) {
    hash.update(this.opnds, "OR");
  }
  /**
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (this.opnds[i].evaluate(parser, outerContext)) {
        return true;
      }
    }
    return false;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === SemanticContext.NONE) {
        return SemanticContext.NONE;
      } else if (evaluated !== null) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return null;
    }
    const result = null;
    operands.map(function(o) {
      return result === null ? o : SemanticContext.orContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.opnds.map((o) => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("||");
  }
};
function filterPrecedencePredicates(set) {
  const result = [];
  set.values().map(function(context) {
    if (context instanceof SemanticContext.PrecedencePredicate) {
      result.push(context);
    }
  });
  return result;
}

// node_modules/antlr4/src/antlr4/atn/ATNConfig.js
function checkParams(params, isCfg) {
  if (params === null) {
    const result = { state: null, alt: null, context: null, semanticContext: null };
    if (isCfg) {
      result.reachesIntoOuterContext = 0;
    }
    return result;
  } else {
    const props = {};
    props.state = params.state || null;
    props.alt = params.alt === void 0 ? null : params.alt;
    props.context = params.context || null;
    props.semanticContext = params.semanticContext || null;
    if (isCfg) {
      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
    }
    return props;
  }
}
var ATNConfig = class {
  /**
   * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
   * The syntactic context is a graph-structured stack node whose
   * path(s) to the root is the rule invocation(s)
   * chain used to arrive at the state.  The semantic context is
   * the tree of semantic predicates encountered before reaching
   * an ATN state
   */
  constructor(params, config) {
    this.checkContext(params, config);
    params = checkParams(params);
    config = checkParams(config, true);
    this.state = params.state !== null ? params.state : config.state;
    this.alt = params.alt !== null ? params.alt : config.alt;
    this.context = params.context !== null ? params.context : config.context;
    this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE;
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
  }
  checkContext(params, config) {
    if ((params.context === null || params.context === void 0) && (config === null || config.context === null || config.context === void 0)) {
      this.context = null;
    }
  }
  hashCode() {
    const hash = new HashCode();
    this.updateHashCode(hash);
    return hash.finish();
  }
  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  /**
   * An ATN configuration is equal to another if both have
   * the same state, they predict the same alternative, and
   * syntactic/semantic contexts are the same
   */
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
    }
  }
  hashCodeForConfigSet() {
    const hash = new HashCode();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
  }
  equalsForConfigSet(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);
    }
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};

// node_modules/antlr4/src/antlr4/misc/Interval.js
var Interval = class {
  constructor(start, stop) {
    this.start = start;
    this.stop = stop;
  }
  clone() {
    return new Interval(this.start, this.stop);
  }
  contains(item) {
    return item >= this.start && item < this.stop;
  }
  toString() {
    if (this.start === this.stop - 1) {
      return this.start.toString();
    } else {
      return this.start.toString() + ".." + (this.stop - 1).toString();
    }
  }
  get length() {
    return this.stop - this.start;
  }
};
Interval.INVALID_INTERVAL = new Interval(-1, -2);

// node_modules/antlr4/src/antlr4/misc/IntervalSet.js
var IntervalSet = class {
  constructor() {
    this.intervals = null;
    this.readOnly = false;
  }
  first(v) {
    if (this.intervals === null || this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    } else {
      return this.intervals[0].start;
    }
  }
  addOne(v) {
    this.addInterval(new Interval(v, v + 1));
  }
  addRange(l, h) {
    this.addInterval(new Interval(l, h + 1));
  }
  addInterval(toAdd) {
    if (this.intervals === null) {
      this.intervals = [];
      this.intervals.push(toAdd.clone());
    } else {
      for (let pos = 0; pos < this.intervals.length; pos++) {
        const existing = this.intervals[pos];
        if (toAdd.stop < existing.start) {
          this.intervals.splice(pos, 0, toAdd);
          return;
        } else if (toAdd.stop === existing.start) {
          this.intervals[pos] = new Interval(toAdd.start, existing.stop);
          return;
        } else if (toAdd.start <= existing.stop) {
          this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
          this.reduce(pos);
          return;
        }
      }
      this.intervals.push(toAdd.clone());
    }
  }
  addSet(other) {
    if (other.intervals !== null) {
      other.intervals.forEach((toAdd) => this.addInterval(toAdd), this);
    }
    return this;
  }
  reduce(pos) {
    if (pos < this.intervals.length - 1) {
      const current = this.intervals[pos];
      const next = this.intervals[pos + 1];
      if (current.stop >= next.stop) {
        this.intervals.splice(pos + 1, 1);
        this.reduce(pos);
      } else if (current.stop >= next.start) {
        this.intervals[pos] = new Interval(current.start, next.stop);
        this.intervals.splice(pos + 1, 1);
      }
    }
  }
  complement(start, stop) {
    const result = new IntervalSet();
    result.addInterval(new Interval(start, stop + 1));
    if (this.intervals !== null)
      this.intervals.forEach((toRemove) => result.removeRange(toRemove));
    return result;
  }
  contains(item) {
    if (this.intervals === null) {
      return false;
    } else {
      for (let k = 0; k < this.intervals.length; k++) {
        if (this.intervals[k].contains(item)) {
          return true;
        }
      }
      return false;
    }
  }
  removeRange(toRemove) {
    if (toRemove.start === toRemove.stop - 1) {
      this.removeOne(toRemove.start);
    } else if (this.intervals !== null) {
      let pos = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        const existing = this.intervals[pos];
        if (toRemove.stop <= existing.start) {
          return;
        } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
          const x = new Interval(toRemove.stop, existing.stop);
          this.intervals.splice(pos, 0, x);
          return;
        } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
          this.intervals.splice(pos, 1);
          pos = pos - 1;
        } else if (toRemove.start < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
        } else if (toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
        }
        pos += 1;
      }
    }
  }
  removeOne(value) {
    if (this.intervals !== null) {
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        if (value < existing.start) {
          return;
        } else if (value === existing.start && value === existing.stop - 1) {
          this.intervals.splice(i, 1);
          return;
        } else if (value === existing.start) {
          this.intervals[i] = new Interval(existing.start + 1, existing.stop);
          return;
        } else if (value === existing.stop - 1) {
          this.intervals[i] = new Interval(existing.start, existing.stop - 1);
          return;
        } else if (value < existing.stop - 1) {
          const replace = new Interval(existing.start, value);
          existing.start = value + 1;
          this.intervals.splice(i, 0, replace);
          return;
        }
      }
    }
  }
  toString(literalNames, symbolicNames, elemsAreChar) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    elemsAreChar = elemsAreChar || false;
    if (this.intervals === null) {
      return "{}";
    } else if (literalNames !== null || symbolicNames !== null) {
      return this.toTokenString(literalNames, symbolicNames);
    } else if (elemsAreChar) {
      return this.toCharString();
    } else {
      return this.toIndexString();
    }
  }
  toCharString() {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push("'" + String.fromCharCode(existing.start) + "'");
        }
      } else {
        names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  toIndexString() {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push(existing.start.toString());
        }
      } else {
        names.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  toTokenString(literalNames, symbolicNames) {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      for (let j = existing.start; j < existing.stop; j++) {
        names.push(this.elementName(literalNames, symbolicNames, j));
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  elementName(literalNames, symbolicNames, token) {
    if (token === Token.EOF) {
      return "<EOF>";
    } else if (token === Token.EPSILON) {
      return "<EPSILON>";
    } else {
      return literalNames[token] || symbolicNames[token];
    }
  }
  get length() {
    return this.intervals.map((interval) => interval.length).reduce((acc, val) => acc + val);
  }
};

// node_modules/antlr4/src/antlr4/state/ATNState.js
var ATNState = class {
  constructor() {
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0;
    this.epsilonOnlyTransitions = false;
    this.transitions = [];
    this.nextTokenWithinRule = null;
  }
  toString() {
    return this.stateNumber;
  }
  equals(other) {
    if (other instanceof ATNState) {
      return this.stateNumber === other.stateNumber;
    } else {
      return false;
    }
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(trans, index) {
    if (index === void 0) {
      index = -1;
    }
    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }
    if (index === -1) {
      this.transitions.push(trans);
    } else {
      this.transitions.splice(index, 1, trans);
    }
  }
};
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;
ATNState.serializationNames = [
  "INVALID",
  "BASIC",
  "RULE_START",
  "BLOCK_START",
  "PLUS_BLOCK_START",
  "STAR_BLOCK_START",
  "TOKEN_START",
  "RULE_STOP",
  "BLOCK_END",
  "STAR_LOOP_BACK",
  "STAR_LOOP_ENTRY",
  "PLUS_LOOP_BACK",
  "LOOP_END"
];
ATNState.INVALID_STATE_NUMBER = -1;

// node_modules/antlr4/src/antlr4/state/RuleStopState.js
var RuleStopState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_STOP;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/transition/Transition.js
var Transition = class {
  constructor(target) {
    if (target === void 0 || target === null) {
      throw "target cannot be null.";
    }
    this.target = target;
    this.isEpsilon = false;
    this.label = null;
  }
};
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;
Transition.serializationNames = [
  "INVALID",
  "EPSILON",
  "RANGE",
  "RULE",
  "PREDICATE",
  "ATOM",
  "ACTION",
  "SET",
  "NOT_SET",
  "WILDCARD",
  "PRECEDENCE"
];
Transition.serializationTypes = {
  EpsilonTransition: Transition.EPSILON,
  RangeTransition: Transition.RANGE,
  RuleTransition: Transition.RULE,
  PredicateTransition: Transition.PREDICATE,
  AtomTransition: Transition.ATOM,
  ActionTransition: Transition.ACTION,
  SetTransition: Transition.SET,
  NotSetTransition: Transition.NOT_SET,
  WildcardTransition: Transition.WILDCARD,
  PrecedencePredicateTransition: Transition.PRECEDENCE
};

// node_modules/antlr4/src/antlr4/transition/RuleTransition.js
var RuleTransition = class extends Transition {
  constructor(ruleStart, ruleIndex, precedence, followState) {
    super(ruleStart);
    this.ruleIndex = ruleIndex;
    this.precedence = precedence;
    this.followState = followState;
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
};

// node_modules/antlr4/src/antlr4/transition/SetTransition.js
var SetTransition = class extends Transition {
  constructor(target, set) {
    super(target);
    this.serializationType = Transition.SET;
    if (set !== void 0 && set !== null) {
      this.label = set;
    } else {
      this.label = new IntervalSet();
      this.label.addOne(Token.INVALID_TYPE);
    }
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label.contains(symbol);
  }
  toString() {
    return this.label.toString();
  }
};

// node_modules/antlr4/src/antlr4/transition/NotSetTransition.js
var NotSetTransition = class extends SetTransition {
  constructor(target, set) {
    super(target, set);
    this.serializationType = Transition.NOT_SET;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
  }
  toString() {
    return "~" + super.toString();
  }
};

// node_modules/antlr4/src/antlr4/transition/WildcardTransition.js
var WildcardTransition = class extends Transition {
  constructor(target) {
    super(target);
    this.serializationType = Transition.WILDCARD;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
  }
  toString() {
    return ".";
  }
};

// node_modules/antlr4/src/antlr4/atn/AbstractPredicateTransition.js
var AbstractPredicateTransition = class extends Transition {
  constructor(target) {
    super(target);
  }
};

// node_modules/antlr4/src/antlr4/tree/Tree.js
var Tree = class {
};

// node_modules/antlr4/src/antlr4/tree/SyntaxTree.js
var SyntaxTree = class extends Tree {
};

// node_modules/antlr4/src/antlr4/tree/ParseTree.js
var ParseTree = class extends SyntaxTree {
};

// node_modules/antlr4/src/antlr4/tree/RuleNode.js
var RuleNode = class extends ParseTree {
  getRuleContext() {
    throw new Error("missing interface implementation");
  }
};

// node_modules/antlr4/src/antlr4/tree/TerminalNode.js
var TerminalNode = class extends ParseTree {
};

// node_modules/antlr4/src/antlr4/tree/ErrorNode.js
var ErrorNode = class extends TerminalNode {
};

// node_modules/antlr4/src/antlr4/utils/escapeWhitespace.js
function escapeWhitespace(s, escapeSpaces) {
  s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  if (escapeSpaces) {
    s = s.replace(/ /g, "\xB7");
  }
  return s;
}

// node_modules/antlr4/src/antlr4/tree/Trees.js
var Trees = {
  /**
   * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
   *  node payloads to get the text for the nodes.  Detect
   *  parse trees and extract data appropriately.
   */
  toStringTree: function(tree, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    let s = Trees.getNodeText(tree, ruleNames);
    s = escapeWhitespace(s, false);
    const c = tree.getChildCount();
    if (c === 0) {
      return s;
    }
    let res = "(" + s + " ";
    if (c > 0) {
      s = Trees.toStringTree(tree.getChild(0), ruleNames);
      res = res.concat(s);
    }
    for (let i = 1; i < c; i++) {
      s = Trees.toStringTree(tree.getChild(i), ruleNames);
      res = res.concat(" " + s);
    }
    res = res.concat(")");
    return res;
  },
  getNodeText: function(t, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    if (ruleNames !== null) {
      if (t instanceof RuleNode) {
        const context = t.getRuleContext();
        const altNumber = context.getAltNumber();
        if (altNumber != 0) {
          return ruleNames[t.ruleIndex] + ":" + altNumber;
        }
        return ruleNames[t.ruleIndex];
      } else if (t instanceof ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode) {
        if (t.symbol !== null) {
          return t.symbol.text;
        }
      }
    }
    const payload = t.getPayload();
    if (payload instanceof Token) {
      return payload.text;
    }
    return t.getPayload().toString();
  },
  /**
   * Return ordered list of all children of this node
   */
  getChildren: function(t) {
    const list = [];
    for (let i = 0; i < t.getChildCount(); i++) {
      list.push(t.getChild(i));
    }
    return list;
  },
  /**
   * Return a list of all ancestors of this node.  The first node of
   * list is the root and the last is the parent of this node.
   */
  getAncestors: function(t) {
    let ancestors = [];
    t = t.getParent();
    while (t !== null) {
      ancestors = [t].concat(ancestors);
      t = t.getParent();
    }
    return ancestors;
  },
  findAllTokenNodes: function(t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
  },
  findAllRuleNodes: function(t, ruleIndex) {
    return Trees.findAllNodes(t, ruleIndex, false);
  },
  findAllNodes: function(t, index, findTokens) {
    const nodes = [];
    Trees._findAllNodes(t, index, findTokens, nodes);
    return nodes;
  },
  _findAllNodes: function(t, index, findTokens, nodes) {
    if (findTokens && t instanceof TerminalNode) {
      if (t.symbol.type === index) {
        nodes.push(t);
      }
    } else if (!findTokens && t instanceof RuleNode) {
      if (t.ruleIndex === index) {
        nodes.push(t);
      }
    }
    for (let i = 0; i < t.getChildCount(); i++) {
      Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
    }
  },
  descendants: function(t) {
    let nodes = [t];
    for (let i = 0; i < t.getChildCount(); i++) {
      nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
  }
};
var Trees_default = Trees;

// node_modules/antlr4/src/antlr4/context/RuleContext.js
var RuleContext = class extends RuleNode {
  /** A rule context is a record of a single rule invocation. It knows
   * which context invoked it, if any. If there is no parent context, then
   * naturally the invoking state is not valid.  The parent link
   * provides a chain upwards from the current rule invocation to the root
   * of the invocation tree, forming a stack. We actually carry no
   * information about the rule associated with this context (except
   * when parsing). We keep only the state number of the invoking state from
   * the ATN submachine that invoked this. Contrast this with the s
   * pointer inside ParserRuleContext that tracks the current state
   * being "executed" for the current rule.
   *
   * The parent contexts are useful for computing lookahead sets and
   * getting error information.
   *
   * These objects are used during parsing and prediction.
   * For the special case of parsers, we use the subclass
   * ParserRuleContext.
   *
   * @see ParserRuleContext
   */
  constructor(parent, invokingState) {
    super();
    this.parentCtx = parent || null;
    this.invokingState = invokingState || -1;
  }
  depth() {
    let n = 0;
    let p = this;
    while (p !== null) {
      p = p.parentCtx;
      n += 1;
    }
    return n;
  }
  /**
   * A context is empty if there is no invoking state; meaning nobody call
   * current context.
   */
  isEmpty() {
    return this.invokingState === -1;
  }
  // satisfy the ParseTree / SyntaxTree interface
  getSourceInterval() {
    return Interval.INVALID_INTERVAL;
  }
  getRuleContext() {
    return this;
  }
  getPayload() {
    return this;
  }
  /**
   * Return the combined text of all child nodes. This method only considers
   * tokens which have been added to the parse tree.
   * <p>
   * Since tokens on hidden channels (e.g. whitespace or comments) are not
   * added to the parse trees, they will not appear in the output of this
   * method.
   */
  getText() {
    if (this.getChildCount() === 0) {
      return "";
    } else {
      return this.children.map(function(child) {
        return child.getText();
      }).join("");
    }
  }
  /**
   * For rule associated with this parse tree internal node, return
   * the outer alternative number used to match the input. Default
   * implementation does not compute nor store this alt num. Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   * to set it.
   */
  getAltNumber() {
    return 0;
  }
  /**
   * Set the outer alternative number for this context node. Default
   * implementation does nothing to avoid backing field overhead for
   * trees that don't need it.  Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   */
  setAltNumber(altNumber) {
  }
  getChild(i) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitChildren(this);
  }
  /**
   * Print out a whole tree, not just a node, in LISP format
   * (root child1 .. childN). Print just a node if this is a leaf.
   */
  toStringTree(ruleNames, recog) {
    return Trees_default.toStringTree(this, ruleNames, recog);
  }
  toString(ruleNames, stop) {
    ruleNames = ruleNames || null;
    stop = stop || null;
    let p = this;
    let s = "[";
    while (p !== null && p !== stop) {
      if (ruleNames === null) {
        if (!p.isEmpty()) {
          s += p.invokingState;
        }
      } else {
        const ri = p.ruleIndex;
        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
        s += ruleName;
      }
      if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
        s += " ";
      }
      p = p.parentCtx;
    }
    s += "]";
    return s;
  }
};

// node_modules/antlr4/src/antlr4/context/PredictionContext.js
var PredictionContext = class {
  constructor(cachedHashCode) {
    this.cachedHashCode = cachedHashCode;
  }
  /**
   * Stores the computed hash code of this {@link PredictionContext}. The hash
   * code is computed in parts to match the following reference algorithm.
   *
   * <pre>
   * private int referenceHashCode() {
   * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
   * //INITIAL_HASH});
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
   * getParent}(i));
   * }
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
   * //getReturnState getReturnState}(i));
   * }
   *
   * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
   * //size()});
   * return hash;
   * }
   * </pre>
   * This means only the {@link //EMPTY} context is in set.
   */
  isEmpty() {
    return this === PredictionContext.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }
};
PredictionContext.EMPTY = null;
PredictionContext.EMPTY_RETURN_STATE = 2147483647;
PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// node_modules/antlr4/src/antlr4/context/ArrayPredictionContext.js
var ArrayPredictionContext = class extends PredictionContext {
  constructor(parents, returnStates) {
    const h = new HashCode();
    h.update(parents, returnStates);
    const hashCode = h.finish();
    super(hashCode);
    this.parents = parents;
    this.returnStates = returnStates;
    return this;
  }
  isEmpty() {
    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
  }
  getParent(index) {
    return this.parents[index];
  }
  getReturnState(index) {
    return this.returnStates[index];
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ArrayPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false;
    } else {
      return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
    }
  }
  toString() {
    if (this.isEmpty()) {
      return "[]";
    } else {
      let s = "[";
      for (let i = 0; i < this.returnStates.length; i++) {
        if (i > 0) {
          s = s + ", ";
        }
        if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
          s = s + "$";
          continue;
        }
        s = s + this.returnStates[i];
        if (this.parents[i] !== null) {
          s = s + " " + this.parents[i];
        } else {
          s = s + "null";
        }
      }
      return s + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
};

// node_modules/antlr4/src/antlr4/context/SingletonPredictionContext.js
var SingletonPredictionContext = class extends PredictionContext {
  constructor(parent, returnState) {
    let hashCode = 0;
    const hash = new HashCode();
    if (parent !== null) {
      hash.update(parent, returnState);
    } else {
      hash.update(1);
    }
    hashCode = hash.finish();
    super(hashCode);
    this.parentCtx = parent;
    this.returnState = returnState;
  }
  getParent(index) {
    return this.parentCtx;
  }
  getReturnState(index) {
    return this.returnState;
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof SingletonPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false;
    } else {
      if (this.returnState !== other.returnState)
        return false;
      else if (this.parentCtx == null)
        return other.parentCtx == null;
      else
        return this.parentCtx.equals(other.parentCtx);
    }
  }
  toString() {
    const up = this.parentCtx === null ? "" : this.parentCtx.toString();
    if (up.length === 0) {
      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
        return "$";
      } else {
        return "" + this.returnState;
      }
    } else {
      return "" + this.returnState + " " + up;
    }
  }
  get length() {
    return 1;
  }
  static create(parent, returnState) {
    if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
      return PredictionContext.EMPTY;
    } else {
      return new SingletonPredictionContext(parent, returnState);
    }
  }
};

// node_modules/antlr4/src/antlr4/context/EmptyPredictionContext.js
var EmptyPredictionContext = class extends SingletonPredictionContext {
  constructor() {
    super(null, PredictionContext.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(index) {
    return null;
  }
  getReturnState(index) {
    return this.returnState;
  }
  equals(other) {
    return this === other;
  }
  toString() {
    return "$";
  }
};
PredictionContext.EMPTY = new EmptyPredictionContext();

// node_modules/antlr4/src/antlr4/misc/HashMap.js
var HASH_KEY_PREFIX2 = "h-";
var HashMap = class {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  set(key, value) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) {
          const oldValue = entry.value;
          entry.value = value;
          return oldValue;
        }
      }
      entries.push({ key, value });
      return value;
    } else {
      this.data[hashKey] = [{ key, value }];
      return value;
    }
  }
  containsKey(key) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key))
          return true;
      }
    }
    return false;
  }
  get(key) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key))
          return entry.value;
      }
    }
    return null;
  }
  entries() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX2)).flatMap((key) => this.data[key], this);
  }
  getKeys() {
    return this.entries().map((e) => e.key);
  }
  getValues() {
    return this.entries().map((e) => e.value);
  }
  toString() {
    const ss = this.entries().map((e) => "{" + e.key + ":" + e.value + "}");
    return "[" + ss.join(", ") + "]";
  }
  get length() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX2)).map((key) => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
  }
};

// node_modules/antlr4/src/antlr4/context/PredictionContextUtils.js
function predictionContextFromRuleContext(atn3, outerContext) {
  if (outerContext === void 0 || outerContext === null) {
    outerContext = RuleContext.EMPTY;
  }
  if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
    return PredictionContext.EMPTY;
  }
  const parent = predictionContextFromRuleContext(atn3, outerContext.parentCtx);
  const state = atn3.states[outerContext.invokingState];
  const transition = state.transitions[0];
  return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
function getCachedPredictionContext(context, contextCache, visited) {
  if (context.isEmpty()) {
    return context;
  }
  let existing = visited.get(context) || null;
  if (existing !== null) {
    return existing;
  }
  existing = contextCache.get(context);
  if (existing !== null) {
    visited.set(context, existing);
    return existing;
  }
  let changed = false;
  let parents = [];
  for (let i = 0; i < parents.length; i++) {
    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
    if (changed || parent !== context.getParent(i)) {
      if (!changed) {
        parents = [];
        for (let j = 0; j < context.length; j++) {
          parents[j] = context.getParent(j);
        }
        changed = true;
      }
      parents[i] = parent;
    }
  }
  if (!changed) {
    contextCache.add(context);
    visited.set(context, context);
    return context;
  }
  let updated = null;
  if (parents.length === 0) {
    updated = PredictionContext.EMPTY;
  } else if (parents.length === 1) {
    updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
  } else {
    updated = new ArrayPredictionContext(parents, context.returnStates);
  }
  contextCache.add(updated);
  visited.set(updated, updated);
  visited.set(context, updated);
  return updated;
}
function merge(a, b, rootIsWildcard, mergeCache) {
  if (a === b) {
    return a;
  }
  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
    return mergeSingletons(a, b, rootIsWildcard, mergeCache);
  }
  if (rootIsWildcard) {
    if (a instanceof EmptyPredictionContext) {
      return a;
    }
    if (b instanceof EmptyPredictionContext) {
      return b;
    }
  }
  if (a instanceof SingletonPredictionContext) {
    a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
  }
  if (b instanceof SingletonPredictionContext) {
    b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
  }
  return mergeArrays(a, b, rootIsWildcard, mergeCache);
}
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous !== null) {
      return previous;
    }
  }
  let i = 0;
  let j = 0;
  let k = 0;
  let mergedReturnStates = [];
  let mergedParents = [];
  while (i < a.returnStates.length && j < b.returnStates.length) {
    const a_parent = a.parents[i];
    const b_parent = b.parents[j];
    if (a.returnStates[i] === b.returnStates[j]) {
      const payload = a.returnStates[i];
      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;
      const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent;
      if (bothDollars || ax_ax) {
        mergedParents[k] = a_parent;
        mergedReturnStates[k] = payload;
      } else {
        mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
        mergedReturnStates[k] = payload;
      }
      i += 1;
      j += 1;
    } else if (a.returnStates[i] < b.returnStates[j]) {
      mergedParents[k] = a_parent;
      mergedReturnStates[k] = a.returnStates[i];
      i += 1;
    } else {
      mergedParents[k] = b_parent;
      mergedReturnStates[k] = b.returnStates[j];
      j += 1;
    }
    k += 1;
  }
  if (i < a.returnStates.length) {
    for (let p = i; p < a.returnStates.length; p++) {
      mergedParents[k] = a.parents[p];
      mergedReturnStates[k] = a.returnStates[p];
      k += 1;
    }
  } else {
    for (let p = j; p < b.returnStates.length; p++) {
      mergedParents[k] = b.parents[p];
      mergedReturnStates[k] = b.returnStates[p];
      k += 1;
    }
  }
  if (k < mergedParents.length) {
    if (k === 1) {
      const a_ = SingletonPredictionContext.create(
        mergedParents[0],
        mergedReturnStates[0]
      );
      if (mergeCache !== null) {
        mergeCache.set(a, b, a_);
      }
      return a_;
    }
    mergedParents = mergedParents.slice(0, k);
    mergedReturnStates = mergedReturnStates.slice(0, k);
  }
  const M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
  if (M === a) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, a);
    }
    return a;
  }
  if (M === b) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, b);
    }
    return b;
  }
  combineCommonParents(mergedParents);
  if (mergeCache !== null) {
    mergeCache.set(a, b, M);
  }
  return M;
}
function combineCommonParents(parents) {
  const uniqueParents = new HashMap();
  for (let p = 0; p < parents.length; p++) {
    const parent = parents[p];
    if (!uniqueParents.containsKey(parent)) {
      uniqueParents.set(parent, parent);
    }
  }
  for (let q = 0; q < parents.length; q++) {
    parents[q] = uniqueParents.get(parents[q]);
  }
}
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous !== null) {
      return previous;
    }
  }
  const rootMerge = mergeRoot(a, b, rootIsWildcard);
  if (rootMerge !== null) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, rootMerge);
    }
    return rootMerge;
  }
  if (a.returnState === b.returnState) {
    const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
    if (parent === a.parentCtx) {
      return a;
    }
    if (parent === b.parentCtx) {
      return b;
    }
    const spc = SingletonPredictionContext.create(parent, a.returnState);
    if (mergeCache !== null) {
      mergeCache.set(a, b, spc);
    }
    return spc;
  } else {
    let singleParent = null;
    if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {
      singleParent = a.parentCtx;
    }
    if (singleParent !== null) {
      const payloads2 = [a.returnState, b.returnState];
      if (a.returnState > b.returnState) {
        payloads2[0] = b.returnState;
        payloads2[1] = a.returnState;
      }
      const parents2 = [singleParent, singleParent];
      const apc = new ArrayPredictionContext(parents2, payloads2);
      if (mergeCache !== null) {
        mergeCache.set(a, b, apc);
      }
      return apc;
    }
    const payloads = [a.returnState, b.returnState];
    let parents = [a.parentCtx, b.parentCtx];
    if (a.returnState > b.returnState) {
      payloads[0] = b.returnState;
      payloads[1] = a.returnState;
      parents = [b.parentCtx, a.parentCtx];
    }
    const a_ = new ArrayPredictionContext(parents, payloads);
    if (mergeCache !== null) {
      mergeCache.set(a, b, a_);
    }
    return a_;
  }
}
function mergeRoot(a, b, rootIsWildcard) {
  if (rootIsWildcard) {
    if (a === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    if (b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
  } else {
    if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    } else if (a === PredictionContext.EMPTY) {
      const payloads = [
        b.returnState,
        PredictionContext.EMPTY_RETURN_STATE
      ];
      const parents = [b.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    } else if (b === PredictionContext.EMPTY) {
      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [a.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    }
  }
  return null;
}

// node_modules/antlr4/src/antlr4/misc/BitSet.js
var BitSet = class {
  constructor() {
    this.data = [];
  }
  add(value) {
    this.data[value] = true;
  }
  or(set) {
    Object.keys(set.data).map((alt) => this.add(alt), this);
  }
  remove(value) {
    delete this.data[value];
  }
  has(value) {
    return this.data[value] === true;
  }
  values() {
    return Object.keys(this.data);
  }
  minValue() {
    return Math.min.apply(null, this.values());
  }
  hashCode() {
    return HashCode.hashStuff(this.values());
  }
  equals(other) {
    return other instanceof BitSet && equalArrays(this.data, other.data);
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  get length() {
    return this.values().length;
  }
};

// node_modules/antlr4/src/antlr4/atn/LL1Analyzer.js
var LL1Analyzer = class {
  constructor(atn3) {
    this.atn = atn3;
  }
  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in {@code s}. If the closure from transition
   * <em>i</em> leads to a semantic predicate before matching a symbol, the
   * element at index <em>i</em> of the result will be {@code null}.
   *
   * @param s the ATN state
   * @return the expected symbols for each outgoing transition of {@code s}.
   */
  getDecisionLookahead(s) {
    if (s === null) {
      return null;
    }
    const count = s.transitions.length;
    const look = [];
    for (let alt = 0; alt < count; alt++) {
      look[alt] = new IntervalSet();
      const lookBusy = new HashSet();
      const seeThruPreds = false;
      this._LOOK(
        s.transition(alt).target,
        null,
        PredictionContext.EMPTY,
        look[alt],
        lookBusy,
        new BitSet(),
        seeThruPreds,
        false
      );
      if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
        look[alt] = null;
      }
    }
    return look;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and the end of the rule containing
   * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
   * If {@code ctx} is not {@code null} and the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx the complete parser context, or {@code null} if the context
   * should be ignored
   *
   * @return The set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   */
  LOOK(s, stopState, ctx) {
    const r = new IntervalSet();
    const seeThruPreds = true;
    ctx = ctx || null;
    const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new HashSet(), new BitSet(), seeThruPreds, true);
    return r;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
   * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
   * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
   * {@code true} and {@code stopState} or the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state.
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx The outer context, or {@code null} if the outer context should
   * not be used.
   * @param look The result lookahead set.
   * @param lookBusy A set used for preventing epsilon closures in the ATN
   * from causing a stack overflow. Outside code should pass
   * {@code new CustomizedSet<ATNConfig>} for this argument.
   * @param calledRuleStack A set used for preventing left recursion in the
   * ATN from causing a stack overflow. Outside code should pass
   * {@code new BitSet()} for this argument.
   * @param seeThruPreds {@code true} to true semantic predicates as
   * implicitly {@code true} and "see through them", otherwise {@code false}
   * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
   * result if one is encountered.
   * @param addEOF Add {@link Token//EOF} to the result if the end of the
   * outermost context is reached. This parameter has no effect if {@code ctx}
   * is {@code null}.
   */
  _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    const c = new ATNConfig({ state: s, alt: 0, context: ctx }, null);
    if (lookBusy.has(c)) {
      return;
    }
    lookBusy.add(c);
    if (s === stopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
    }
    if (s instanceof RuleStopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
      if (ctx !== PredictionContext.EMPTY) {
        const removed = calledRuleStack.has(s.ruleIndex);
        try {
          calledRuleStack.remove(s.ruleIndex);
          for (let i = 0; i < ctx.length; i++) {
            const returnState = this.atn.states[ctx.getReturnState(i)];
            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.add(s.ruleIndex);
          }
        }
        return;
      }
    }
    for (let j = 0; j < s.transitions.length; j++) {
      const t = s.transitions[j];
      if (t.constructor === RuleTransition) {
        if (calledRuleStack.has(t.target.ruleIndex)) {
          continue;
        }
        const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
        try {
          calledRuleStack.add(t.target.ruleIndex);
          this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } finally {
          calledRuleStack.remove(t.target.ruleIndex);
        }
      } else if (t instanceof AbstractPredicateTransition) {
        if (seeThruPreds) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else {
          look.addOne(LL1Analyzer.HIT_PRED);
        }
      } else if (t.isEpsilon) {
        this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
      } else if (t.constructor === WildcardTransition) {
        look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
      } else {
        let set = t.label;
        if (set !== null) {
          if (t instanceof NotSetTransition) {
            set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          }
          look.addSet(set);
        }
      }
    }
  }
};
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;

// node_modules/antlr4/src/antlr4/atn/ATN.js
var ATN = class {
  constructor(grammarType, maxTokenType) {
    this.grammarType = grammarType;
    this.maxTokenType = maxTokenType;
    this.states = [];
    this.decisionToState = [];
    this.ruleToStartState = [];
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    this.ruleToTokenType = null;
    this.lexerActions = null;
    this.modeToStartState = [];
  }
  /**
   * Compute the set of valid tokens that can occur starting in state {@code s}.
   * If {@code ctx} is null, the set of tokens will not include what can follow
   * the rule surrounding {@code s}. In other words, the set will be
   * restricted to tokens reachable staying within {@code s}'s rule
   */
  nextTokensInContext(s, ctx) {
    const anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
  }
  /**
   * Compute the set of valid tokens that can occur starting in {@code s} and
   * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
   * rule
   */
  nextTokensNoContext(s) {
    if (s.nextTokenWithinRule !== null) {
      return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
  }
  nextTokens(s, ctx) {
    if (ctx === void 0) {
      return this.nextTokensNoContext(s);
    } else {
      return this.nextTokensInContext(s, ctx);
    }
  }
  addState(state) {
    if (state !== null) {
      state.atn = this;
      state.stateNumber = this.states.length;
    }
    this.states.push(state);
  }
  removeState(state) {
    this.states[state.stateNumber] = null;
  }
  defineDecisionState(s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length - 1;
    return s.decision;
  }
  getDecisionState(decision) {
    if (this.decisionToState.length === 0) {
      return null;
    } else {
      return this.decisionToState[decision];
    }
  }
  /**
   * Computes the set of input symbols which could follow ATN state number
   * {@code stateNumber} in the specified full {@code context}. This method
   * considers the complete parser context, but does not evaluate semantic
   * predicates (i.e. all predicates encountered during the calculation are
   * assumed true). If a path in the ATN exists from the starting state to the
   * {@link RuleStopState} of the outermost context without matching any
   * symbols, {@link Token//EOF} is added to the returned set.
   *
   * <p>If {@code context} is {@code null}, it is treated as
   * {@link ParserRuleContext//EMPTY}.</p>
   *
   * @param stateNumber the ATN state number
   * @param ctx the full parse context
   *
   * @return {IntervalSet} The set of potentially valid input symbols which could follow the
   * specified state in the specified context.
   *
   * @throws IllegalArgumentException if the ATN does not contain a state with
   * number {@code stateNumber}
   */
  getExpectedTokens(stateNumber, ctx) {
    if (stateNumber < 0 || stateNumber >= this.states.length) {
      throw "Invalid state number.";
    }
    const s = this.states[stateNumber];
    let following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
      return following;
    }
    const expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = this.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = this.nextTokens(rt.followState);
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
      expected.addOne(Token.EOF);
    }
    return expected;
  }
};
ATN.INVALID_ALT_NUMBER = 0;

// node_modules/antlr4/src/antlr4/atn/ATNType.js
var ATNType_default = {
  LEXER: 0,
  PARSER: 1
};

// node_modules/antlr4/src/antlr4/state/BasicState.js
var BasicState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BASIC;
  }
};

// node_modules/antlr4/src/antlr4/state/DecisionState.js
var DecisionState = class extends ATNState {
  constructor() {
    super();
    this.decision = -1;
    this.nonGreedy = false;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BlockStartState.js
var BlockStartState = class extends DecisionState {
  constructor() {
    super();
    this.endState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BlockEndState.js
var BlockEndState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/LoopEndState.js
var LoopEndState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.LOOP_END;
    this.loopBackState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/RuleStartState.js
var RuleStartState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_START;
    this.stopState = null;
    this.isPrecedenceRule = false;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/TokensStartState.js
var TokensStartState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.TOKEN_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/PlusLoopbackState.js
var PlusLoopbackState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_LOOP_BACK;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarLoopbackState.js
var StarLoopbackState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_BACK;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarLoopEntryState.js
var StarLoopEntryState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    this.isPrecedenceDecision = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/PlusBlockStartState.js
var PlusBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarBlockStartState.js
var StarBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_BLOCK_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BasicBlockStartState.js
var BasicBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/transition/AtomTransition.js
var AtomTransition = class extends Transition {
  constructor(target, label) {
    super(target);
    this.label_ = label;
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
  }
  makeLabel() {
    const s = new IntervalSet();
    s.addOne(this.label_);
    return s;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label_ === symbol;
  }
  toString() {
    return this.label_;
  }
};

// node_modules/antlr4/src/antlr4/transition/RangeTransition.js
var RangeTransition = class extends Transition {
  constructor(target, start, stop) {
    super(target);
    this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
  }
  makeLabel() {
    const s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= this.start && symbol <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};

// node_modules/antlr4/src/antlr4/transition/ActionTransition.js
var ActionTransition = class extends Transition {
  constructor(target, ruleIndex, actionIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex === void 0 ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};

// node_modules/antlr4/src/antlr4/transition/EpsilonTransition.js
var EpsilonTransition = class extends Transition {
  constructor(target, outermostPrecedenceReturn) {
    super(target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "epsilon";
  }
};

// node_modules/antlr4/src/antlr4/atn/Predicate.js
var Predicate = class extends SemanticContext {
  constructor(ruleIndex, predIndex, isCtxDependent) {
    super();
    this.ruleIndex = ruleIndex === void 0 ? -1 : ruleIndex;
    this.predIndex = predIndex === void 0 ? -1 : predIndex;
    this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
  }
  evaluate(parser, outerContext) {
    const localctx = this.isCtxDependent ? outerContext : null;
    return parser.sempred(localctx, this.ruleIndex, this.predIndex);
  }
  updateHashCode(hash) {
    hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof Predicate)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
    }
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
};
SemanticContext.NONE = new Predicate();

// node_modules/antlr4/src/antlr4/transition/PredicateTransition.js
var PredicateTransition = class extends AbstractPredicateTransition {
  constructor(target, ruleIndex, predIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};

// node_modules/antlr4/src/antlr4/atn/PrecedencePredicate.js
var PrecedencePredicate = class extends SemanticContext {
  constructor(precedence) {
    super();
    this.precedence = precedence === void 0 ? 0 : precedence;
  }
  evaluate(parser, outerContext) {
    return parser.precpred(outerContext, this.precedence);
  }
  evalPrecedence(parser, outerContext) {
    if (parser.precpred(outerContext, this.precedence)) {
      return SemanticContext.NONE;
    } else {
      return null;
    }
  }
  compareTo(other) {
    return this.precedence - other.precedence;
  }
  updateHashCode(hash) {
    hash.update(this.precedence);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof PrecedencePredicate)) {
      return false;
    } else {
      return this.precedence === other.precedence;
    }
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
};
SemanticContext.PrecedencePredicate = PrecedencePredicate;

// node_modules/antlr4/src/antlr4/transition/PrecedencePredicateTransition.js
var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
  constructor(target, precedence) {
    super(target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new PrecedencePredicate(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js
var ATNDeserializationOptions = class {
  constructor(copyFrom) {
    if (copyFrom === void 0) {
      copyFrom = null;
    }
    this.readOnly = false;
    this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
  }
};
ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

// node_modules/antlr4/src/antlr4/atn/LexerActionType.js
var LexerActionType_default = {
  // The type of a {@link LexerChannelAction} action.
  CHANNEL: 0,
  // The type of a {@link LexerCustomAction} action
  CUSTOM: 1,
  // The type of a {@link LexerModeAction} action.
  MODE: 2,
  //The type of a {@link LexerMoreAction} action.
  MORE: 3,
  //The type of a {@link LexerPopModeAction} action.
  POP_MODE: 4,
  //The type of a {@link LexerPushModeAction} action.
  PUSH_MODE: 5,
  //The type of a {@link LexerSkipAction} action.
  SKIP: 6,
  //The type of a {@link LexerTypeAction} action.
  TYPE: 7
};

// node_modules/antlr4/src/antlr4/action/LexerAction.js
var LexerAction = class {
  constructor(action) {
    this.actionType = action;
    this.isPositionDependent = false;
  }
  hashCode() {
    const hash = new HashCode();
    this.updateHashCode(hash);
    return hash.finish();
  }
  updateHashCode(hash) {
    hash.update(this.actionType);
  }
  equals(other) {
    return this === other;
  }
};

// node_modules/antlr4/src/antlr4/action/LexerSkipAction.js
var LexerSkipAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.SKIP);
  }
  execute(lexer) {
    lexer.skip();
  }
  toString() {
    return "skip";
  }
};
LexerSkipAction.INSTANCE = new LexerSkipAction();

// node_modules/antlr4/src/antlr4/action/LexerChannelAction.js
var LexerChannelAction = class extends LexerAction {
  constructor(channel) {
    super(LexerActionType_default.CHANNEL);
    this.channel = channel;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//setChannel} with the
   * value provided by {@link //getChannel}.</p>
   */
  execute(lexer) {
    lexer._channel = this.channel;
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.channel);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerChannelAction)) {
      return false;
    } else {
      return this.channel === other.channel;
    }
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerCustomAction.js
var LexerCustomAction = class extends LexerAction {
  /**
   * Constructs a custom lexer action with the specified rule and action
   * indexes.
   *
   * @param ruleIndex The rule index to use for calls to
   * {@link Recognizer//action}.
   * @param actionIndex The action index to use for calls to
   * {@link Recognizer//action}.
   */
  constructor(ruleIndex, actionIndex) {
    super(LexerActionType_default.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
  }
  /**
   * <p>Custom actions are implemented by calling {@link Lexer//action} with the
   * appropriate rule and action indexes.</p>
   */
  execute(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerCustomAction)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
  }
};

// node_modules/antlr4/src/antlr4/action/LexerMoreAction.js
var LexerMoreAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.MORE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.more();
  }
  toString() {
    return "more";
  }
};
LexerMoreAction.INSTANCE = new LexerMoreAction();

// node_modules/antlr4/src/antlr4/action/LexerTypeAction.js
var LexerTypeAction = class extends LexerAction {
  constructor(type) {
    super(LexerActionType_default.TYPE);
    this.type = type;
  }
  execute(lexer) {
    lexer.type = this.type;
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.type);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerTypeAction)) {
      return false;
    } else {
      return this.type === other.type;
    }
  }
  toString() {
    return "type(" + this.type + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerPushModeAction.js
var LexerPushModeAction = class extends LexerAction {
  constructor(mode) {
    super(LexerActionType_default.PUSH_MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//pushMode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.pushMode(this.mode);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerPushModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerPopModeAction.js
var LexerPopModeAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.POP_MODE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.popMode();
  }
  toString() {
    return "popMode";
  }
};
LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// node_modules/antlr4/src/antlr4/action/LexerModeAction.js
var LexerModeAction = class extends LexerAction {
  constructor(mode) {
    super(LexerActionType_default.MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//mode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.mode(this.mode);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js
var SERIALIZED_VERSION = 4;
function initArray(length, value) {
  const tmp = [];
  tmp[length - 1] = value;
  return tmp.map(function(i) {
    return value;
  });
}
var ATNDeserializer = class {
  constructor(options) {
    if (options === void 0 || options === null) {
      options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;
  }
  deserialize(data) {
    const legacy = this.reset(data);
    this.checkVersion(legacy);
    if (legacy)
      this.skipUUID();
    const atn3 = this.readATN();
    this.readStates(atn3, legacy);
    this.readRules(atn3, legacy);
    this.readModes(atn3);
    const sets = [];
    this.readSets(atn3, sets, this.readInt.bind(this));
    if (legacy)
      this.readSets(atn3, sets, this.readInt32.bind(this));
    this.readEdges(atn3, sets);
    this.readDecisions(atn3);
    this.readLexerActions(atn3, legacy);
    this.markPrecedenceDecisions(atn3);
    this.verifyATN(atn3);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn3.grammarType === ATNType_default.PARSER) {
      this.generateRuleBypassTransitions(atn3);
      this.verifyATN(atn3);
    }
    return atn3;
  }
  reset(data) {
    const version2 = data.charCodeAt ? data.charCodeAt(0) : data[0];
    if (version2 === SERIALIZED_VERSION - 1) {
      const adjust = function(c) {
        const v = c.charCodeAt(0);
        return v > 1 ? v - 2 : v + 65534;
      };
      const temp = data.split("").map(adjust);
      temp[0] = data.charCodeAt(0);
      this.data = temp;
      this.pos = 0;
      return true;
    } else {
      this.data = data;
      this.pos = 0;
      return false;
    }
  }
  skipUUID() {
    let count = 0;
    while (count++ < 8)
      this.readInt();
  }
  checkVersion(legacy) {
    const version2 = this.readInt();
    if (!legacy && version2 !== SERIALIZED_VERSION) {
      throw "Could not deserialize ATN with version " + version2 + " (expected " + SERIALIZED_VERSION + ").";
    }
  }
  readATN() {
    const grammarType = this.readInt();
    const maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
  }
  readStates(atn3, legacy) {
    let j, pair, stateNumber;
    const loopBackStateNumbers = [];
    const endStateNumbers = [];
    const nstates = this.readInt();
    for (let i = 0; i < nstates; i++) {
      const stype = this.readInt();
      if (stype === ATNState.INVALID_TYPE) {
        atn3.addState(null);
        continue;
      }
      let ruleIndex = this.readInt();
      if (legacy && ruleIndex === 65535) {
        ruleIndex = -1;
      }
      const s = this.stateFactory(stype, ruleIndex);
      if (stype === ATNState.LOOP_END) {
        const loopBackStateNumber = this.readInt();
        loopBackStateNumbers.push([s, loopBackStateNumber]);
      } else if (s instanceof BlockStartState) {
        const endStateNumber = this.readInt();
        endStateNumbers.push([s, endStateNumber]);
      }
      atn3.addState(s);
    }
    for (j = 0; j < loopBackStateNumbers.length; j++) {
      pair = loopBackStateNumbers[j];
      pair[0].loopBackState = atn3.states[pair[1]];
    }
    for (j = 0; j < endStateNumbers.length; j++) {
      pair = endStateNumbers[j];
      pair[0].endState = atn3.states[pair[1]];
    }
    let numNonGreedyStates = this.readInt();
    for (j = 0; j < numNonGreedyStates; j++) {
      stateNumber = this.readInt();
      atn3.states[stateNumber].nonGreedy = true;
    }
    let numPrecedenceStates = this.readInt();
    for (j = 0; j < numPrecedenceStates; j++) {
      stateNumber = this.readInt();
      atn3.states[stateNumber].isPrecedenceRule = true;
    }
  }
  readRules(atn3, legacy) {
    let i;
    const nrules = this.readInt();
    if (atn3.grammarType === ATNType_default.LEXER) {
      atn3.ruleToTokenType = initArray(nrules, 0);
    }
    atn3.ruleToStartState = initArray(nrules, 0);
    for (i = 0; i < nrules; i++) {
      const s = this.readInt();
      atn3.ruleToStartState[i] = atn3.states[s];
      if (atn3.grammarType === ATNType_default.LEXER) {
        let tokenType = this.readInt();
        if (legacy && tokenType === 65535) {
          tokenType = Token.EOF;
        }
        atn3.ruleToTokenType[i] = tokenType;
      }
    }
    atn3.ruleToStopState = initArray(nrules, 0);
    for (i = 0; i < atn3.states.length; i++) {
      const state = atn3.states[i];
      if (!(state instanceof RuleStopState)) {
        continue;
      }
      atn3.ruleToStopState[state.ruleIndex] = state;
      atn3.ruleToStartState[state.ruleIndex].stopState = state;
    }
  }
  readModes(atn3) {
    const nmodes = this.readInt();
    for (let i = 0; i < nmodes; i++) {
      let s = this.readInt();
      atn3.modeToStartState.push(atn3.states[s]);
    }
  }
  readSets(atn3, sets, reader) {
    const m = this.readInt();
    for (let i = 0; i < m; i++) {
      const iset = new IntervalSet();
      sets.push(iset);
      const n = this.readInt();
      const containsEof = this.readInt();
      if (containsEof !== 0) {
        iset.addOne(-1);
      }
      for (let j = 0; j < n; j++) {
        const i1 = reader();
        const i2 = reader();
        iset.addRange(i1, i2);
      }
    }
  }
  readEdges(atn3, sets) {
    let i, j, state, trans, target;
    const nedges = this.readInt();
    for (i = 0; i < nedges; i++) {
      const src = this.readInt();
      const trg = this.readInt();
      const ttype = this.readInt();
      const arg1 = this.readInt();
      const arg2 = this.readInt();
      const arg3 = this.readInt();
      trans = this.edgeFactory(atn3, ttype, src, trg, arg1, arg2, arg3, sets);
      const srcState = atn3.states[src];
      srcState.addTransition(trans);
    }
    for (i = 0; i < atn3.states.length; i++) {
      state = atn3.states[i];
      for (j = 0; j < state.transitions.length; j++) {
        const t = state.transitions[j];
        if (!(t instanceof RuleTransition)) {
          continue;
        }
        let outermostPrecedenceReturn = -1;
        if (atn3.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
          if (t.precedence === 0) {
            outermostPrecedenceReturn = t.target.ruleIndex;
          }
        }
        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
        atn3.ruleToStopState[t.target.ruleIndex].addTransition(trans);
      }
    }
    for (i = 0; i < atn3.states.length; i++) {
      state = atn3.states[i];
      if (state instanceof BlockStartState) {
        if (state.endState === null) {
          throw "IllegalState";
        }
        if (state.endState.startState !== null) {
          throw "IllegalState";
        }
        state.endState.startState = state;
      }
      if (state instanceof PlusLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof PlusBlockStartState) {
            target.loopBackState = state;
          }
        }
      } else if (state instanceof StarLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof StarLoopEntryState) {
            target.loopBackState = state;
          }
        }
      }
    }
  }
  readDecisions(atn3) {
    const ndecisions = this.readInt();
    for (let i = 0; i < ndecisions; i++) {
      const s = this.readInt();
      const decState = atn3.states[s];
      atn3.decisionToState.push(decState);
      decState.decision = i;
    }
  }
  readLexerActions(atn3, legacy) {
    if (atn3.grammarType === ATNType_default.LEXER) {
      const count = this.readInt();
      atn3.lexerActions = initArray(count, null);
      for (let i = 0; i < count; i++) {
        const actionType = this.readInt();
        let data1 = this.readInt();
        if (legacy && data1 === 65535) {
          data1 = -1;
        }
        let data2 = this.readInt();
        if (legacy && data2 === 65535) {
          data2 = -1;
        }
        atn3.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
      }
    }
  }
  generateRuleBypassTransitions(atn3) {
    let i;
    const count = atn3.ruleToStartState.length;
    for (i = 0; i < count; i++) {
      atn3.ruleToTokenType[i] = atn3.maxTokenType + i + 1;
    }
    for (i = 0; i < count; i++) {
      this.generateRuleBypassTransition(atn3, i);
    }
  }
  generateRuleBypassTransition(atn3, idx) {
    let i, state;
    const bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn3.addState(bypassStart);
    const bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn3.addState(bypassStop);
    bypassStart.endState = bypassStop;
    atn3.defineDecisionState(bypassStart);
    bypassStop.startState = bypassStart;
    let excludeTransition = null;
    let endState = null;
    if (atn3.ruleToStartState[idx].isPrecedenceRule) {
      endState = null;
      for (i = 0; i < atn3.states.length; i++) {
        state = atn3.states[i];
        if (this.stateIsEndStateFor(state, idx)) {
          endState = state;
          excludeTransition = state.loopBackState.transitions[0];
          break;
        }
      }
      if (excludeTransition === null) {
        throw "Couldn't identify final state of the precedence rule prefix section.";
      }
    } else {
      endState = atn3.ruleToStopState[idx];
    }
    for (i = 0; i < atn3.states.length; i++) {
      state = atn3.states[i];
      for (let j = 0; j < state.transitions.length; j++) {
        const transition = state.transitions[j];
        if (transition === excludeTransition) {
          continue;
        }
        if (transition.target === endState) {
          transition.target = bypassStop;
        }
      }
    }
    const ruleToStartState = atn3.ruleToStartState[idx];
    const count = ruleToStartState.transitions.length;
    while (count > 0) {
      bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
      ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    atn3.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));
    const matchState = new BasicState();
    atn3.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn3.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
  }
  stateIsEndStateFor(state, idx) {
    if (state.ruleIndex !== idx) {
      return null;
    }
    if (!(state instanceof StarLoopEntryState)) {
      return null;
    }
    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!(maybeLoopEndState instanceof LoopEndState)) {
      return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
      return state;
    } else {
      return null;
    }
  }
  /**
   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
   * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
   * correct value.
   * @param atn The ATN.
   */
  markPrecedenceDecisions(atn3) {
    for (let i = 0; i < atn3.states.length; i++) {
      const state = atn3.states[i];
      if (!(state instanceof StarLoopEntryState)) {
        continue;
      }
      if (atn3.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (maybeLoopEndState instanceof LoopEndState) {
          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
            state.isPrecedenceDecision = true;
          }
        }
      }
    }
  }
  verifyATN(atn3) {
    if (!this.deserializationOptions.verifyATN) {
      return;
    }
    for (let i = 0; i < atn3.states.length; i++) {
      const state = atn3.states[i];
      if (state === null) {
        continue;
      }
      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
      if (state instanceof PlusBlockStartState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof StarLoopEntryState) {
        this.checkCondition(state.loopBackState !== null);
        this.checkCondition(state.transitions.length === 2);
        if (state.transitions[0].target instanceof StarBlockStartState) {
          this.checkCondition(state.transitions[1].target instanceof LoopEndState);
          this.checkCondition(!state.nonGreedy);
        } else if (state.transitions[0].target instanceof LoopEndState) {
          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
          this.checkCondition(state.nonGreedy);
        } else {
          throw "IllegalState";
        }
      } else if (state instanceof StarLoopbackState) {
        this.checkCondition(state.transitions.length === 1);
        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
      } else if (state instanceof LoopEndState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof RuleStartState) {
        this.checkCondition(state.stopState !== null);
      } else if (state instanceof BlockStartState) {
        this.checkCondition(state.endState !== null);
      } else if (state instanceof BlockEndState) {
        this.checkCondition(state.startState !== null);
      } else if (state instanceof DecisionState) {
        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
      } else {
        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
      }
    }
  }
  checkCondition(condition, message) {
    if (!condition) {
      if (message === void 0 || message === null) {
        message = "IllegalState";
      }
      throw message;
    }
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    const low = this.readInt();
    const high = this.readInt();
    return low | high << 16;
  }
  edgeFactory(atn3, type, src, trg, arg1, arg2, arg3, sets) {
    const target = atn3.states[trg];
    switch (type) {
      case Transition.EPSILON:
        return new EpsilonTransition(target);
      case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
      case Transition.RULE:
        return new RuleTransition(atn3.states[arg1], arg2, arg3, target);
      case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
      case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
      case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.SET:
        return new SetTransition(target, sets[arg1]);
      case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
      case Transition.WILDCARD:
        return new WildcardTransition(target);
      default:
        throw "The specified transition type: " + type + " is not valid.";
    }
  }
  stateFactory(type, ruleIndex) {
    if (this.stateFactories === null) {
      const sf = [];
      sf[ATNState.INVALID_TYPE] = null;
      sf[ATNState.BASIC] = () => new BasicState();
      sf[ATNState.RULE_START] = () => new RuleStartState();
      sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();
      sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();
      sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();
      sf[ATNState.TOKEN_START] = () => new TokensStartState();
      sf[ATNState.RULE_STOP] = () => new RuleStopState();
      sf[ATNState.BLOCK_END] = () => new BlockEndState();
      sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();
      sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();
      sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();
      sf[ATNState.LOOP_END] = () => new LoopEndState();
      this.stateFactories = sf;
    }
    if (type > this.stateFactories.length || this.stateFactories[type] === null) {
      throw "The specified state type " + type + " is not valid.";
    } else {
      const s = this.stateFactories[type]();
      if (s !== null) {
        s.ruleIndex = ruleIndex;
        return s;
      }
    }
  }
  lexerActionFactory(type, data1, data2) {
    if (this.actionFactories === null) {
      const af = [];
      af[LexerActionType_default.CHANNEL] = (data12, data22) => new LexerChannelAction(data12);
      af[LexerActionType_default.CUSTOM] = (data12, data22) => new LexerCustomAction(data12, data22);
      af[LexerActionType_default.MODE] = (data12, data22) => new LexerModeAction(data12);
      af[LexerActionType_default.MORE] = (data12, data22) => LexerMoreAction.INSTANCE;
      af[LexerActionType_default.POP_MODE] = (data12, data22) => LexerPopModeAction.INSTANCE;
      af[LexerActionType_default.PUSH_MODE] = (data12, data22) => new LexerPushModeAction(data12);
      af[LexerActionType_default.SKIP] = (data12, data22) => LexerSkipAction.INSTANCE;
      af[LexerActionType_default.TYPE] = (data12, data22) => new LexerTypeAction(data12);
      this.actionFactories = af;
    }
    if (type > this.actionFactories.length || this.actionFactories[type] === null) {
      throw "The specified lexer action type " + type + " is not valid.";
    } else {
      return this.actionFactories[type](data1, data2);
    }
  }
};

// node_modules/antlr4/src/antlr4/error/ErrorListener.js
var ErrorListener = class {
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
  }
};

// node_modules/antlr4/src/antlr4/error/ConsoleErrorListener.js
var ConsoleErrorListener = class extends ErrorListener {
  constructor() {
    super();
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
  }
};
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

// node_modules/antlr4/src/antlr4/error/ProxyErrorListener.js
var ProxyErrorListener = class extends ErrorListener {
  constructor(delegates) {
    super();
    if (delegates === null) {
      throw "delegates";
    }
    this.delegates = delegates;
    return this;
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map((d) => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map((d) => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    this.delegates.map((d) => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    this.delegates.map((d) => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
  }
};

// node_modules/antlr4/src/antlr4/Recognizer.js
var Recognizer = class {
  constructor() {
    this._listeners = [ConsoleErrorListener.INSTANCE];
    this._interp = null;
    this._stateNumber = -1;
  }
  checkVersion(toolVersion) {
    const runtimeVersion = "4.10.1";
    if (runtimeVersion !== toolVersion) {
      console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
    }
  }
  addErrorListener(listener) {
    this._listeners.push(listener);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getLiteralNames() {
    return Object.getPrototypeOf(this).constructor.literalNames || [];
  }
  getSymbolicNames() {
    return Object.getPrototypeOf(this).constructor.symbolicNames || [];
  }
  getTokenNames() {
    if (!this.tokenNames) {
      const literalNames = this.getLiteralNames();
      const symbolicNames = this.getSymbolicNames();
      const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
      this.tokenNames = [];
      for (let i = 0; i < length; i++) {
        this.tokenNames[i] = literalNames[i] || symbolicNames[i] || "<INVALID";
      }
    }
    return this.tokenNames;
  }
  getTokenTypeMap() {
    const tokenNames = this.getTokenNames();
    if (tokenNames === null) {
      throw "The current recognizer does not provide a list of token names.";
    }
    let result = this.tokenTypeMapCache[tokenNames];
    if (result === void 0) {
      result = tokenNames.reduce(function(o, k, i) {
        o[k] = i;
      });
      result.EOF = Token.EOF;
      this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
  }
  /**
   * Get a map from rule names to rule indexes.
   * <p>Used for XPath and tree pattern compilation.</p>
   */
  getRuleIndexMap() {
    const ruleNames = this.ruleNames;
    if (ruleNames === null) {
      throw "The current recognizer does not provide a list of rule names.";
    }
    let result = this.ruleIndexMapCache[ruleNames];
    if (result === void 0) {
      result = ruleNames.reduce(function(o, k, i) {
        o[k] = i;
      });
      this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
  }
  getTokenType(tokenName) {
    const ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !== void 0) {
      return ttype;
    } else {
      return Token.INVALID_TYPE;
    }
  }
  // What is the error header, normally line/character position information?
  getErrorHeader(e) {
    const line = e.getOffendingToken().line;
    const column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out.  Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   *
   * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
   * implementations of {@link ANTLRErrorStrategy} may provide a similar
   * feature when necessary. For example, see
   * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/
  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }
    let s = t.text;
    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }
    s = s.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t");
    return "'" + s + "'";
  }
  getErrorListenerDispatch() {
    return new ProxyErrorListener(this._listeners);
  }
  /**
   * subclass needs to override these if there are sempreds or actions
   * that the ATN interp needs to execute
   */
  sempred(localctx, ruleIndex, actionIndex) {
    return true;
  }
  precpred(localctx, precedence) {
    return true;
  }
  get state() {
    return this._stateNumber;
  }
  set state(state) {
    this._stateNumber = state;
  }
};
Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};

// node_modules/antlr4/src/antlr4/CommonToken.js
var CommonToken = class extends Token {
  constructor(source, type, channel, start, stop) {
    super();
    this.source = source !== void 0 ? source : CommonToken.EMPTY_SOURCE;
    this.type = type !== void 0 ? type : null;
    this.channel = channel !== void 0 ? channel : Token.DEFAULT_CHANNEL;
    this.start = start !== void 0 ? start : -1;
    this.stop = stop !== void 0 ? stop : -1;
    this.tokenIndex = -1;
    if (this.source[0] !== null) {
      this.line = source[0].line;
      this.column = source[0].column;
    } else {
      this.column = -1;
    }
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * <p>
   * If {@code oldToken} is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link //text} field and
   * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
   * be assigned the result of calling {@link //getText}, and {@link //source}
   * will be constructed from the result of {@link Token//getTokenSource} and
   * {@link Token//getInputStream}.</p>
   *
   * @param oldToken The token to copy.
   */
  clone() {
    const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
    t.tokenIndex = this.tokenIndex;
    t.line = this.line;
    t.column = this.column;
    t.text = this.text;
    return t;
  }
  toString() {
    let txt = this.text;
    if (txt !== null) {
      txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    } else {
      txt = "<no text>";
    }
    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    }
    const input = this.getInputStream();
    if (input === null) {
      return null;
    }
    const n = input.size;
    if (this.start < n && this.stop < n) {
      return input.getText(this.start, this.stop);
    } else {
      return "<EOF>";
    }
  }
  set text(text) {
    this._text = text;
  }
};
CommonToken.EMPTY_SOURCE = [null, null];

// node_modules/antlr4/src/antlr4/CommonTokenFactory.js
var TokenFactory = class {
};
var CommonTokenFactory = class extends TokenFactory {
  constructor(copyText) {
    super();
    this.copyText = copyText === void 0 ? false : copyText;
  }
  create(source, type, text, channel, start, stop, line, column) {
    const t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !== null) {
      t.text = text;
    } else if (this.copyText && source[1] !== null) {
      t.text = source[1].getText(start, stop);
    }
    return t;
  }
  createThin(type, text) {
    const t = new CommonToken(null, type);
    t.text = text;
    return t;
  }
};
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

// node_modules/antlr4/src/antlr4/error/RecognitionException.js
var RecognitionException = class extends Error {
  constructor(params) {
    super(params.message);
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, RecognitionException);
    this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    this.offendingToken = null;
    this.offendingState = -1;
    if (this.recognizer !== null) {
      this.offendingState = this.recognizer.state;
    }
  }
  /**
   * Gets the set of input symbols which could potentially follow the
   * previously matched symbol at the time this exception was thrown.
   *
   * <p>If the set of expected tokens is not known and could not be computed,
   * this method returns {@code null}.</p>
   *
   * @return The set of token types that could potentially follow the current
   * state in the ATN, or {@code null} if the information is not available.
   */
  getExpectedTokens() {
    if (this.recognizer !== null) {
      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
      return null;
    }
  }
  // <p>If the state number is not known, this method returns -1.</p>
  toString() {
    return this.message;
  }
};

// node_modules/antlr4/src/antlr4/error/LexerNoViableAltException.js
var LexerNoViableAltException = class extends RecognitionException {
  constructor(lexer, input, startIndex, deadEndConfigs) {
    super({ message: "", recognizer: lexer, input, ctx: null });
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
  }
  toString() {
    let symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
      symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
  }
};

// node_modules/antlr4/src/antlr4/Lexer.js
var Lexer = class extends Recognizer {
  constructor(input) {
    super();
    this._input = input;
    this._factory = CommonTokenFactory.DEFAULT;
    this._tokenFactorySourcePair = [this, input];
    this._interp = null;
    this._token = null;
    this._tokenStartCharIndex = -1;
    this._tokenStartLine = -1;
    this._tokenStartColumn = -1;
    this._hitEOF = false;
    this._channel = Token.DEFAULT_CHANNEL;
    this._type = Token.INVALID_TYPE;
    this._modeStack = [];
    this._mode = Lexer.DEFAULT_MODE;
    this._text = null;
  }
  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }
    this._token = null;
    this._type = Token.INVALID_TYPE;
    this._channel = Token.DEFAULT_CHANNEL;
    this._tokenStartCharIndex = -1;
    this._tokenStartColumn = -1;
    this._tokenStartLine = -1;
    this._text = null;
    this._hitEOF = false;
    this._mode = Lexer.DEFAULT_MODE;
    this._modeStack = [];
    this._interp.reset();
  }
  // Return a token from this source; i.e., match a token on the char stream.
  nextToken() {
    if (this._input === null) {
      throw "nextToken requires a non-null input stream.";
    }
    const tokenStartMarker = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF) {
          this.emitEOF();
          return this._token;
        }
        this._token = null;
        this._channel = Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = this._input.index;
        this._tokenStartColumn = this._interp.column;
        this._tokenStartLine = this._interp.line;
        this._text = null;
        let continueOuter = false;
        for (; ; ) {
          this._type = Token.INVALID_TYPE;
          let ttype = Lexer.SKIP;
          try {
            ttype = this._interp.match(this._input, this._mode);
          } catch (e) {
            if (e instanceof RecognitionException) {
              this.notifyListeners(e);
              this.recover(e);
            } else {
              console.log(e.stack);
              throw e;
            }
          }
          if (this._input.LA(1) === Token.EOF) {
            this._hitEOF = true;
          }
          if (this._type === Token.INVALID_TYPE) {
            this._type = ttype;
          }
          if (this._type === Lexer.SKIP) {
            continueOuter = true;
            break;
          }
          if (this._type !== Lexer.MORE) {
            break;
          }
        }
        if (continueOuter) {
          continue;
        }
        if (this._token === null) {
          this.emit();
        }
        return this._token;
      }
    } finally {
      this._input.release(tokenStartMarker);
    }
  }
  /**
   * Instruct the lexer to skip creating a token for current lexer rule
   * and look for another token. nextToken() knows to keep looking when
   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
   * if token==null at end of any token rule, it creates one for you
   * and emits it.
   */
  skip() {
    this._type = Lexer.SKIP;
  }
  more() {
    this._type = Lexer.MORE;
  }
  mode(m) {
    this._mode = m;
  }
  pushMode(m) {
    if (this._interp.debug) {
      console.log("pushMode " + m);
    }
    this._modeStack.push(this._mode);
    this.mode(m);
  }
  popMode() {
    if (this._modeStack.length === 0) {
      throw "Empty Stack";
    }
    if (this._interp.debug) {
      console.log("popMode back to " + this._modeStack.slice(0, -1));
    }
    this.mode(this._modeStack.pop());
    return this._mode;
  }
  /**
   * By default does not support multiple emits per nextToken invocation
   * for efficiency reasons. Subclass and override this method, nextToken,
   * and getToken (to push tokens into a list and pull from that list
   * rather than a single variable as this implementation does).
   */
  emitToken(token) {
    this._token = token;
  }
  /**
   * The standard method called to automatically emit a token at the
   * outermost lexical rule. The token object should point into the
   * char buffer start..stop. If there is a text override in 'text',
   * use that to set the token's text. Override this method to emit
   * custom Token objects or provide a new factory.
   */
  emit() {
    const t = this._factory.create(
      this._tokenFactorySourcePair,
      this._type,
      this._text,
      this._channel,
      this._tokenStartCharIndex,
      this.getCharIndex() - 1,
      this._tokenStartLine,
      this._tokenStartColumn
    );
    this.emitToken(t);
    return t;
  }
  emitEOF() {
    const cpos = this.column;
    const lpos = this.line;
    const eof = this._factory.create(
      this._tokenFactorySourcePair,
      Token.EOF,
      null,
      Token.DEFAULT_CHANNEL,
      this._input.index,
      this._input.index - 1,
      lpos,
      cpos
    );
    this.emitToken(eof);
    return eof;
  }
  // What is the index of the current character of lookahead?///
  getCharIndex() {
    return this._input.index;
  }
  /**
   * Return a list of all Token objects in input char stream.
   * Forces load of all tokens. Does not include EOF token.
   */
  getAllTokens() {
    const tokens = [];
    let t = this.nextToken();
    while (t.type !== Token.EOF) {
      tokens.push(t);
      t = this.nextToken();
    }
    return tokens;
  }
  notifyListeners(e) {
    const start = this._tokenStartCharIndex;
    const stop = this._input.index;
    const text = this._input.getText(start, stop);
    const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(
      this,
      null,
      this._tokenStartLine,
      this._tokenStartColumn,
      msg,
      e
    );
  }
  getErrorDisplay(s) {
    const d = [];
    for (let i = 0; i < s.length; i++) {
      d.push(s[i]);
    }
    return d.join("");
  }
  getErrorDisplayForChar(c) {
    if (c.charCodeAt(0) === Token.EOF) {
      return "<EOF>";
    } else if (c === "\n") {
      return "\\n";
    } else if (c === "	") {
      return "\\t";
    } else if (c === "\r") {
      return "\\r";
    } else {
      return c;
    }
  }
  getCharErrorDisplay(c) {
    return "'" + this.getErrorDisplayForChar(c) + "'";
  }
  /**
   * Lexers can normally match any char in it's vocabulary after matching
   * a token, so do the easy thing and just kill a character and hope
   * it all works out. You can instead use the rule invocation stack
   * to do sophisticated error recovery if you are in a fragment rule.
   */
  recover(re) {
    if (this._input.LA(1) !== Token.EOF) {
      if (re instanceof LexerNoViableAltException) {
        this._interp.consume(this._input);
      } else {
        this._input.consume();
      }
    }
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(input) {
    this._input = null;
    this._tokenFactorySourcePair = [this, this._input];
    this.reset();
    this._input = input;
    this._tokenFactorySourcePair = [this, this._input];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
  }
  get line() {
    return this._interp.line;
  }
  set line(line) {
    this._interp.line = line;
  }
  get column() {
    return this._interp.column;
  }
  set column(column) {
    this._interp.column = column;
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    } else {
      return this._interp.getText(this._input);
    }
  }
  set text(text) {
    this._text = text;
  }
};
Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0;
Lexer.MAX_CHAR_VALUE = 1114111;

// node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js
function hashATNConfig(c) {
  return c.hashCodeForConfigSet();
}
function equalATNConfigs(a, b) {
  if (a === b) {
    return true;
  } else if (a === null || b === null) {
    return false;
  } else
    return a.equalsForConfigSet(b);
}
var ATNConfigSet = class {
  constructor(fullCtx) {
    this.configLookup = new HashSet(hashATNConfig, equalATNConfigs);
    this.fullCtx = fullCtx === void 0 ? true : fullCtx;
    this.readOnly = false;
    this.configs = [];
    this.uniqueAlt = 0;
    this.conflictingAlts = null;
    this.hasSemanticContext = false;
    this.dipsIntoOuterContext = false;
    this.cachedHashCode = -1;
  }
  /**
   * Adding a new config means merging contexts with existing configs for
   * {@code (s, i, pi, _)}, where {@code s} is the
   * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
   * {@code pi} is the {@link ATNConfig//semanticContext}. We use
   * {@code (s,i,pi)} as key.
   *
   * <p>This method updates {@link //dipsIntoOuterContext} and
   * {@link //hasSemanticContext} when necessary.</p>
   */
  add(config, mergeCache) {
    if (mergeCache === void 0) {
      mergeCache = null;
    }
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (config.semanticContext !== SemanticContext.NONE) {
      this.hasSemanticContext = true;
    }
    if (config.reachesIntoOuterContext > 0) {
      this.dipsIntoOuterContext = true;
    }
    const existing = this.configLookup.add(config);
    if (existing === config) {
      this.cachedHashCode = -1;
      this.configs.push(config);
      return true;
    }
    const rootIsWildcard = !this.fullCtx;
    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
    existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
    if (config.precedenceFilterSuppressed) {
      existing.precedenceFilterSuppressed = true;
    }
    existing.context = merged;
    return true;
  }
  getStates() {
    const states = new HashSet();
    for (let i = 0; i < this.configs.length; i++) {
      states.add(this.configs[i].state);
    }
    return states;
  }
  getPredicates() {
    const preds = [];
    for (let i = 0; i < this.configs.length; i++) {
      const c = this.configs[i].semanticContext;
      if (c !== SemanticContext.NONE) {
        preds.push(c.semanticContext);
      }
    }
    return preds;
  }
  optimizeConfigs(interpreter) {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (this.configLookup.length === 0) {
      return;
    }
    for (let i = 0; i < this.configs.length; i++) {
      const config = this.configs[i];
      config.context = interpreter.getCachedContext(config.context);
    }
  }
  addAll(coll) {
    for (let i = 0; i < coll.length; i++) {
      this.add(coll[i]);
    }
    return false;
  }
  equals(other) {
    return this === other || other instanceof ATNConfigSet && equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;
  }
  hashCode() {
    const hash = new HashCode();
    hash.update(this.configs);
    return hash.finish();
  }
  updateHashCode(hash) {
    if (this.readOnly) {
      if (this.cachedHashCode === -1) {
        this.cachedHashCode = this.hashCode();
      }
      hash.update(this.cachedHashCode);
    } else {
      hash.update(this.hashCode());
    }
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.contains(item);
  }
  containsFast(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.containsFast(item);
  }
  clear() {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    this.configs = [];
    this.cachedHashCode = -1;
    this.configLookup = new HashSet();
  }
  setReadonly(readOnly) {
    this.readOnly = readOnly;
    if (readOnly) {
      this.configLookup = null;
    }
  }
  toString() {
    return arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
};

// node_modules/antlr4/src/antlr4/dfa/DFAState.js
var DFAState = class {
  constructor(stateNumber, configs) {
    if (stateNumber === null) {
      stateNumber = -1;
    }
    if (configs === null) {
      configs = new ATNConfigSet();
    }
    this.stateNumber = stateNumber;
    this.configs = configs;
    this.edges = null;
    this.isAcceptState = false;
    this.prediction = 0;
    this.lexerActionExecutor = null;
    this.requiresFullContext = false;
    this.predicates = null;
    return this;
  }
  /**
   * Get the set of all alts mentioned by all ATN configurations in this
   * DFA state.
   */
  getAltSet() {
    const alts = new HashSet();
    if (this.configs !== null) {
      for (let i = 0; i < this.configs.length; i++) {
        const c = this.configs[i];
        alts.add(c.alt);
      }
    }
    if (alts.length === 0) {
      return null;
    } else {
      return alts;
    }
  }
  /**
   * Two {@link DFAState} instances are equal if their ATN configuration sets
   * are the same. This method is used to see if a state already exists.
   *
   * <p>Because the number of alternatives and number of ATN configurations are
   * finite, there is a finite number of DFA states that can be processed.
   * This is necessary to show that the algorithm terminates.</p>
   *
   * <p>Cannot test the DFA state numbers here because in
   * {@link ParserATNSimulator//addDFAState} we need to know if any other state
   * exists that has this exact set of ATN configurations. The
   * {@link //stateNumber} is irrelevant.</p>
   */
  equals(other) {
    return this === other || other instanceof DFAState && this.configs.equals(other.configs);
  }
  toString() {
    let s = "" + this.stateNumber + ":" + this.configs;
    if (this.isAcceptState) {
      s = s + "=>";
      if (this.predicates !== null)
        s = s + this.predicates;
      else
        s = s + this.prediction;
    }
    return s;
  }
  hashCode() {
    const hash = new HashCode();
    hash.update(this.configs);
    return hash.finish();
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNSimulator.js
var ATNSimulator = class {
  constructor(atn3, sharedContextCache2) {
    this.atn = atn3;
    this.sharedContextCache = sharedContextCache2;
    return this;
  }
  getCachedContext(context) {
    if (this.sharedContextCache === null) {
      return context;
    }
    const visited = new HashMap();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
  }
};
ATNSimulator.ERROR = new DFAState(2147483647, new ATNConfigSet());

// node_modules/antlr4/src/antlr4/atn/OrderedATNConfigSet.js
var OrderedATNConfigSet = class extends ATNConfigSet {
  constructor() {
    super();
    this.configLookup = new HashSet();
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerATNConfig.js
var LexerATNConfig = class extends ATNConfig {
  constructor(params, config) {
    super(params, config);
    const lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;
    this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
    this.equalsForConfigSet = LexerATNConfig.prototype.equals;
    return this;
  }
  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(other) {
    return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
  }
  checkNonGreedyDecision(source, target) {
    return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;
  }
};

// node_modules/antlr4/src/antlr4/action/LexerIndexedCustomAction.js
var LexerIndexedCustomAction = class extends LexerAction {
  constructor(offset, action) {
    super(action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
  }
  /**
   * <p>This method calls {@link //execute} on the result of {@link //getAction}
   * using the provided {@code lexer}.</p>
   */
  execute(lexer) {
    this.action.execute(lexer);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.offset, this.action);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerIndexedCustomAction)) {
      return false;
    } else {
      return this.offset === other.offset && this.action === other.action;
    }
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js
var LexerActionExecutor = class {
  /**
   * Represents an executor for a sequence of lexer actions which traversed during
   * the matching operation of a lexer rule (token).
   *
   * <p>The executor tracks position information for position-dependent lexer actions
   * efficiently, ensuring that actions appearing only at the end of the rule do
   * not cause bloating of the {@link DFA} created for the lexer.</p>
   */
  constructor(lexerActions) {
    this.lexerActions = lexerActions === null ? [] : lexerActions;
    this.cachedHashCode = HashCode.hashStuff(lexerActions);
    return this;
  }
  /**
   * Creates a {@link LexerActionExecutor} which encodes the current offset
   * for position-dependent lexer actions.
   *
   * <p>Normally, when the executor encounters lexer actions where
   * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
   * {@link IntStream//seek} on the input {@link CharStream} to set the input
   * position to the <em>end</em> of the current token. This behavior provides
   * for efficient DFA representation of lexer actions which appear at the end
   * of a lexer rule, even when the lexer rule matches a variable number of
   * characters.</p>
   *
   * <p>Prior to traversing a match transition in the ATN, the current offset
   * from the token start index is assigned to all position-dependent lexer
   * actions which have not already been assigned a fixed offset. By storing
   * the offsets relative to the token start index, the DFA representation of
   * lexer actions which appear in the middle of tokens remains efficient due
   * to sharing among tokens of the same length, regardless of their absolute
   * position in the input stream.</p>
   *
   * <p>If the current executor already has offsets assigned to all
   * position-dependent lexer actions, the method returns {@code this}.</p>
   *
   * @param offset The current offset to assign to all position-dependent
   * lexer actions which do not already have offsets assigned.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
   * for all position-dependent lexer actions.
   */
  fixOffsetBeforeMatch(offset) {
    let updatedLexerActions = null;
    for (let i = 0; i < this.lexerActions.length; i++) {
      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
        if (updatedLexerActions === null) {
          updatedLexerActions = this.lexerActions.concat([]);
        }
        updatedLexerActions[i] = new LexerIndexedCustomAction(
          offset,
          this.lexerActions[i]
        );
      }
    }
    if (updatedLexerActions === null) {
      return this;
    } else {
      return new LexerActionExecutor(updatedLexerActions);
    }
  }
  /**
   * Execute the actions encapsulated by this executor within the context of a
   * particular {@link Lexer}.
   *
   * <p>This method calls {@link IntStream//seek} to set the position of the
   * {@code input} {@link CharStream} prior to calling
   * {@link LexerAction//execute} on a position-dependent action. Before the
   * method returns, the input position will be restored to the same position
   * it was in when the method was invoked.</p>
   *
   * @param lexer The lexer instance.
   * @param input The input stream which is the source for the current token.
   * When this method is called, the current {@link IntStream//index} for
   * {@code input} should be the start of the following token, i.e. 1
   * character past the end of the current token.
   * @param startIndex The token start index. This value may be passed to
   * {@link IntStream//seek} to set the {@code input} position to the beginning
   * of the token.
   */
  execute(lexer, input, startIndex) {
    let requiresSeek = false;
    const stopIndex = input.index;
    try {
      for (let i = 0; i < this.lexerActions.length; i++) {
        let lexerAction = this.lexerActions[i];
        if (lexerAction instanceof LexerIndexedCustomAction) {
          const offset = lexerAction.offset;
          input.seek(startIndex + offset);
          lexerAction = lexerAction.action;
          requiresSeek = startIndex + offset !== stopIndex;
        } else if (lexerAction.isPositionDependent) {
          input.seek(stopIndex);
          requiresSeek = false;
        }
        lexerAction.execute(lexer);
      }
    } finally {
      if (requiresSeek) {
        input.seek(stopIndex);
      }
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerActionExecutor)) {
      return false;
    } else if (this.cachedHashCode != other.cachedHashCode) {
      return false;
    } else if (this.lexerActions.length != other.lexerActions.length) {
      return false;
    } else {
      const numActions = this.lexerActions.length;
      for (let idx = 0; idx < numActions; ++idx) {
        if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
          return false;
        }
      }
      return true;
    }
  }
  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input {@code lexerActionExecutor} followed by a specified
   * {@code lexerAction}.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
   * though it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in {@code lexerActionExecutor}.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
   * of {@code lexerActionExecutor} and {@code lexerAction}.
   */
  static append(lexerActionExecutor, lexerAction) {
    if (lexerActionExecutor === null) {
      return new LexerActionExecutor([lexerAction]);
    }
    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
    return new LexerActionExecutor(lexerActions);
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js
function resetSimState(sim) {
  sim.index = -1;
  sim.line = 0;
  sim.column = -1;
  sim.dfaState = null;
}
var SimState = class {
  constructor() {
    resetSimState(this);
  }
  reset() {
    resetSimState(this);
  }
};
var LexerATNSimulator = class extends ATNSimulator {
  /**
   * When we hit an accept state in either the DFA or the ATN, we
   * have to notify the character stream to start buffering characters
   * via {@link IntStream//mark} and record the current state. The current sim state
   * includes the current index into the input, the current line,
   * and current character position in that line. Note that the Lexer is
   * tracking the starting line and characterization of the token. These
   * variables track the "state" of the simulator when it hits an accept state.
   *
   * <p>We track these variables separately for the DFA and ATN simulation
   * because the DFA simulation often has to fail over to the ATN
   * simulation. If the ATN simulation fails, we need the DFA to fall
   * back to its previously accepted state, if any. If the ATN succeeds,
   * then the ATN does the accept and the DFA simulator that invoked it
   * can simply return the predicted token type.</p>
   */
  constructor(recog, atn3, decisionToDFA, sharedContextCache2) {
    super(atn3, sharedContextCache2);
    this.decisionToDFA = decisionToDFA;
    this.recog = recog;
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
    this.prevAccept = new SimState();
  }
  copyState(simulator) {
    this.column = simulator.column;
    this.line = simulator.line;
    this.mode = simulator.mode;
    this.startIndex = simulator.startIndex;
  }
  match(input, mode) {
    this.mode = mode;
    const mark = input.mark();
    try {
      this.startIndex = input.index;
      this.prevAccept.reset();
      const dfa = this.decisionToDFA[mode];
      if (dfa.s0 === null) {
        return this.matchATN(input);
      } else {
        return this.execATN(input, dfa.s0);
      }
    } finally {
      input.release(mark);
    }
  }
  reset() {
    this.prevAccept.reset();
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
  }
  matchATN(input) {
    const startState = this.atn.modeToStartState[this.mode];
    if (LexerATNSimulator.debug) {
      console.log("matchATN mode " + this.mode + " start: " + startState);
    }
    const old_mode = this.mode;
    const s0_closure = this.computeStartState(input, startState);
    const suppressEdge = s0_closure.hasSemanticContext;
    s0_closure.hasSemanticContext = false;
    const next = this.addDFAState(s0_closure);
    if (!suppressEdge) {
      this.decisionToDFA[this.mode].s0 = next;
    }
    const predict = this.execATN(input, next);
    if (LexerATNSimulator.debug) {
      console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
    }
    return predict;
  }
  execATN(input, ds0) {
    if (LexerATNSimulator.debug) {
      console.log("start state closure=" + ds0.configs);
    }
    if (ds0.isAcceptState) {
      this.captureSimState(this.prevAccept, input, ds0);
    }
    let t = input.LA(1);
    let s = ds0;
    for (; ; ) {
      if (LexerATNSimulator.debug) {
        console.log("execATN loop starting closure: " + s.configs);
      }
      let target = this.getExistingTargetState(s, t);
      if (target === null) {
        target = this.computeTargetState(input, s, t);
      }
      if (target === ATNSimulator.ERROR) {
        break;
      }
      if (t !== Token.EOF) {
        this.consume(input);
      }
      if (target.isAcceptState) {
        this.captureSimState(this.prevAccept, input, target);
        if (t === Token.EOF) {
          break;
        }
      }
      t = input.LA(1);
      s = target;
    }
    return this.failOrAccept(this.prevAccept, input, s.configs, t);
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param s The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(s, t) {
    if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
      return null;
    }
    let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
    if (target === void 0) {
      target = null;
    }
    if (LexerATNSimulator.debug && target !== null) {
      console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
    }
    return target;
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param input The input stream
   * @param s The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR}.
   */
  computeTargetState(input, s, t) {
    const reach = new OrderedATNConfigSet();
    this.getReachableConfigSet(input, s.configs, reach, t);
    if (reach.items.length === 0) {
      if (!reach.hasSemanticContext) {
        this.addDFAEdge(s, t, ATNSimulator.ERROR);
      }
      return ATNSimulator.ERROR;
    }
    return this.addDFAEdge(s, t, null, reach);
  }
  failOrAccept(prevAccept, input, reach, t) {
    if (this.prevAccept.dfaState !== null) {
      const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
      this.accept(
        input,
        lexerActionExecutor,
        this.startIndex,
        prevAccept.index,
        prevAccept.line,
        prevAccept.column
      );
      return prevAccept.dfaState.prediction;
    } else {
      if (t === Token.EOF && input.index === this.startIndex) {
        return Token.EOF;
      }
      throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
    }
  }
  /**
   * Given a starting configuration set, figure out all ATN configurations
   * we can reach upon input {@code t}. Parameter {@code reach} is a return
   * parameter.
   */
  getReachableConfigSet(input, closure, reach, t) {
    let skipAlt = ATN.INVALID_ALT_NUMBER;
    for (let i = 0; i < closure.items.length; i++) {
      const cfg = closure.items[i];
      const currentAltReachedAcceptState = cfg.alt === skipAlt;
      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
        continue;
      }
      if (LexerATNSimulator.debug) {
        console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recog, true));
      }
      for (let j = 0; j < cfg.state.transitions.length; j++) {
        const trans = cfg.state.transitions[j];
        const target = this.getReachableTarget(trans, t);
        if (target !== null) {
          let lexerActionExecutor = cfg.lexerActionExecutor;
          if (lexerActionExecutor !== null) {
            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
          }
          const treatEofAsEpsilon = t === Token.EOF;
          const config = new LexerATNConfig({ state: target, lexerActionExecutor }, cfg);
          if (this.closure(
            input,
            config,
            reach,
            currentAltReachedAcceptState,
            true,
            treatEofAsEpsilon
          )) {
            skipAlt = cfg.alt;
          }
        }
      }
    }
  }
  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
    if (LexerATNSimulator.debug) {
      console.log("ACTION %s\n", lexerActionExecutor);
    }
    input.seek(index);
    this.line = line;
    this.column = charPos;
    if (lexerActionExecutor !== null && this.recog !== null) {
      lexerActionExecutor.execute(this.recog, input, startIndex);
    }
  }
  getReachableTarget(trans, t) {
    if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
      return trans.target;
    } else {
      return null;
    }
  }
  computeStartState(input, p) {
    const initialContext = PredictionContext.EMPTY;
    const configs = new OrderedATNConfigSet();
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const cfg = new LexerATNConfig({ state: target, alt: i + 1, context: initialContext }, null);
      this.closure(input, cfg, configs, false, false, false);
    }
    return configs;
  }
  /**
   * Since the alternatives within any lexer decision are ordered by
   * preference, this method stops pursuing the closure as soon as an accept
   * state is reached. After the first accept state is reached by depth-first
   * search from {@code config}, all other (potentially reachable) states for
   * this rule would have a lower priority.
   *
   * @return {Boolean} {@code true} if an accept state is reached, otherwise
   * {@code false}.
   */
  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (LexerATNSimulator.debug) {
      console.log("closure(" + config.toString(this.recog, true) + ")");
    }
    if (config.state instanceof RuleStopState) {
      if (LexerATNSimulator.debug) {
        if (this.recog !== null) {
          console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
        } else {
          console.log("closure at rule stop %s\n", config);
        }
      }
      if (config.context === null || config.context.hasEmptyPath()) {
        if (config.context === null || config.context.isEmpty()) {
          configs.add(config);
          return true;
        } else {
          configs.add(new LexerATNConfig({ state: config.state, context: PredictionContext.EMPTY }, config));
          currentAltReachedAcceptState = true;
        }
      }
      if (config.context !== null && !config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
            const newContext = config.context.getParent(i);
            const returnState = this.atn.states[config.context.getReturnState(i)];
            cfg = new LexerATNConfig({ state: returnState, context: newContext }, config);
            currentAltReachedAcceptState = this.closure(
              input,
              cfg,
              configs,
              currentAltReachedAcceptState,
              speculative,
              treatEofAsEpsilon
            );
          }
        }
      }
      return currentAltReachedAcceptState;
    }
    if (!config.state.epsilonOnlyTransitions) {
      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
        configs.add(config);
      }
    }
    for (let j = 0; j < config.state.transitions.length; j++) {
      const trans = config.state.transitions[j];
      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
      if (cfg !== null) {
        currentAltReachedAcceptState = this.closure(
          input,
          cfg,
          configs,
          currentAltReachedAcceptState,
          speculative,
          treatEofAsEpsilon
        );
      }
    }
    return currentAltReachedAcceptState;
  }
  // side-effect: can alter configs.hasSemanticContext
  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (trans.serializationType === Transition.RULE) {
      const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
      cfg = new LexerATNConfig({ state: trans.target, context: newContext }, config);
    } else if (trans.serializationType === Transition.PRECEDENCE) {
      throw "Precedence predicates are not supported in lexers.";
    } else if (trans.serializationType === Transition.PREDICATE) {
      if (LexerATNSimulator.debug) {
        console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
      }
      configs.hasSemanticContext = true;
      if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
        cfg = new LexerATNConfig({ state: trans.target }, config);
      }
    } else if (trans.serializationType === Transition.ACTION) {
      if (config.context === null || config.context.hasEmptyPath()) {
        const lexerActionExecutor = LexerActionExecutor.append(
          config.lexerActionExecutor,
          this.atn.lexerActions[trans.actionIndex]
        );
        cfg = new LexerATNConfig({ state: trans.target, lexerActionExecutor }, config);
      } else {
        cfg = new LexerATNConfig({ state: trans.target }, config);
      }
    } else if (trans.serializationType === Transition.EPSILON) {
      cfg = new LexerATNConfig({ state: trans.target }, config);
    } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {
      if (treatEofAsEpsilon) {
        if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
          cfg = new LexerATNConfig({ state: trans.target }, config);
        }
      }
    }
    return cfg;
  }
  /**
   * Evaluate a predicate specified in the lexer.
   *
   * <p>If {@code speculative} is {@code true}, this method was called before
   * {@link //consume} for the matched character. This method should call
   * {@link //consume} before evaluating the predicate to ensure position
   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
   * and {@link Lexer//getcolumn}, properly reflect the current
   * lexer state. This method should restore {@code input} and the simulator
   * to the original state before returning (i.e. undo the actions made by the
   * call to {@link //consume}.</p>
   *
   * @param input The input stream.
   * @param ruleIndex The rule containing the predicate.
   * @param predIndex The index of the predicate within the rule.
   * @param speculative {@code true} if the current index in {@code input} is
   * one character before the predicate's location.
   *
   * @return {@code true} if the specified predicate evaluates to
   * {@code true}.
   */
  evaluatePredicate(input, ruleIndex, predIndex, speculative) {
    if (this.recog === null) {
      return true;
    }
    if (!speculative) {
      return this.recog.sempred(null, ruleIndex, predIndex);
    }
    const savedcolumn = this.column;
    const savedLine = this.line;
    const index = input.index;
    const marker = input.mark();
    try {
      this.consume(input);
      return this.recog.sempred(null, ruleIndex, predIndex);
    } finally {
      this.column = savedcolumn;
      this.line = savedLine;
      input.seek(index);
      input.release(marker);
    }
  }
  captureSimState(settings, input, dfaState) {
    settings.index = input.index;
    settings.line = this.line;
    settings.column = this.column;
    settings.dfaState = dfaState;
  }
  addDFAEdge(from_, tk, to, cfgs) {
    if (to === void 0) {
      to = null;
    }
    if (cfgs === void 0) {
      cfgs = null;
    }
    if (to === null && cfgs !== null) {
      const suppressEdge = cfgs.hasSemanticContext;
      cfgs.hasSemanticContext = false;
      to = this.addDFAState(cfgs);
      if (suppressEdge) {
        return to;
      }
    }
    if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
      return to;
    }
    if (LexerATNSimulator.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
    }
    if (from_.edges === null) {
      from_.edges = [];
    }
    from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to;
    return to;
  }
  /**
   * Add a new DFA state if there isn't one with this set of
   * configurations already. This method also detects the first
   * configuration containing an ATN rule stop state. Later, when
   * traversing the DFA, we will know which rule to accept.
   */
  addDFAState(configs) {
    const proposed = new DFAState(null, configs);
    let firstConfigWithRuleStopState = null;
    for (let i = 0; i < configs.items.length; i++) {
      const cfg = configs.items[i];
      if (cfg.state instanceof RuleStopState) {
        firstConfigWithRuleStopState = cfg;
        break;
      }
    }
    if (firstConfigWithRuleStopState !== null) {
      proposed.isAcceptState = true;
      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
    }
    const dfa = this.decisionToDFA[this.mode];
    const existing = dfa.states.get(proposed);
    if (existing !== null) {
      return existing;
    }
    const newState = proposed;
    newState.stateNumber = dfa.states.length;
    configs.setReadonly(true);
    newState.configs = configs;
    dfa.states.add(newState);
    return newState;
  }
  getDFA(mode) {
    return this.decisionToDFA[mode];
  }
  // Get the text matched so far for the current token.
  getText(input) {
    return input.getText(this.startIndex, input.index - 1);
  }
  consume(input) {
    const curChar = input.LA(1);
    if (curChar === "\n".charCodeAt(0)) {
      this.line += 1;
      this.column = 0;
    } else {
      this.column += 1;
    }
    input.consume();
  }
  getTokenName(tt) {
    if (tt === -1) {
      return "EOF";
    } else {
      return "'" + String.fromCharCode(tt) + "'";
    }
  }
};
LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;
LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127;

// node_modules/antlr4/src/antlr4/dfa/PredPrediction.js
var PredPrediction = class {
  constructor(pred, alt) {
    this.alt = alt;
    this.pred = pred;
  }
  toString() {
    return "(" + this.pred + ", " + this.alt + ")";
  }
};

// node_modules/antlr4/src/antlr4/misc/AltDict.js
var AltDict = class {
  constructor() {
    this.data = {};
  }
  get(key) {
    return this.data["k-" + key] || null;
  }
  set(key, value) {
    this.data["k-" + key] = value;
  }
  values() {
    return Object.keys(this.data).filter((key) => key.startsWith("k-")).map((key) => this.data[key], this);
  }
};

// node_modules/antlr4/src/antlr4/atn/PredictionMode.js
var PredictionMode = {
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   * <p>
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link //LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link //SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link //LL} prediction abilities to complete successfully.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  SLL: 0,
  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   * <p>
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for <em>exactly which</em> alternatives are
   * ambiguous.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL: 1,
  /**
   *
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link //LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   * <p>
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL_EXACT_AMBIG_DETECTION: 2,
  /**
   *
   * Computes the SLL prediction termination condition.
   *
   * <p>
   * This method computes the SLL prediction termination condition for both of
   * the following cases.</p>
   *
   * <ul>
   * <li>The usual SLL+LL fallback upon SLL conflict</li>
   * <li>Pure SLL without LL fallback</li>
   * </ul>
   *
   * <p><strong>COMBINED SLL+LL PARSING</strong></p>
   *
   * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
   * ensured regardless of how the termination condition is computed by this
   * method. Due to the substantially higher cost of LL prediction, the
   * prediction should only fall back to LL when the additional lookahead
   * cannot lead to a unique SLL prediction.</p>
   *
   * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
   * conflicting subsets should fall back to full LL, even if the
   * configuration sets don't resolve to the same alternative (e.g.
   * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
   * configuration, SLL could continue with the hopes that more lookahead will
   * resolve via one of those non-conflicting configurations.</p>
   *
   * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
   * stops when it sees only conflicting configuration subsets. In contrast,
   * full LL keeps going when there is uncertainty.</p>
   *
   * <p><strong>HEURISTIC</strong></p>
   *
   * <p>As a heuristic, we stop prediction when we see any conflicting subset
   * unless we see a state that only has one alternative associated with it.
   * The single-alt-state thing lets prediction continue upon rules like
   * (otherwise, it would admit defeat too soon):</p>
   *
   * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
   *
   * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
   * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
   * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
   * processing this node because alternative to has another way to continue,
   * via {@code [6|2|[]]}.</p>
   *
   * <p>It also let's us continue for this rule:</p>
   *
   * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
   *
   * <p>After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not stop
   * working on this state. In the previous example, we're concerned with
   * states associated with the conflicting alternatives. Here alt 3 is not
   * associated with the conflicting configs, but since we can continue
   * looking for input reasonably, don't declare the state done.</p>
   *
   * <p><strong>PURE SLL PARSING</strong></p>
   *
   * <p>To handle pure SLL parsing, all we have to do is make sure that we
   * combine stack contexts for configurations that differ only by semantic
   * predicate. From there, we can do the usual SLL termination heuristic.</p>
   *
   * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
   *
   * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
   * states because they need to create the DFA cache that works in all
   * semantic situations. In contrast, full LL evaluates predicates collected
   * during start state computation so it can ignore predicates thereafter.
   * This means that SLL termination detection can totally ignore semantic
   * predicates.</p>
   *
   * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
   * semantic predicate contexts so we might see two configurations like the
   * following.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
   *
   * <p>Before testing these configurations against others, we have to merge
   * {@code x} and {@code x'} (without modifying the existing configurations).
   * For example, we test {@code (x+x')==x''} when looking for conflicts in
   * the following configurations.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
   *
   * <p>If the configuration set has predicates (as indicated by
   * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
   * the configurations to strip out all of the predicates so that a standard
   * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
   */
  hasSLLConflictTerminatingPrediction: function(mode, configs) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return true;
    }
    if (mode === PredictionMode.SLL) {
      if (configs.hasSemanticContext) {
        const dup = new ATNConfigSet();
        for (let i = 0; i < configs.items.length; i++) {
          let c = configs.items[i];
          c = new ATNConfig({ semanticContext: SemanticContext.NONE }, c);
          dup.add(c);
        }
        configs = dup;
      }
    }
    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
  },
  /**
   * Checks if any configuration in {@code configs} is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if any configuration in {@code configs} is in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  hasConfigInRuleStopState: function(configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.state instanceof RuleStopState) {
        return true;
      }
    }
    return false;
  },
  /**
   * Checks if all configurations in {@code configs} are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if all configurations in {@code configs} are in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  allConfigsInRuleStopStates: function(configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (!(c.state instanceof RuleStopState)) {
        return false;
      }
    }
    return true;
  },
  /**
   *
   * Full LL prediction termination.
   *
   * <p>Can we stop looking ahead during ATN simulation or is there some
   * uncertainty as to which alternative we will ultimately pick, after
   * consuming more input? Even if there are partial conflicts, we might know
   * that everything is going to resolve to the same minimum alternative. That
   * means we can stop since no more lookahead will change that fact. On the
   * other hand, there might be multiple conflicts that resolve to different
   * minimums. That means we need more look ahead to decide which of those
   * alternatives we should predict.</p>
   *
   * <p>The basic idea is to split the set of configurations {@code C}, into
   * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
   * non-conflicting configurations. Two configurations conflict if they have
   * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
   * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
   * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
   *
   * <p>Reduce these configuration subsets to the set of possible alternatives.
   * You can compute the alternative subsets in one pass as follows:</p>
   *
   * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
   * {@code C} holding {@code s} and {@code ctx} fixed.</p>
   *
   * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   *
   * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
   *
   * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
   * {@code s} and {@code ctx}.</p>
   *
   * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
   * the union of these alternative subsets is a singleton, then no amount of
   * more lookahead will help us. We will always pick that alternative. If,
   * however, there is more than one alternative, then we are uncertain which
   * alternative to predict and must continue looking for resolution. We may
   * or may not discover an ambiguity in the future, even if there are no
   * conflicting subsets this round.</p>
   *
   * <p>The biggest sin is to terminate early because it means we've made a
   * decision but were uncertain as to the eventual outcome. We haven't used
   * enough lookahead. On the other hand, announcing a conflict too late is no
   * big deal; you will still have the conflict. It's just inefficient. It
   * might even look until the end of file.</p>
   *
   * <p>No special consideration for semantic predicates is required because
   * predicates are evaluated on-the-fly for full LL prediction, ensuring that
   * no configuration contains a semantic context during the termination
   * check.</p>
   *
   * <p><strong>CONFLICTING CONFIGS</strong></p>
   *
   * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
   * when {@code i!=j} but {@code x=x'}. Because we merge all
   * {@code (s, i, _)} configurations together, that means that there are at
   * most {@code n} configurations associated with state {@code s} for
   * {@code n} possible alternatives in the decision. The merged stacks
   * complicate the comparison of configuration contexts {@code x} and
   * {@code x'}. Sam checks to see if one is a subset of the other by calling
   * merge and checking to see if the merged result is either {@code x} or
   * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
   * is the superset, then {@code i} is the only possible prediction since the
   * others resolve to {@code min(i)} as well. However, if {@code x} is
   * associated with {@code j>i} then at least one stack configuration for
   * {@code j} is not in conflict with alternative {@code i}. The algorithm
   * should keep going, looking for more lookahead due to the uncertainty.</p>
   *
   * <p>For simplicity, I'm doing a equality check between {@code x} and
   * {@code x'} that lets the algorithm continue to consume lookahead longer
   * than necessary. The reason I like the equality is of course the
   * simplicity but also because that is the test you need to detect the
   * alternatives that are actually in conflict.</p>
   *
   * <p><strong>CONTINUE/STOP RULE</strong></p>
   *
   * <p>Continue if union of resolved alternative sets from non-conflicting and
   * conflicting alternative subsets has more than one alternative. We are
   * uncertain about which alternative to predict.</p>
   *
   * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
   * alternatives are still in the running for the amount of input we've
   * consumed at this point. The conflicting sets let us to strip away
   * configurations that won't lead to more states because we resolve
   * conflicts to the configuration with a minimum alternate for the
   * conflicting set.</p>
   *
   * <p><strong>CASES</strong></p>
   *
   * <ul>
   *
   * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
   *
   * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
   * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
   * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1,3}} =&gt; continue
   * </li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
   * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1}} =&gt; stop and predict 1</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
   * ambiguity {@code {1,2}}</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
   * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {2}} = {@code {1,2}} =&gt; continue</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
   * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {3}} = {@code {1,3}} =&gt; continue</li>
   *
   * </ul>
   *
   * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
   *
   * <p>If all states report the same conflicting set of alternatives, then we
   * know we have the exact ambiguity set.</p>
   *
   * <p><code>|A_<em>i</em>|&gt;1</code> and
   * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
   *
   * <p>In other words, we continue examining lookahead until all {@code A_i}
   * have more than one alternative and all {@code A_i} are the same. If
   * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
   * because the resolved set is {@code {1}}. To determine what the real
   * ambiguity is, we have to know whether the ambiguity is between one and
   * two or one and three so we keep going. We can only stop prediction when
   * we need exact ambiguity detection when the sets look like
   * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
   */
  resolvesToJustOneViableAlt: function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
  },
  /**
   * Determines if every alternative subset in {@code altsets} contains more
   * than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every {@link BitSet} in {@code altsets} has
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  allSubsetsConflict: function(altsets) {
    return !PredictionMode.hasNonConflictingAltSet(altsets);
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * exactly one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
   */
  hasNonConflictingAltSet: function(altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (alts.length === 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * more than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  hasConflictingAltSet: function(altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (alts.length > 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if every alternative subset in {@code altsets} is equivalent.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every member of {@code altsets} is equal to the
   * others, otherwise {@code false}
   */
  allSubsetsEqual: function(altsets) {
    let first = null;
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (first === null) {
        first = alts;
      } else if (alts !== first) {
        return false;
      }
    }
    return true;
  },
  /**
   * Returns the unique alternative predicted by all alternative subsets in
   * {@code altsets}. If no such alternative exists, this method returns
   * {@link ATN//INVALID_ALT_NUMBER}.
   *
   * @param altsets a collection of alternative subsets
   */
  getUniqueAlt: function(altsets) {
    const all = PredictionMode.getAlts(altsets);
    if (all.length === 1) {
      return all.minValue();
    } else {
      return ATN.INVALID_ALT_NUMBER;
    }
  },
  /**
   * Gets the complete set of represented alternatives for a collection of
   * alternative subsets. This method returns the union of each {@link BitSet}
   * in {@code altsets}.
   *
   * @param altsets a collection of alternative subsets
   * @return the set of represented alternatives in {@code altsets}
   */
  getAlts: function(altsets) {
    const all = new BitSet();
    altsets.map(function(alts) {
      all.or(alts);
    });
    return all;
  },
  /**
   * This function gets the conflicting alt subsets from a configuration set.
   * For each configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   */
  getConflictingAltSubsets: function(configs) {
    const configToAlts = new HashMap();
    configToAlts.hashFunction = function(cfg) {
      HashCode.hashStuff(cfg.state.stateNumber, cfg.context);
    };
    configToAlts.equalsFunction = function(c1, c2) {
      return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);
    };
    configs.items.map(function(cfg) {
      let alts = configToAlts.get(cfg);
      if (alts === null) {
        alts = new BitSet();
        configToAlts.set(cfg, alts);
      }
      alts.add(cfg.alt);
    });
    return configToAlts.getValues();
  },
  /**
   * Get a map from state to alt subset from a configuration set. For each
   * configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
   * </pre>
   */
  getStateToAltMap: function(configs) {
    const m = new AltDict();
    configs.items.map(function(c) {
      let alts = m.get(c.state);
      if (alts === null) {
        alts = new BitSet();
        m.set(c.state, alts);
      }
      alts.add(c.alt);
    });
    return m;
  },
  hasStateAssociatedWithOneAlt: function(configs) {
    const values = PredictionMode.getStateToAltMap(configs).values();
    for (let i = 0; i < values.length; i++) {
      if (values[i].length === 1) {
        return true;
      }
    }
    return false;
  },
  getSingleViableAlt: function(altsets) {
    let result = null;
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      const minAlt = alts.minValue();
      if (result === null) {
        result = minAlt;
      } else if (result !== minAlt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return result;
  }
};
var PredictionMode_default = PredictionMode;

// node_modules/antlr4/src/antlr4/error/NoViableAltException.js
var NoViableAltException = class extends RecognitionException {
  constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
    ctx = ctx || recognizer._ctx;
    offendingToken = offendingToken || recognizer.getCurrentToken();
    startToken = startToken || recognizer.getCurrentToken();
    input = input || recognizer.getInputStream();
    super({ message: "", recognizer, input, ctx });
    this.deadEndConfigs = deadEndConfigs;
    this.startToken = startToken;
    this.offendingToken = offendingToken;
  }
};

// node_modules/antlr4/src/antlr4/utils/DoubleDict.js
var DoubleDict = class {
  constructor(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || HashMap;
    this.cacheMap = new this.defaultMapCtor();
  }
  get(a, b) {
    const d = this.cacheMap.get(a) || null;
    return d === null ? null : d.get(b) || null;
  }
  set(a, b, o) {
    let d = this.cacheMap.get(a) || null;
    if (d === null) {
      d = new this.defaultMapCtor();
      this.cacheMap.set(a, d);
    }
    d.set(b, o);
  }
};

// node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js
var ParserATNSimulator = class extends ATNSimulator {
  constructor(parser, atn3, decisionToDFA, sharedContextCache2) {
    super(atn3, sharedContextCache2);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    this.predictionMode = PredictionMode_default.LL;
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    this.mergeCache = null;
    this.debug = false;
    this.debug_closure = false;
    this.debug_add = false;
    this.debug_list_atn_decisions = false;
    this.dfa_debug = false;
    this.retry_debug = false;
  }
  reset() {
  }
  adaptivePredict(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;
    const dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    const m = input.mark();
    const index = input.index;
    try {
      let s0;
      if (dfa.precedenceDfa) {
        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
      } else {
        s0 = dfa.s0;
      }
      if (s0 === null) {
        if (outerContext === null) {
          outerContext = RuleContext.EMPTY;
        }
        if (this.debug || this.debug_list_atn_decisions) {
          console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
        }
        const fullCtx = false;
        let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);
        if (dfa.precedenceDfa) {
          dfa.s0.configs = s0_closure;
          s0_closure = this.applyPrecedenceFilter(s0_closure);
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
        } else {
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.s0 = s0;
        }
      }
      const alt = this.execATN(dfa, s0, input, index, outerContext);
      if (this.debug) {
        console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
      }
      return alt;
    } finally {
      this._dfa = null;
      this.mergeCache = null;
      input.seek(index);
      input.release(m);
    }
  }
  /**
   * Performs ATN simulation to compute a predicted alternative based
   *  upon the remaining input, but also updates the DFA cache to avoid
   *  having to traverse the ATN again for the same input sequence.
   *
   * There are some key conditions we're looking for after computing a new
   * set of ATN configs (proposed DFA state):
   *       if the set is empty, there is no viable alternative for current symbol
   *       does the state uniquely predict an alternative?
   *       does the state have a conflict that would prevent us from
   *         putting it on the work list?
   *
   * We also have some key operations to do:
   *       add an edge from previous DFA state to potentially new DFA state, D,
   *         upon current symbol but only if adding to work list, which means in all
   *         cases except no viable alternative (and possibly non-greedy decisions?)
   *       collecting predicates and adding semantic context to DFA accept states
   *       adding rule context to context-sensitive DFA accept states
   *       consuming an input symbol
   *       reporting a conflict
   *       reporting an ambiguity
   *       reporting a context sensitivity
   *       reporting insufficient predicates
   *
   * cover these cases:
   *    dead end
   *    single alt
   *    single alt + preds
   *    conflict
   *    conflict + preds
   *
   */
  execATN(dfa, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    let alt;
    let previousD = s0;
    if (this.debug) {
      console.log("s0 = " + s0);
    }
    let t = input.LA(1);
    for (; ; ) {
      let D = this.getExistingTargetState(previousD, t);
      if (D === null) {
        D = this.computeTargetState(dfa, previousD, t);
      }
      if (D === ATNSimulator.ERROR) {
        const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
        input.seek(startIndex);
        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      if (D.requiresFullContext && this.predictionMode !== PredictionMode_default.SLL) {
        let conflictingAlts = null;
        if (D.predicates !== null) {
          if (this.debug) {
            console.log("DFA state has preds in DFA sim LL failover");
          }
          const conflictIndex = input.index;
          if (conflictIndex !== startIndex) {
            input.seek(startIndex);
          }
          conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
          if (conflictingAlts.length === 1) {
            if (this.debug) {
              console.log("Full LL avoided");
            }
            return conflictingAlts.minValue();
          }
          if (conflictIndex !== startIndex) {
            input.seek(conflictIndex);
          }
        }
        if (this.dfa_debug) {
          console.log("ctx sensitive state " + outerContext + " in " + D);
        }
        const fullCtx = true;
        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
        this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
        alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
        return alt;
      }
      if (D.isAcceptState) {
        if (D.predicates === null) {
          return D.prediction;
        }
        const stopIndex = input.index;
        input.seek(startIndex);
        const alts = this.evalSemanticContext(D.predicates, outerContext, true);
        if (alts.length === 0) {
          throw this.noViableAlt(input, outerContext, D.configs, startIndex);
        } else if (alts.length === 1) {
          return alts.minValue();
        } else {
          this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
          return alts.minValue();
        }
      }
      previousD = D;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param previousD The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(previousD, t) {
    const edges = previousD.edges;
    if (edges === null) {
      return null;
    } else {
      return edges[t + 1] || null;
    }
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param dfa The DFA
   * @param previousD The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR
   */
  computeTargetState(dfa, previousD, t) {
    const reach = this.computeReachSet(previousD.configs, t, false);
    if (reach === null) {
      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
      return ATNSimulator.ERROR;
    }
    let D = new DFAState(null, reach);
    const predictedAlt = this.getUniqueAlt(reach);
    if (this.debug) {
      const altSubSets = PredictionMode_default.getConflictingAltSubsets(reach);
      console.log("SLL altSubSets=" + arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
      ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode_default.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
    }
    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
      D.isAcceptState = true;
      D.configs.uniqueAlt = predictedAlt;
      D.prediction = predictedAlt;
    } else if (PredictionMode_default.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
      D.configs.conflictingAlts = this.getConflictingAlts(reach);
      D.requiresFullContext = true;
      D.isAcceptState = true;
      D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
      if (D.predicates !== null) {
        D.prediction = ATN.INVALID_ALT_NUMBER;
      }
    }
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
  }
  predicateDFAState(dfaState, decisionState) {
    const nalts = decisionState.transitions.length;
    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred !== null) {
      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
      dfaState.prediction = ATN.INVALID_ALT_NUMBER;
    } else {
      dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
  }
  // comes back with reach.uniqueAlt set to a valid alt
  execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATNWithFullContext " + s0);
    }
    const fullCtx = true;
    let foundExactAmbig = false;
    let reach;
    let previous = s0;
    input.seek(startIndex);
    let t = input.LA(1);
    let predictedAlt = -1;
    for (; ; ) {
      reach = this.computeReachSet(previous, t, fullCtx);
      if (reach === null) {
        const e = this.noViableAlt(input, outerContext, previous, startIndex);
        input.seek(startIndex);
        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      const altSubSets = PredictionMode_default.getConflictingAltSubsets(reach);
      if (this.debug) {
        console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode_default.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode_default.resolvesToJustOneViableAlt(altSubSets));
      }
      reach.uniqueAlt = this.getUniqueAlt(reach);
      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        predictedAlt = reach.uniqueAlt;
        break;
      } else if (this.predictionMode !== PredictionMode_default.LL_EXACT_AMBIG_DETECTION) {
        predictedAlt = PredictionMode_default.resolvesToJustOneViableAlt(altSubSets);
        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          break;
        }
      } else {
        if (PredictionMode_default.allSubsetsConflict(altSubSets) && PredictionMode_default.allSubsetsEqual(altSubSets)) {
          foundExactAmbig = true;
          predictedAlt = PredictionMode_default.getSingleViableAlt(altSubSets);
          break;
        }
      }
      previous = reach;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
      return predictedAlt;
    }
    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);
    return predictedAlt;
  }
  computeReachSet(closure, t, fullCtx) {
    if (this.debug) {
      console.log("in computeReachSet, starting closure: " + closure);
    }
    if (this.mergeCache === null) {
      this.mergeCache = new DoubleDict();
    }
    const intermediate = new ATNConfigSet(fullCtx);
    let skippedStopStates = null;
    for (let i = 0; i < closure.items.length; i++) {
      const c = closure.items[i];
      if (this.debug) {
        console.log("testing " + this.getTokenName(t) + " at " + c);
      }
      if (c.state instanceof RuleStopState) {
        if (fullCtx || t === Token.EOF) {
          if (skippedStopStates === null) {
            skippedStopStates = [];
          }
          skippedStopStates.push(c);
          if (this.debug_add) {
            console.log("added " + c + " to skippedStopStates");
          }
        }
        continue;
      }
      for (let j = 0; j < c.state.transitions.length; j++) {
        const trans = c.state.transitions[j];
        const target = this.getReachableTarget(trans, t);
        if (target !== null) {
          const cfg = new ATNConfig({ state: target }, c);
          intermediate.add(cfg, this.mergeCache);
          if (this.debug_add) {
            console.log("added " + cfg + " to intermediate");
          }
        }
      }
    }
    let reach = null;
    if (skippedStopStates === null && t !== Token.EOF) {
      if (intermediate.items.length === 1) {
        reach = intermediate;
      } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
        reach = intermediate;
      }
    }
    if (reach === null) {
      reach = new ATNConfigSet(fullCtx);
      const closureBusy = new HashSet();
      const treatEofAsEpsilon = t === Token.EOF;
      for (let k = 0; k < intermediate.items.length; k++) {
        this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
      }
    }
    if (t === Token.EOF) {
      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    if (skippedStopStates !== null && (!fullCtx || !PredictionMode_default.hasConfigInRuleStopState(reach))) {
      for (let l = 0; l < skippedStopStates.length; l++) {
        reach.add(skippedStopStates[l], this.mergeCache);
      }
    }
    if (reach.items.length === 0) {
      return null;
    } else {
      return reach;
    }
  }
  /**
   * Return a configuration set containing only the configurations from
   * {@code configs} which are in a {@link RuleStopState}. If all
   * configurations in {@code configs} are already in a rule stop state, this
   * method simply returns {@code configs}.
   *
   * <p>When {@code lookToEndOfRule} is true, this method uses
   * {@link ATN//nextTokens} for each configuration in {@code configs} which is
   * not already in a rule stop state to see if a rule stop state is reachable
   * from the configuration via epsilon-only transitions.</p>
   *
   * @param configs the configuration set to update
   * @param lookToEndOfRule when true, this method checks for rule stop states
   * reachable by epsilon-only transitions from each configuration in
   * {@code configs}.
   *
   * @return {@code configs} if all configurations in {@code configs} are in a
   * rule stop state, otherwise return a new configuration set containing only
   * the configurations from {@code configs} which are in a rule stop state
   */
  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
    if (PredictionMode_default.allConfigsInRuleStopStates(configs)) {
      return configs;
    }
    const result = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      const config = configs.items[i];
      if (config.state instanceof RuleStopState) {
        result.add(config, this.mergeCache);
        continue;
      }
      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
        const nextTokens = this.atn.nextTokens(config.state);
        if (nextTokens.contains(Token.EPSILON)) {
          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
          result.add(new ATNConfig({ state: endOfRuleState }, config), this.mergeCache);
        }
      }
    }
    return result;
  }
  computeStartState(p, ctx, fullCtx) {
    const initialContext = predictionContextFromRuleContext(this.atn, ctx);
    const configs = new ATNConfigSet(fullCtx);
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const c = new ATNConfig({ state: target, alt: i + 1, context: initialContext }, null);
      const closureBusy = new HashSet();
      this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
  }
  /**
   * This method transforms the start state computed by
   * {@link //computeStartState} to the special start state used by a
   * precedence DFA for a particular precedence value. The transformation
   * process applies the following changes to the start state's configuration
   * set.
   *
   * <ol>
   * <li>Evaluate the precedence predicates for each configuration using
   * {@link SemanticContext//evalPrecedence}.</li>
   * <li>Remove all configurations which predict an alternative greater than
   * 1, for which another configuration that predicts alternative 1 is in the
   * same ATN state with the same prediction context. This transformation is
   * valid for the following reasons:
   * <ul>
   * <li>The closure block cannot contain any epsilon transitions which bypass
   * the body of the closure, so all states reachable via alternative 1 are
   * part of the precedence alternatives of the transformed left-recursive
   * rule.</li>
   * <li>The "primary" portion of a left recursive rule cannot contain an
   * epsilon transition, so the only way an alternative other than 1 can exist
   * in a state that is also reachable via alternative 1 is by nesting calls
   * to the left-recursive rule, with the outer calls not being at the
   * preferred precedence level.</li>
   * </ul>
   * </li>
   * </ol>
   *
   * <p>
   * The prediction context must be considered by this filter to address
   * situations like the following.
   * </p>
   * <code>
   * <pre>
   * grammar TA;
   * prog: statement* EOF;
   * statement: letterA | statement letterA 'b' ;
   * letterA: 'a';
   * </pre>
   * </code>
   * <p>
   * If the above grammar, the ATN state immediately before the token
   * reference {@code 'a'} in {@code letterA} is reachable from the left edge
   * of both the primary and closure blocks of the left-recursive rule
   * {@code statement}. The prediction context associated with each of these
   * configurations distinguishes between them, and prevents the alternative
   * which stepped out to {@code prog} (and then back in to {@code statement}
   * from being eliminated by the filter.
   * </p>
   *
   * @param configs The configuration set computed by
   * {@link //computeStartState} as the start state for the DFA.
   * @return The transformed configuration set representing the start state
   * for a precedence DFA at a particular precedence level (determined by
   * calling {@link Parser//getPrecedence})
   */
  applyPrecedenceFilter(configs) {
    let config;
    const statesFromAlt1 = [];
    const configSet = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i];
      if (config.alt !== 1) {
        continue;
      }
      const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
      if (updatedContext === null) {
        continue;
      }
      statesFromAlt1[config.state.stateNumber] = config.context;
      if (updatedContext !== config.semanticContext) {
        configSet.add(new ATNConfig({ semanticContext: updatedContext }, config), this.mergeCache);
      } else {
        configSet.add(config, this.mergeCache);
      }
    }
    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i];
      if (config.alt === 1) {
        continue;
      }
      if (!config.precedenceFilterSuppressed) {
        const context = statesFromAlt1[config.state.stateNumber] || null;
        if (context !== null && context.equals(config.context)) {
          continue;
        }
      }
      configSet.add(config, this.mergeCache);
    }
    return configSet;
  }
  getReachableTarget(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
      return trans.target;
    } else {
      return null;
    }
  }
  getPredsForAmbigAlts(ambigAlts, configs, nalts) {
    let altToPred = [];
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (ambigAlts.has(c.alt)) {
        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
      }
    }
    let nPredAlts = 0;
    for (let i = 1; i < nalts + 1; i++) {
      const pred = altToPred[i] || null;
      if (pred === null) {
        altToPred[i] = SemanticContext.NONE;
      } else if (pred !== SemanticContext.NONE) {
        nPredAlts += 1;
      }
    }
    if (nPredAlts === 0) {
      altToPred = null;
    }
    if (this.debug) {
      console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
    }
    return altToPred;
  }
  getPredicatePredictions(ambigAlts, altToPred) {
    const pairs = [];
    let containsPredicate = false;
    for (let i = 1; i < altToPred.length; i++) {
      const pred = altToPred[i];
      if (ambigAlts !== null && ambigAlts.has(i)) {
        pairs.push(new PredPrediction(pred, i));
      }
      if (pred !== SemanticContext.NONE) {
        containsPredicate = true;
      }
    }
    if (!containsPredicate) {
      return null;
    }
    return pairs;
  }
  /**
   * This method is used to improve the localization of error messages by
   * choosing an alternative rather than throwing a
   * {@link NoViableAltException} in particular prediction scenarios where the
   * {@link //ERROR} state was reached during ATN simulation.
   *
   * <p>
   * The default implementation of this method uses the following
   * algorithm to identify an ATN configuration which successfully parsed the
   * decision entry rule. Choosing such an alternative ensures that the
   * {@link ParserRuleContext} returned by the calling rule will be complete
   * and valid, and the syntax error will be reported later at a more
   * localized location.</p>
   *
   * <ul>
   * <li>If a syntactically valid path or paths reach the end of the decision rule and
   * they are semantically valid if predicated, return the min associated alt.</li>
   * <li>Else, if a semantically invalid but syntactically valid path exist
   * or paths exist, return the minimum associated alt.
   * </li>
   * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
   * </ul>
   *
   * <p>
   * In some scenarios, the algorithm described above could predict an
   * alternative which will result in a {@link FailedPredicateException} in
   * the parser. Specifically, this could occur if the <em>only</em> configuration
   * capable of successfully parsing to the end of the decision rule is
   * blocked by a semantic predicate. By choosing this alternative within
   * {@link //adaptivePredict} instead of throwing a
   * {@link NoViableAltException}, the resulting
   * {@link FailedPredicateException} in the parser will identify the specific
   * predicate which is preventing the parser from successfully parsing the
   * decision rule, which helps developers identify and correct logic errors
   * in semantic predicates.
   * </p>
   *
   * @param configs The ATN configurations which were valid immediately before
   * the {@link //ERROR} state was reached
   * @param outerContext The is the \gamma_0 initial parser context from the paper
   * or the parser stack at the instant before prediction commences.
   *
   * @return The value to return from {@link //adaptivePredict}, or
   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
   * identified and {@link //adaptivePredict} should report an error instead
   */
  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
    const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    const semValidConfigs = cfgs[0];
    const semInvalidConfigs = cfgs[1];
    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt !== ATN.INVALID_ALT_NUMBER) {
      return alt;
    }
    if (semInvalidConfigs.items.length > 0) {
      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
      if (alt !== ATN.INVALID_ALT_NUMBER) {
        return alt;
      }
    }
    return ATN.INVALID_ALT_NUMBER;
  }
  getAltThatFinishedDecisionEntryRule(configs) {
    const alts = [];
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
        if (alts.indexOf(c.alt) < 0) {
          alts.push(c.alt);
        }
      }
    }
    if (alts.length === 0) {
      return ATN.INVALID_ALT_NUMBER;
    } else {
      return Math.min.apply(null, alts);
    }
  }
  /**
   * Walk the list of configurations and split them according to
   * those that have preds evaluating to true/false.  If no pred, assume
   * true pred and include in succeeded set.  Returns Pair of sets.
   *
   * Create a new set so as not to alter the incoming parameter.
   *
   * Assumption: the input stream has been restored to the starting point
   * prediction, which is where predicates need to evaluate.*/
  splitAccordingToSemanticValidity(configs, outerContext) {
    const succeeded = new ATNConfigSet(configs.fullCtx);
    const failed = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.semanticContext !== SemanticContext.NONE) {
        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
        if (predicateEvaluationResult) {
          succeeded.add(c);
        } else {
          failed.add(c);
        }
      } else {
        succeeded.add(c);
      }
    }
    return [succeeded, failed];
  }
  /**
   * Look through a list of predicate/alt pairs, returning alts for the
   * pairs that win. A {@code NONE} predicate indicates an alt containing an
   * unpredicated config which behaves as "always true." If !complete
   * then we stop at the first predicate that evaluates to true. This
   * includes pairs with null predicates.
   */
  evalSemanticContext(predPredictions, outerContext, complete) {
    const predictions = new BitSet();
    for (let i = 0; i < predPredictions.length; i++) {
      const pair = predPredictions[i];
      if (pair.pred === SemanticContext.NONE) {
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
        continue;
      }
      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
      if (this.debug || this.dfa_debug) {
        console.log("eval pred " + pair + "=" + predicateEvaluationResult);
      }
      if (predicateEvaluationResult) {
        if (this.debug || this.dfa_debug) {
          console.log("PREDICT " + pair.alt);
        }
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
      }
    }
    return predictions;
  }
  // TODO: If we are doing predicates, there is no point in pursuing
  //     closure operations if we reach a DFA state that uniquely predicts
  //     alternative. We will not be caching that DFA state and it is a
  //     waste to pursue the closure. Might have to advance when we do
  //     ambig detection thought :(
  //
  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    const initialDepth = 0;
    this.closureCheckingStopState(
      config,
      configs,
      closureBusy,
      collectPredicates,
      fullCtx,
      initialDepth,
      treatEofAsEpsilon
    );
  }
  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
      console.log("closure(" + config.toString(this.parser, true) + ")");
      if (config.reachesIntoOuterContext > 50) {
        throw "problem";
      }
    }
    if (config.state instanceof RuleStopState) {
      if (!config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
            if (fullCtx) {
              configs.add(new ATNConfig({ state: config.state, context: PredictionContext.EMPTY }, config), this.mergeCache);
              continue;
            } else {
              if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
              }
              this.closure_(
                config,
                configs,
                closureBusy,
                collectPredicates,
                fullCtx,
                depth,
                treatEofAsEpsilon
              );
            }
            continue;
          }
          const returnState = this.atn.states[config.context.getReturnState(i)];
          const newContext = config.context.getParent(i);
          const parms = { state: returnState, alt: config.alt, context: newContext, semanticContext: config.semanticContext };
          const c = new ATNConfig(parms, null);
          c.reachesIntoOuterContext = config.reachesIntoOuterContext;
          this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
        }
        return;
      } else if (fullCtx) {
        configs.add(config, this.mergeCache);
        return;
      } else {
        if (this.debug) {
          console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
        }
      }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
  }
  // Do the actual work of walking epsilon edges//
  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    const p = config.state;
    if (!p.epsilonOnlyTransitions) {
      configs.add(config, this.mergeCache);
    }
    for (let i = 0; i < p.transitions.length; i++) {
      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
        continue;
      const t = p.transitions[i];
      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
      if (c !== null) {
        let newDepth = depth;
        if (config.state instanceof RuleStopState) {
          if (this._dfa !== null && this._dfa.precedenceDfa) {
            if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
              c.precedenceFilterSuppressed = true;
            }
          }
          c.reachesIntoOuterContext += 1;
          if (closureBusy.add(c) !== c) {
            continue;
          }
          configs.dipsIntoOuterContext = true;
          newDepth -= 1;
          if (this.debug) {
            console.log("dips into outer ctx: " + c);
          }
        } else {
          if (!t.isEpsilon && closureBusy.add(c) !== c) {
            continue;
          }
          if (t instanceof RuleTransition) {
            if (newDepth >= 0) {
              newDepth += 1;
            }
          }
        }
        this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
      }
    }
  }
  canDropLoopEntryEdgeInLeftRecursiveRule(config) {
    const p = config.state;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY)
      return false;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath())
      return false;
    const numCtxs = config.context.length;
    for (let i = 0; i < numCtxs; i++) {
      const returnState = this.atn.states[config.context.getReturnState(i)];
      if (returnState.ruleIndex !== p.ruleIndex)
        return false;
    }
    const decisionStartState = p.transitions[0].target;
    const blockEndStateNum = decisionStartState.endState.stateNumber;
    const blockEndState = this.atn.states[blockEndStateNum];
    for (let i = 0; i < numCtxs; i++) {
      const returnStateNumber = config.context.getReturnState(i);
      const returnState = this.atn.states[returnStateNumber];
      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)
        return false;
      const returnStateTarget = returnState.transitions[0].target;
      if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p)
        continue;
      if (returnState === blockEndState)
        continue;
      if (returnStateTarget === blockEndState)
        continue;
      if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)
        continue;
      return false;
    }
    return true;
  }
  getRuleName(index) {
    if (this.parser !== null && index >= 0) {
      return this.parser.ruleNames[index];
    } else {
      return "<rule " + index + ">";
    }
  }
  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch (t.serializationType) {
      case Transition.RULE:
        return this.ruleTransition(config, t);
      case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
      case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
      case Transition.ACTION:
        return this.actionTransition(config, t);
      case Transition.EPSILON:
        return new ATNConfig({ state: t.target }, config);
      case Transition.ATOM:
      case Transition.RANGE:
      case Transition.SET:
        if (treatEofAsEpsilon) {
          if (t.matches(Token.EOF, 0, 1)) {
            return new ATNConfig({ state: t.target }, config);
          }
        }
        return null;
      default:
        return null;
    }
  }
  actionTransition(config, t) {
    if (this.debug) {
      const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
      console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }
    return new ATNConfig({ state: t.target }, config);
  }
  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && inContext) {
      if (fullCtx) {
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c = new ATNConfig({ state: pt.target }, config);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({ state: pt.target, semanticContext: newSemCtx }, config);
      }
    } else {
      c = new ATNConfig({ state: pt.target }, config);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  predTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
      if (fullCtx) {
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c = new ATNConfig({ state: pt.target }, config);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({ state: pt.target, semanticContext: newSemCtx }, config);
      }
    } else {
      c = new ATNConfig({ state: pt.target }, config);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  ruleTransition(config, t) {
    if (this.debug) {
      console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    const returnState = t.followState;
    const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({ state: t.target, context: newContext }, config);
  }
  getConflictingAlts(configs) {
    const altsets = PredictionMode_default.getConflictingAltSubsets(configs);
    return PredictionMode_default.getAlts(altsets);
  }
  /**
   * Sam pointed out a problem with the previous definition, v3, of
   * ambiguous states. If we have another state associated with conflicting
   * alternatives, we should keep going. For example, the following grammar
   *
   * s : (ID | ID ID?) ';' ;
   *
   * When the ATN simulation reaches the state before ';', it has a DFA
   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
   * because alternative to has another way to continue, via [6|2|[]].
   * The key is that we have a single state that has config's only associated
   * with a single alternative, 2, and crucially the state transitions
   * among the configurations are all non-epsilon transitions. That means
   * we don't consider any conflicts that include alternative 2. So, we
   * ignore the conflict between alts 1 and 2. We ignore a set of
   * conflicting alts when there is an intersection with an alternative
   * associated with a single alt state in the state&rarr;config-list map.
   *
   * It's also the case that we might have two conflicting configurations but
   * also a 3rd nonconflicting configuration for a different alternative:
   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
   *
   * a : A | A | A B ;
   *
   * After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not
   * stop working on this state. In the previous example, we're concerned
   * with states associated with the conflicting alternatives. Here alt
   * 3 is not associated with the conflicting configs, but since we can continue
   * looking for input reasonably, I don't declare the state done. We
   * ignore a set of conflicting alts when we have an alternative
   * that we still need to pursue
   */
  getConflictingAltsOrUniqueAlt(configs) {
    let conflictingAlts = null;
    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = new BitSet();
      conflictingAlts.add(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
  }
  getTokenName(t) {
    if (t === Token.EOF) {
      return "EOF";
    }
    if (this.parser !== null && this.parser.literalNames !== null) {
      if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
        console.log("" + t + " ttype out of range: " + this.parser.literalNames);
        console.log("" + this.parser.getInputStream().getTokens());
      } else {
        const name2 = this.parser.literalNames[t] || this.parser.symbolicNames[t];
        return name2 + "<" + t + ">";
      }
    }
    return "" + t;
  }
  getLookaheadName(input) {
    return this.getTokenName(input.LA(1));
  }
  /**
   * Used for debugging in adaptivePredict around execATN but I cut
   * it out for clarity now that alg. works well. We can leave this
   * "dead" code for a bit
   */
  dumpDeadEndConfigs(nvae) {
    console.log("dead end configs: ");
    const decs = nvae.getDeadEndConfigs();
    for (let i = 0; i < decs.length; i++) {
      const c = decs[i];
      let trans = "no edges";
      if (c.state.transitions.length > 0) {
        const t = c.state.transitions[0];
        if (t instanceof AtomTransition) {
          trans = "Atom " + this.getTokenName(t.label);
        } else if (t instanceof SetTransition) {
          const neg = t instanceof NotSetTransition;
          trans = (neg ? "~" : "") + "Set " + t.set;
        }
      }
      console.error(c.toString(this.parser, true) + ":" + trans);
    }
  }
  noViableAlt(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
  }
  getUniqueAlt(configs) {
    let alt = ATN.INVALID_ALT_NUMBER;
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (alt === ATN.INVALID_ALT_NUMBER) {
        alt = c.alt;
      } else if (c.alt !== alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return alt;
  }
  /**
   * Add an edge to the DFA, if possible. This method calls
   * {@link //addDFAState} to ensure the {@code to} state is present in the
   * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
   * range of edges that can be represented in the DFA tables, this method
   * returns without adding the edge to the DFA.
   *
   * <p>If {@code to} is {@code null}, this method returns {@code null}.
   * Otherwise, this method returns the {@link DFAState} returned by calling
   * {@link //addDFAState} for the {@code to} state.</p>
   *
   * @param dfa The DFA
   * @param from_ The source state for the edge
   * @param t The input symbol
   * @param to The target state for the edge
   *
   * @return If {@code to} is {@code null}, this method returns {@code null};
   * otherwise this method returns the result of calling {@link //addDFAState}
   * on {@code to}
   */
  addDFAEdge(dfa, from_, t, to) {
    if (this.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to === null) {
      return null;
    }
    to = this.addDFAState(dfa, to);
    if (from_ === null || t < -1 || t > this.atn.maxTokenType) {
      return to;
    }
    if (from_.edges === null) {
      from_.edges = [];
    }
    from_.edges[t + 1] = to;
    if (this.debug) {
      const literalNames = this.parser === null ? null : this.parser.literalNames;
      const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
      console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
  }
  /**
   * Add state {@code D} to the DFA if it is not already present, and return
   * the actual instance stored in the DFA. If a state equivalent to {@code D}
   * is already in the DFA, the existing state is returned. Otherwise this
   * method returns {@code D} after adding it to the DFA.
   *
   * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
   * does not change the DFA.</p>
   *
   * @param dfa The dfa
   * @param D The DFA state to add
   * @return The state stored in the DFA. This will be either the existing
   * state if {@code D} is already in the DFA, or {@code D} itself if the
   * state was not already present
   */
  addDFAState(dfa, D) {
    if (D === ATNSimulator.ERROR) {
      return D;
    }
    const existing = dfa.states.get(D);
    if (existing !== null) {
      return existing;
    }
    D.stateNumber = dfa.states.length;
    if (!D.configs.readOnly) {
      D.configs.optimizeConfigs(this);
      D.configs.setReadonly(true);
    }
    dfa.states.add(D);
    if (this.debug) {
      console.log("adding new DFA state: " + D);
    }
    return D;
  }
  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
  }
  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
  }
  // If context sensitive parsing, we know it's ambiguity not conflict//
  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
  }
};

// node_modules/antlr4/src/antlr4/atn/index.js
var atn_default = { ATN, ATNDeserializer, LexerATNSimulator, ParserATNSimulator, PredictionMode: PredictionMode_default };

// node_modules/antlr4/src/antlr4/dfa/DFASerializer.js
var DFASerializer = class {
  constructor(dfa, literalNames, symbolicNames) {
    this.dfa = dfa;
    this.literalNames = literalNames || [];
    this.symbolicNames = symbolicNames || [];
  }
  toString() {
    if (this.dfa.s0 === null) {
      return null;
    }
    let buf = "";
    const states = this.dfa.sortedStates();
    for (let i = 0; i < states.length; i++) {
      const s = states[i];
      if (s.edges !== null) {
        const n = s.edges.length;
        for (let j = 0; j < n; j++) {
          const t = s.edges[j] || null;
          if (t !== null && t.stateNumber !== 2147483647) {
            buf = buf.concat(this.getStateString(s));
            buf = buf.concat("-");
            buf = buf.concat(this.getEdgeLabel(j));
            buf = buf.concat("->");
            buf = buf.concat(this.getStateString(t));
            buf = buf.concat("\n");
          }
        }
      }
    }
    return buf.length === 0 ? null : buf;
  }
  getEdgeLabel(i) {
    if (i === 0) {
      return "EOF";
    } else if (this.literalNames !== null || this.symbolicNames !== null) {
      return this.literalNames[i - 1] || this.symbolicNames[i - 1];
    } else {
      return String.fromCharCode(i - 1);
    }
  }
  getStateString(s) {
    const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + s.stateNumber + (s.requiresFullContext ? "^" : "");
    if (s.isAcceptState) {
      if (s.predicates !== null) {
        return baseStateStr + "=>" + arrayToString(s.predicates);
      } else {
        return baseStateStr + "=>" + s.prediction.toString();
      }
    } else {
      return baseStateStr;
    }
  }
};

// node_modules/antlr4/src/antlr4/dfa/LexerDFASerializer.js
var LexerDFASerializer = class extends DFASerializer {
  constructor(dfa) {
    super(dfa, null);
  }
  getEdgeLabel(i) {
    return "'" + String.fromCharCode(i) + "'";
  }
};

// node_modules/antlr4/src/antlr4/dfa/DFA.js
var DFA = class {
  constructor(atnStartState, decision) {
    if (decision === void 0) {
      decision = 0;
    }
    this.atnStartState = atnStartState;
    this.decision = decision;
    this._states = new HashSet();
    this.s0 = null;
    this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState) {
      if (atnStartState.isPrecedenceDecision) {
        this.precedenceDfa = true;
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      }
    }
  }
  /**
   * Get the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @return The start state corresponding to the specified precedence, or
   * {@code null} if no start state exists for the specified precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  getPrecedenceStartState(precedence) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    if (precedence < 0 || precedence >= this.s0.edges.length) {
      return null;
    }
    return this.s0.edges[precedence] || null;
  }
  /**
   * Set the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @param startState The start state corresponding to the specified
   * precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  setPrecedenceStartState(precedence, startState) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    if (precedence < 0) {
      return;
    }
    this.s0.edges[precedence] = startState;
  }
  /**
   * Sets whether this is a precedence DFA. If the specified value differs
   * from the current DFA configuration, the following actions are taken;
   * otherwise no changes are made to the current DFA.
   *
   * <ul>
   * <li>The {@link //states} map is cleared</li>
   * <li>If {@code precedenceDfa} is {@code false}, the initial state
   * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
   * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
   * store the start states for individual precedence values.</li>
   * <li>The {@link //precedenceDfa} field is updated</li>
   * </ul>
   *
   * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
   * {@code false}
   */
  setPrecedenceDfa(precedenceDfa) {
    if (this.precedenceDfa !== precedenceDfa) {
      this._states = new HashSet();
      if (precedenceDfa) {
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      } else {
        this.s0 = null;
      }
      this.precedenceDfa = precedenceDfa;
    }
  }
  /**
   * Return a list of all states in this DFA, ordered by state number.
   */
  sortedStates() {
    const list = this._states.values();
    return list.sort(function(a, b) {
      return a.stateNumber - b.stateNumber;
    });
  }
  toString(literalNames, symbolicNames) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    if (this.s0 === null) {
      return "";
    }
    const serializer = new DFASerializer(this, literalNames, symbolicNames);
    return serializer.toString();
  }
  toLexerString() {
    if (this.s0 === null) {
      return "";
    }
    const serializer = new LexerDFASerializer(this);
    return serializer.toString();
  }
  get states() {
    return this._states;
  }
};

// node_modules/antlr4/src/antlr4/dfa/index.js
var dfa_default = { DFA, DFASerializer, LexerDFASerializer, PredPrediction };

// node_modules/antlr4/src/antlr4/tree/ParseTreeListener.js
var ParseTreeListener = class {
  visitTerminal(node) {
  }
  visitErrorNode(node) {
  }
  enterEveryRule(node) {
  }
  exitEveryRule(node) {
  }
};

// node_modules/antlr4/src/antlr4/tree/ParseTreeVisitor.js
var ParseTreeVisitor = class {
  visit(ctx) {
    if (Array.isArray(ctx)) {
      return ctx.map(function(child) {
        return child.accept(this);
      }, this);
    } else {
      return ctx.accept(this);
    }
  }
  visitChildren(ctx) {
    if (ctx.children) {
      return this.visit(ctx.children);
    } else {
      return null;
    }
  }
  visitTerminal(node) {
  }
  visitErrorNode(node) {
  }
};

// node_modules/antlr4/src/antlr4/tree/ParseTreeWalker.js
var ParseTreeWalker = class {
  /**
   * Performs a walk on the given parse tree starting at the root and going down recursively
   * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
   * recursively walking down into child nodes, then
   * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
   * @param listener The listener used by the walker to process grammar rules
   * @param t The parse tree to be walked on
   */
  walk(listener, t) {
    const errorNode = t instanceof ErrorNode || t.isErrorNode !== void 0 && t.isErrorNode();
    if (errorNode) {
      listener.visitErrorNode(t);
    } else if (t instanceof TerminalNode) {
      listener.visitTerminal(t);
    } else {
      this.enterRule(listener, t);
      for (let i = 0; i < t.getChildCount(); i++) {
        const child = t.getChild(i);
        this.walk(listener, child);
      }
      this.exitRule(listener, t);
    }
  }
  /**
   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
   * then by triggering the event specific to the given parse tree node
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  enterRule(listener, r) {
    const ctx = r.getRuleContext();
    listener.enterEveryRule(ctx);
    ctx.enterRule(listener);
  }
  /**
   * Exits a grammar rule by first triggering the event specific to the given parse tree node
   * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  exitRule(listener, r) {
    const ctx = r.getRuleContext();
    ctx.exitRule(listener);
    listener.exitEveryRule(ctx);
  }
};
ParseTreeWalker.DEFAULT = new ParseTreeWalker();

// node_modules/antlr4/src/antlr4/tree/index.js
var tree_default = { Trees: Trees_default, RuleNode, ErrorNode, TerminalNode, ParseTreeListener, ParseTreeVisitor, ParseTreeWalker };

// node_modules/antlr4/src/antlr4/error/InputMismatchException.js
var InputMismatchException = class extends RecognitionException {
  constructor(recognizer) {
    super({ message: "", recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx });
    this.offendingToken = recognizer.getCurrentToken();
  }
};

// node_modules/antlr4/src/antlr4/error/FailedPredicateException.js
var FailedPredicateException = class extends RecognitionException {
  constructor(recognizer, predicate, message) {
    super({
      message: formatMessage(predicate, message || null),
      recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    const s = recognizer._interp.atn.states[recognizer.state];
    const trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
      this.ruleIndex = trans.ruleIndex;
      this.predicateIndex = trans.predIndex;
    } else {
      this.ruleIndex = 0;
      this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
  }
};
function formatMessage(predicate, message) {
  if (message !== null) {
    return message;
  } else {
    return "failed predicate: {" + predicate + "}?";
  }
}

// node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js
var DiagnosticErrorListener = class extends ErrorListener {
  constructor(exactOnly) {
    super();
    exactOnly = exactOnly || true;
    this.exactOnly = exactOnly;
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.exactOnly && !exact) {
      return;
    }
    const msg = "reportAmbiguity d=" + this.getDecisionDescription(recognizer, dfa) + ": ambigAlts=" + this.getConflictingAlts(ambigAlts, configs) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    const msg = "reportAttemptingFullContext d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    const msg = "reportContextSensitivity d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  getDecisionDescription(recognizer, dfa) {
    const decision = dfa.decision;
    const ruleIndex = dfa.atnStartState.ruleIndex;
    const ruleNames = recognizer.ruleNames;
    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
      return "" + decision;
    }
    const ruleName = ruleNames[ruleIndex] || null;
    if (ruleName === null || ruleName.length === 0) {
      return "" + decision;
    }
    return `${decision} (${ruleName})`;
  }
  /**
   * Computes the set of conflicting or ambiguous alternatives from a
   * configuration set, if that information was not already provided by the
   * parser.
   *
   * @param reportedAlts The set of conflicting or ambiguous alternatives, as
   * reported by the parser.
   * @param configs The conflicting or ambiguous configuration set.
   * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
   * returns the set of alternatives represented in {@code configs}.
      */
  getConflictingAlts(reportedAlts, configs) {
    if (reportedAlts !== null) {
      return reportedAlts;
    }
    const result = new BitSet();
    for (let i = 0; i < configs.items.length; i++) {
      result.add(configs.items[i].alt);
    }
    return `{${result.values().join(", ")}}`;
  }
};

// node_modules/antlr4/src/antlr4/error/ParseCancellationException.js
var ParseCancellationException = class extends Error {
  constructor() {
    super();
    Error.captureStackTrace(this, ParseCancellationException);
  }
};

// node_modules/antlr4/src/antlr4/error/ErrorStrategy.js
var ErrorStrategy = class {
  reset(recognizer) {
  }
  recoverInline(recognizer) {
  }
  recover(recognizer, e) {
  }
  sync(recognizer) {
  }
  inErrorRecoveryMode(recognizer) {
  }
  reportError(recognizer) {
  }
};

// node_modules/antlr4/src/antlr4/error/DefaultErrorStrategy.js
var DefaultErrorStrategy = class extends ErrorStrategy {
  constructor() {
    super();
    this.errorRecoveryMode = false;
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    this.nextTokensContext = null;
    this.nextTokenState = 0;
  }
  /**
   * <p>The default implementation simply calls {@link //endErrorCondition} to
   * ensure that the handler is not in error recovery mode.</p>
   */
  reset(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * This method is called to enter error recovery mode when a recognition
   * exception is reported.
   *
   * @param recognizer the parser instance
   */
  beginErrorCondition(recognizer) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(recognizer) {
    return this.errorRecoveryMode;
  }
  /**
   * This method is called to leave error recovery mode after recovering from
   * a recognition exception.
   * @param recognizer
   */
  endErrorCondition(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
  }
  /**
   * {@inheritDoc}
   * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
   */
  reportMatch(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * {@inheritDoc}
   *
   * <p>The default implementation returns immediately if the handler is already
   * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
   * and dispatches the reporting task based on the runtime type of {@code e}
   * according to the following table.</p>
   *
   * <ul>
   * <li>{@link NoViableAltException}: Dispatches the call to
   * {@link //reportNoViableAlternative}</li>
   * <li>{@link InputMismatchException}: Dispatches the call to
   * {@link //reportInputMismatch}</li>
   * <li>{@link FailedPredicateException}: Dispatches the call to
   * {@link //reportFailedPredicate}</li>
   * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
   * the exception</li>
   * </ul>
   */
  reportError(recognizer, e) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    if (e instanceof NoViableAltException) {
      this.reportNoViableAlternative(recognizer, e);
    } else if (e instanceof InputMismatchException) {
      this.reportInputMismatch(recognizer, e);
    } else if (e instanceof FailedPredicateException) {
      this.reportFailedPredicate(recognizer, e);
    } else {
      console.log("unknown recognition error type: " + e.constructor.name);
      console.log(e.stack);
      recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
  }
  /**
   *
   * {@inheritDoc}
   *
   * <p>The default implementation resynchronizes the parser by consuming tokens
   * until we find one in the resynchronization set--loosely the set of tokens
   * that can follow the current rule.</p>
   *
   */
  recover(recognizer, e) {
    if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
      recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
      this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    const followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
  }
  /**
   * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
   * that the current lookahead symbol is consistent with what were expecting
   * at this point in the ATN. You can call this anytime but ANTLR only
   * generates code to check before subrules/loops and each iteration.
   *
   * <p>Implements Jim Idle's magic sync mechanism in closures and optional
   * subrules. E.g.,</p>
   *
   * <pre>
   * a : sync ( stuff sync )* ;
   * sync : {consume to what can follow sync} ;
   * </pre>
   *
   * At the start of a sub rule upon error, {@link //sync} performs single
   * token deletion, if possible. If it can't do that, it bails on the current
   * rule and uses the default error recovery, which consumes until the
   * resynchronization set of the current rule.
   *
   * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
   * with an empty alternative), then the expected set includes what follows
   * the subrule.</p>
   *
   * <p>During loop iteration, it consumes until it sees a token that can start a
   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
   * stay in the loop as long as possible.</p>
   *
   * <p><strong>ORIGINS</strong></p>
   *
   * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
   * A single mismatch token or missing token would force the parser to bail
   * out of the entire rules surrounding the loop. So, for rule</p>
   *
   * <pre>
   * classDef : 'class' ID '{' member* '}'
   * </pre>
   *
   * input with an extra token between members would force the parser to
   * consume until it found the next class definition rather than the next
   * member definition of the current class.
   *
   * <p>This functionality cost a little bit of effort because the parser has to
   * compare token set at the start of the loop and at each iteration. If for
   * some reason speed is suffering for you, you can turn off this
   * functionality by simply overriding this method as a blank { }.</p>
   *
   */
  sync(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    const s = recognizer._interp.atn.states[recognizer.state];
    const la = recognizer.getTokenStream().LA(1);
    const nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(la)) {
      this.nextTokensContext = null;
      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
      return;
    } else if (nextTokens.contains(Token.EPSILON)) {
      if (this.nextTokensContext === null) {
        this.nextTokensContext = recognizer._ctx;
        this.nextTokensState = recognizer._stateNumber;
      }
      return;
    }
    switch (s.stateType) {
      case ATNState.BLOCK_START:
      case ATNState.STAR_BLOCK_START:
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_LOOP_ENTRY:
        if (this.singleTokenDeletion(recognizer) !== null) {
          return;
        } else {
          throw new InputMismatchException(recognizer);
        }
      case ATNState.PLUS_LOOP_BACK:
      case ATNState.STAR_LOOP_BACK:
        {
          this.reportUnwantedToken(recognizer);
          const expecting = new IntervalSet();
          expecting.addSet(recognizer.getExpectedTokens());
          const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        }
        break;
      default:
    }
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link NoViableAltException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportNoViableAlternative(recognizer, e) {
    const tokens = recognizer.getTokenStream();
    let input;
    if (tokens !== null) {
      if (e.startToken.type === Token.EOF) {
        input = "<EOF>";
      } else {
        input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
      }
    } else {
      input = "<unknown input>";
    }
    const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link //reportError} when the exception is an
   * {@link InputMismatchException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportInputMismatch(recognizer, e) {
    const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link FailedPredicateException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportFailedPredicate(recognizer, e) {
    const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    const msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This method is called to report a syntax error which requires the removal
   * of a token from the input stream. At the time this method is called, the
   * erroneous symbol is current {@code LT(1)} symbol and has not yet been
   * removed from the input stream. When this method returns,
   * {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenDeletion} identifies
   * single-token deletion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   *
   */
  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const tokenName = this.getTokenErrorDisplay(t);
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "extraneous input " + tokenName + " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * This method is called to report a syntax error which requires the
   * insertion of a missing token into the input stream. At the time this
   * method is called, the missing token has not yet been inserted. When this
   * method returns, {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenInsertion} identifies
   * single-token insertion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   */
  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * <p>The default implementation attempts to recover from the mismatched input
   * by using single token insertion and deletion as described below. If the
   * recovery attempt fails, this method throws an
   * {@link InputMismatchException}.</p>
   *
   * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
   *
   * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
   * right token, however, then assume {@code LA(1)} is some extra spurious
   * token and delete it. Then consume and return the next token (which was
   * the {@code LA(2)} token) as the successful result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
      * //singleTokenDeletion}.</p>
   *
   * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
   *
   * <p>If current token (at {@code LA(1)}) is consistent with what could come
   * after the expected {@code LA(1)} token, then assume the token is missing
   * and use the parser's {@link TokenFactory} to create it on the fly. The
   * "insertion" is performed by returning the created token as the successful
   * result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
      * //singleTokenInsertion}.</p>
   *
   * <p><strong>EXAMPLE</strong></p>
   *
   * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
   * the parser returns from the nested call to {@code expr}, it will have
   * call chain:</p>
   *
   * <pre>
   * stat &rarr; expr &rarr; atom
   * </pre>
   *
   * and it will be trying to match the {@code ')'} at this point in the
   * derivation:
   *
   * <pre>
   * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
   * ^
   * </pre>
   *
   * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
   * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
   * is in the set of tokens that can follow the {@code ')'} token reference
   * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
   */
  recoverInline(recognizer) {
    const matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
      recognizer.consume();
      return matchedSymbol;
    }
    if (this.singleTokenInsertion(recognizer)) {
      return this.getMissingSymbol(recognizer);
    }
    throw new InputMismatchException(recognizer);
  }
  /**
   * This method implements the single-token insertion inline error recovery
   * strategy. It is called by {@link //recoverInline} if the single-token
   * deletion strategy fails to recover from the mismatched input. If this
   * method returns {@code true}, {@code recognizer} will be in error recovery
   * mode.
   *
   * <p>This method determines whether or not single-token insertion is viable by
   * checking if the {@code LA(1)} input symbol could be successfully matched
   * if it were instead the {@code LA(2)} symbol. If this method returns
   * {@code true}, the caller is responsible for creating and inserting a
   * token with the correct type to produce this behavior.</p>
   *
   * @param recognizer the parser instance
   * @return {@code true} if single-token insertion is a viable recovery
   * strategy for the current mismatched input, otherwise {@code false}
   */
  singleTokenInsertion(recognizer) {
    const currentSymbolType = recognizer.getTokenStream().LA(1);
    const atn3 = recognizer._interp.atn;
    const currentState = atn3.states[recognizer.state];
    const next = currentState.transitions[0].target;
    const expectingAtLL2 = atn3.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType)) {
      this.reportMissingToken(recognizer);
      return true;
    } else {
      return false;
    }
  }
  /**
   * This method implements the single-token deletion inline error recovery
   * strategy. It is called by {@link //recoverInline} to attempt to recover
   * from mismatched input. If this method returns null, the parser and error
   * handler state will not have changed. If this method returns non-null,
   * {@code recognizer} will <em>not</em> be in error recovery mode since the
   * returned token was a successful match.
   *
   * <p>If the single-token deletion is successful, this method calls
   * {@link //reportUnwantedToken} to report the error, followed by
   * {@link Parser//consume} to actually "delete" the extraneous token. Then,
   * before returning {@link //reportMatch} is called to signal a successful
   * match.</p>
   *
   * @param recognizer the parser instance
   * @return the successfully matched {@link Token} instance if single-token
   * deletion successfully recovers from the mismatched input, otherwise
   * {@code null}
   */
  singleTokenDeletion(recognizer) {
    const nextTokenType = recognizer.getTokenStream().LA(2);
    const expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
      this.reportUnwantedToken(recognizer);
      recognizer.consume();
      const matchedSymbol = recognizer.getCurrentToken();
      this.reportMatch(recognizer);
      return matchedSymbol;
    } else {
      return null;
    }
  }
  /**
   * Conjure up a missing token during error recovery.
   *
   * The recognizer attempts to recover from single missing
   * symbols. But, actions might refer to that missing symbol.
   * For example, x=ID {f($x);}. The action clearly assumes
   * that there has been an identifier matched previously and that
   * $x points at that token. If that token is missing, but
   * the next token in the stream is what we want we assume that
   * this token is missing and we keep going. Because we
   * have to return some token to replace the missing token,
   * we have to conjure one up. This method gives the user control
   * over the tokens returned for missing tokens. Mostly,
   * you will want to create something special for identifier
   * tokens. For literals such as '{' and ',', the default
   * action in the parser or tree parser works. It simply creates
   * a CommonToken of the appropriate type. The text will be the token.
   * If you change what tokens must be created by the lexer,
   * override this method to create the appropriate tokens.
   *
   */
  getMissingSymbol(recognizer) {
    const currentSymbol = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const expectedTokenType = expecting.first();
    let tokenText;
    if (expectedTokenType === Token.EOF) {
      tokenText = "<missing EOF>";
    } else {
      tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    let current = currentSymbol;
    const lookback = recognizer.getTokenStream().LT(-1);
    if (current.type === Token.EOF && lookback !== null) {
      current = lookback;
    }
    return recognizer.getTokenFactory().create(
      current.source,
      expectedTokenType,
      tokenText,
      Token.DEFAULT_CHANNEL,
      -1,
      -1,
      current.line,
      current.column
    );
  }
  getExpectedTokens(recognizer) {
    return recognizer.getExpectedTokens();
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out. Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   */
  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }
    let s = t.text;
    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }
    return this.escapeWSAndQuote(s);
  }
  escapeWSAndQuote(s) {
    s = s.replace(/\n/g, "\\n");
    s = s.replace(/\r/g, "\\r");
    s = s.replace(/\t/g, "\\t");
    return "'" + s + "'";
  }
  /**
   * Compute the error recovery set for the current rule. During
   * rule invocation, the parser pushes the set of tokens that can
   * follow that rule reference on the stack; this amounts to
   * computing FIRST of what follows the rule reference in the
   * enclosing rule. See LinearApproximator.FIRST().
   * This local follow set only includes tokens
   * from within the rule; i.e., the FIRST computation done by
   * ANTLR stops at the end of a rule.
   *
   * EXAMPLE
   *
   * When you find a "no viable alt exception", the input is not
   * consistent with any of the alternatives for rule r. The best
   * thing to do is to consume tokens until you see something that
   * can legally follow a call to r//or* any rule that called r.
   * You don't want the exact set of viable next tokens because the
   * input might just be missing a token--you might consume the
   * rest of the input looking for one of the missing tokens.
   *
   * Consider grammar:
   *
   * a : '[' b ']'
   * | '(' b ')'
   * ;
   * b : c '^' INT ;
   * c : ID
   * | INT
   * ;
   *
   * At each rule invocation, the set of tokens that could follow
   * that rule is pushed on a stack. Here are the various
   * context-sensitive follow sets:
   *
   * FOLLOW(b1_in_a) = FIRST(']') = ']'
   * FOLLOW(b2_in_a) = FIRST(')') = ')'
   * FOLLOW(c_in_b) = FIRST('^') = '^'
   *
   * Upon erroneous input "[]", the call chain is
   *
   * a -> b -> c
   *
   * and, hence, the follow context stack is:
   *
   * depth follow set start of rule execution
   * 0 <EOF> a (from main())
   * 1 ']' b
   * 2 '^' c
   *
   * Notice that ')' is not included, because b would have to have
   * been called from a different context in rule a for ')' to be
   * included.
   *
   * For error recovery, we cannot consider FOLLOW(c)
   * (context-sensitive or otherwise). We need the combined set of
   * all context-sensitive FOLLOW sets--the set of all tokens that
   * could follow any reference in the call chain. We need to
   * resync to one of those tokens. Note that FOLLOW(c)='^' and if
   * we resync'd to that token, we'd consume until EOF. We need to
   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
   * In this case, for input "[]", LA(1) is ']' and in the set, so we would
   * not consume anything. After printing an error, rule c would
   * return normally. Rule b would not find the required '^' though.
   * At this point, it gets a mismatched token error and throws an
   * exception (since LA(1) is not in the viable following token
   * set). The rule exception handler tries to recover, but finds
   * the same recovery set and doesn't consume anything. Rule b
   * exits normally returning to rule a. Now it finds the ']' (and
   * with the successful match exits errorRecovery mode).
   *
   * So, you can see that the parser walks up the call chain looking
   * for the token that was a member of the recovery set.
   *
   * Errors are not generated in errorRecovery mode.
   *
   * ANTLR's error recovery mechanism is based upon original ideas:
   *
   * "Algorithms + Data Structures = Programs" by Niklaus Wirth
   *
   * and
   *
   * "A note on error recovery in recursive descent parsers":
   * http://portal.acm.org/citation.cfm?id=947902.947905
   *
   * Later, Josef Grosch had some good ideas:
   *
   * "Efficient and Comfortable Error Recovery in Recursive Descent
   * Parsers":
   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
   *
   * Like Grosch I implement context-sensitive FOLLOW sets that are combined
   * at run-time upon error to avoid overhead during parsing.
   */
  getErrorRecoverySet(recognizer) {
    const atn3 = recognizer._interp.atn;
    let ctx = recognizer._ctx;
    const recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState >= 0) {
      const invokingState = atn3.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      const follow = atn3.nextTokens(rt.followState);
      recoverSet.addSet(follow);
      ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
  }
  // Consume tokens until one matches the given token set.//
  consumeUntil(recognizer, set) {
    let ttype = recognizer.getTokenStream().LA(1);
    while (ttype !== Token.EOF && !set.contains(ttype)) {
      recognizer.consume();
      ttype = recognizer.getTokenStream().LA(1);
    }
  }
};

// node_modules/antlr4/src/antlr4/error/BailErrorStrategy.js
var BailErrorStrategy = class extends DefaultErrorStrategy {
  constructor() {
    super();
  }
  /**
   * Instead of recovering from exception {@code e}, re-throw it wrapped
   * in a {@link ParseCancellationException} so it is not caught by the
   * rule function catches. Use {@link Exception//getCause()} to get the
   * original {@link RecognitionException}.
   */
  recover(recognizer, e) {
    let context = recognizer._ctx;
    while (context !== null) {
      context.exception = e;
      context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
  }
  /**
   * Make sure we don't attempt to recover inline; if the parser
   * successfully recovers, it won't throw an exception.
   */
  recoverInline(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
  }
  // Make sure we don't attempt to recover from problems in subrules.//
  sync(recognizer) {
  }
};

// node_modules/antlr4/src/antlr4/error/index.js
var error_default = {
  RecognitionException,
  NoViableAltException,
  LexerNoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  DiagnosticErrorListener,
  BailErrorStrategy,
  DefaultErrorStrategy,
  ErrorListener
};

// node_modules/antlr4/src/antlr4/InputStream.js
var InputStream = class {
  constructor(data, decodeToUnicodeCodePoints) {
    this.name = "<empty>";
    this.strdata = data;
    this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
    this._index = 0;
    this.data = [];
    if (this.decodeToUnicodeCodePoints) {
      for (let i = 0; i < this.strdata.length; ) {
        const codePoint = this.strdata.codePointAt(i);
        this.data.push(codePoint);
        i += codePoint <= 65535 ? 1 : 2;
      }
    } else {
      this.data = new Array(this.strdata.length);
      for (let i = 0; i < this.strdata.length; i++) {
        const codeUnit = this.strdata.charCodeAt(i);
        this.data[i] = codeUnit;
      }
    }
    this._size = this.data.length;
  }
  /**
   * Reset the stream so that it's in the same state it was
   * when the object was created *except* the data array is not
   * touched.
   */
  reset() {
    this._index = 0;
  }
  consume() {
    if (this._index >= this._size) {
      throw "cannot consume EOF";
    }
    this._index += 1;
  }
  LA(offset) {
    if (offset === 0) {
      return 0;
    }
    if (offset < 0) {
      offset += 1;
    }
    const pos = this._index + offset - 1;
    if (pos < 0 || pos >= this._size) {
      return Token.EOF;
    }
    return this.data[pos];
  }
  LT(offset) {
    return this.LA(offset);
  }
  // mark/release do nothing; we have entire buffer
  mark() {
    return -1;
  }
  release(marker) {
  }
  /**
   * consume() ahead until p==_index; can't just set p=_index as we must
   * update line and column. If we seek backwards, just set p
   */
  seek(_index) {
    if (_index <= this._index) {
      this._index = _index;
      return;
    }
    this._index = Math.min(_index, this._size);
  }
  getText(start, stop) {
    if (stop >= this._size) {
      stop = this._size - 1;
    }
    if (start >= this._size) {
      return "";
    } else {
      if (this.decodeToUnicodeCodePoints) {
        let result = "";
        for (let i = start; i <= stop; i++) {
          result += String.fromCodePoint(this.data[i]);
        }
        return result;
      } else {
        return this.strdata.slice(start, stop + 1);
      }
    }
  }
  toString() {
    return this.strdata;
  }
  get index() {
    return this._index;
  }
  get size() {
    return this._size;
  }
};

// node_modules/antlr4/src/antlr4/CharStreams.js
var import_fs2 = __toESM(require("fs"), 1);
var CharStreams_default = {
  // Creates an InputStream from a string.
  fromString: function(str) {
    return new InputStream(str, true);
  },
  /**
   * Asynchronously creates an InputStream from a blob given the
   * encoding of the bytes in that blob (defaults to 'utf8' if
   * encoding is null).
   *
   * Invokes onLoad(result) on success, onError(error) on
   * failure.
   */
  fromBlob: function(blob, encoding, onLoad, onError) {
    const reader = new window.FileReader();
    reader.onload = function(e) {
      const is = new InputStream(e.target.result, true);
      onLoad(is);
    };
    reader.onerror = onError;
    reader.readAsText(blob, encoding);
  },
  /**
   * Creates an InputStream from a Buffer given the
   * encoding of the bytes in that buffer (defaults to 'utf8' if
   * encoding is null).
   */
  fromBuffer: function(buffer, encoding) {
    return new InputStream(buffer.toString(encoding), true);
  },
  /** Asynchronously creates an InputStream from a file on disk given
   * the encoding of the bytes in that file (defaults to 'utf8' if
   * encoding is null).
   *
   * Invokes callback(error, result) on completion.
   */
  fromPath: function(path7, encoding, callback) {
    import_fs2.default.readFile(path7, encoding, function(err, data) {
      let is = null;
      if (data !== null) {
        is = new InputStream(data, true);
      }
      callback(err, is);
    });
  },
  /**
   * Synchronously creates an InputStream given a path to a file
   * on disk and the encoding of the bytes in that file (defaults to
   * 'utf8' if encoding is null).
   */
  fromPathSync: function(path7, encoding) {
    const data = import_fs2.default.readFileSync(path7, encoding);
    return new InputStream(data, true);
  }
};

// node_modules/antlr4/src/antlr4/FileStream.js
var import_fs3 = __toESM(require("fs"), 1);
var FileStream = class extends InputStream {
  constructor(fileName, decodeToUnicodeCodePoints) {
    const data = import_fs3.default.readFileSync(fileName, "utf8");
    super(data, decodeToUnicodeCodePoints);
    this.fileName = fileName;
  }
};

// node_modules/antlr4/src/antlr4/TokenStream.js
var TokenStream = class {
};

// node_modules/antlr4/src/antlr4/BufferedTokenStream.js
var BufferedTokenStream = class extends TokenStream {
  constructor(tokenSource) {
    super();
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }
  mark() {
    return 0;
  }
  release(marker) {
  }
  reset() {
    this.seek(0);
  }
  seek(index) {
    this.lazyInit();
    this.index = this.adjustSeekIndex(index);
  }
  get(index) {
    this.lazyInit();
    return this.tokens[index];
  }
  consume() {
    let skipEofCheck = false;
    if (this.index >= 0) {
      if (this.fetchedEOF) {
        skipEofCheck = this.index < this.tokens.length - 1;
      } else {
        skipEofCheck = this.index < this.tokens.length;
      }
    } else {
      skipEofCheck = false;
    }
    if (!skipEofCheck && this.LA(1) === Token.EOF) {
      throw "cannot consume EOF";
    }
    if (this.sync(this.index + 1)) {
      this.index = this.adjustSeekIndex(this.index + 1);
    }
  }
  /**
   * Make sure index {@code i} in tokens has a token.
   *
   * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
   * {@code false}.
   * @see //get(int i)
   */
  sync(i) {
    const n = i - this.tokens.length + 1;
    if (n > 0) {
      const fetched = this.fetch(n);
      return fetched >= n;
    }
    return true;
  }
  /**
   * Add {@code n} elements to buffer.
   *
   * @return {Number} The actual number of elements added to the buffer.
   */
  fetch(n) {
    if (this.fetchedEOF) {
      return 0;
    }
    for (let i = 0; i < n; i++) {
      const t = this.tokenSource.nextToken();
      t.tokenIndex = this.tokens.length;
      this.tokens.push(t);
      if (t.type === Token.EOF) {
        this.fetchedEOF = true;
        return i + 1;
      }
    }
    return n;
  }
  // Get all tokens from start..stop inclusively///
  getTokens(start, stop, types) {
    if (types === void 0) {
      types = null;
    }
    if (start < 0 || stop < 0) {
      return null;
    }
    this.lazyInit();
    const subset = [];
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    for (let i = start; i < stop; i++) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        break;
      }
      if (types === null || types.contains(t.type)) {
        subset.push(t);
      }
    }
    return subset;
  }
  LA(i) {
    return this.LT(i).type;
  }
  LB(k) {
    if (this.index - k < 0) {
      return null;
    }
    return this.tokens[this.index - k];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    const i = this.index + k - 1;
    this.sync(i);
    if (i >= this.tokens.length) {
      return this.tokens[this.tokens.length - 1];
    }
    return this.tokens[i];
  }
  /**
   * Allowed derived classes to modify the behavior of operations which change
   * the current stream position by adjusting the target token index of a seek
   * operation. The default implementation simply returns {@code i}. If an
   * exception is thrown in this method, the current stream index should not be
   * changed.
   *
   * <p>For example, {@link CommonTokenStream} overrides this method to ensure
   * that
   * the seek target is always an on-channel token.</p>
   *
   * @param {Number} i The target token index.
   * @return {Number} The adjusted target token index.
   */
  adjustSeekIndex(i) {
    return i;
  }
  lazyInit() {
    if (this.index === -1) {
      this.setup();
    }
  }
  setup() {
    this.sync(0);
    this.index = this.adjustSeekIndex(0);
  }
  // Reset this token stream by setting its token source.///
  setTokenSource(tokenSource) {
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }
  /**
   * Given a starting index, return the index of the next token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and EOF.
   */
  nextTokenOnChannel(i, channel) {
    this.sync(i);
    if (i >= this.tokens.length) {
      return -1;
    }
    let token = this.tokens[i];
    while (token.channel !== this.channel) {
      if (token.type === Token.EOF) {
        return -1;
      }
      i += 1;
      this.sync(i);
      token = this.tokens[i];
    }
    return i;
  }
  /**
   * Given a starting index, return the index of the previous token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and 0.
   */
  previousTokenOnChannel(i, channel) {
    while (i >= 0 && this.tokens[i].channel !== channel) {
      i -= 1;
    }
    return i;
  }
  /**
   * Collect all tokens on specified channel to the right of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
   * EOF. If channel is -1, find any non default channel token.
   */
  getHiddenTokensToRight(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    const from_ = tokenIndex + 1;
    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
    return this.filterForChannel(from_, to, channel);
  }
  /**
   * Collect all tokens on specified channel to the left of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
   * If channel is -1, find any non default channel token.
   */
  getHiddenTokensToLeft(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    if (prevOnChannel === tokenIndex - 1) {
      return null;
    }
    const from_ = prevOnChannel + 1;
    const to = tokenIndex - 1;
    return this.filterForChannel(from_, to, channel);
  }
  filterForChannel(left, right, channel) {
    const hidden = [];
    for (let i = left; i < right + 1; i++) {
      const t = this.tokens[i];
      if (channel === -1) {
        if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
          hidden.push(t);
        }
      } else if (t.channel === channel) {
        hidden.push(t);
      }
    }
    if (hidden.length === 0) {
      return null;
    }
    return hidden;
  }
  getSourceName() {
    return this.tokenSource.getSourceName();
  }
  // Get the text of all tokens in this buffer.///
  getText(interval) {
    this.lazyInit();
    this.fill();
    if (interval === void 0 || interval === null) {
      interval = new Interval(0, this.tokens.length - 1);
    }
    let start = interval.start;
    if (start instanceof Token) {
      start = start.tokenIndex;
    }
    let stop = interval.stop;
    if (stop instanceof Token) {
      stop = stop.tokenIndex;
    }
    if (start === null || stop === null || start < 0 || stop < 0) {
      return "";
    }
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    let s = "";
    for (let i = start; i < stop + 1; i++) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        break;
      }
      s = s + t.text;
    }
    return s;
  }
  // Get all tokens from lexer until EOF///
  fill() {
    this.lazyInit();
    while (this.fetch(1e3) === 1e3) {
      continue;
    }
  }
};

// node_modules/antlr4/src/antlr4/CommonTokenStream.js
var CommonTokenStream = class extends BufferedTokenStream {
  constructor(lexer, channel) {
    super(lexer);
    this.channel = channel === void 0 ? Token.DEFAULT_CHANNEL : channel;
  }
  adjustSeekIndex(i) {
    return this.nextTokenOnChannel(i, this.channel);
  }
  LB(k) {
    if (k === 0 || this.index - k < 0) {
      return null;
    }
    let i = this.index;
    let n = 1;
    while (n <= k) {
      i = this.previousTokenOnChannel(i - 1, this.channel);
      n += 1;
    }
    if (i < 0) {
      return null;
    }
    return this.tokens[i];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    let i = this.index;
    let n = 1;
    while (n < k) {
      if (this.sync(i + 1)) {
        i = this.nextTokenOnChannel(i + 1, this.channel);
      }
      n += 1;
    }
    return this.tokens[i];
  }
  // Count EOF just once.
  getNumberOfOnChannelTokens() {
    let n = 0;
    this.fill();
    for (let i = 0; i < this.tokens.length; i++) {
      const t = this.tokens[i];
      if (t.channel === this.channel) {
        n += 1;
      }
      if (t.type === Token.EOF) {
        break;
      }
    }
    return n;
  }
};

// node_modules/antlr4/src/antlr4/TraceListener.js
var TraceListener = class extends ParseTreeListener {
  constructor(parser) {
    super();
    this.parser = parser;
  }
  enterEveryRule(ctx) {
    console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(node) {
    console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(ctx) {
    console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
};

// node_modules/antlr4/src/antlr4/Parser.js
var Parser = class extends Recognizer {
  /**
   * this is all the parsing support code essentially; most of it is error
   * recovery stuff.
   */
  constructor(input) {
    super();
    this._input = null;
    this._errHandler = new DefaultErrorStrategy();
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    this._ctx = null;
    this.buildParseTrees = true;
    this._tracer = null;
    this._parseListeners = null;
    this._syntaxErrors = 0;
    this.setInputStream(input);
  }
  // reset the parser's state
  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }
    this._errHandler.reset(this);
    this._ctx = null;
    this._syntaxErrors = 0;
    this.setTrace(false);
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    if (this._interp !== null) {
      this._interp.reset();
    }
  }
  /**
   * Match current input symbol against {@code ttype}. If the symbol type
   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
   * called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @param ttype the token type to match
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * {@code ttype} and the error strategy could not recover from the
   * mismatched symbol
   */
  match(ttype) {
    let t = this.getCurrentToken();
    if (t.type === ttype) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);
      if (this.buildParseTrees && t.tokenIndex === -1) {
        this._ctx.addErrorNode(t);
      }
    }
    return t;
  }
  /**
   * Match current input symbol as a wildcard. If the symbol type matches
   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
   * and {@link //consume} are called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * a wildcard and the error strategy could not recover from the mismatched
   * symbol
   */
  matchWildcard() {
    let t = this.getCurrentToken();
    if (t.type > 0) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);
      if (this._buildParseTrees && t.tokenIndex === -1) {
        this._ctx.addErrorNode(t);
      }
    }
    return t;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  /**
   * Registers {@code listener} to receive events during the parsing process.
   *
   * <p>To support output-preserving grammar transformations (including but not
   * limited to left-recursion removal, automated left-factoring, and
   * optimized code generation), calls to listener methods during the parse
   * may differ substantially from calls made by
   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
   * particular, rule entry and exit events may occur in a different order
   * during the parse than after the parser. In addition, calls to certain
   * rule entry methods may be omitted.</p>
   *
   * <p>With the following specific exceptions, calls to listener events are
   * <em>deterministic</em>, i.e. for identical input the calls to listener
   * methods will be the same.</p>
   *
   * <ul>
   * <li>Alterations to the grammar used to generate code may change the
   * behavior of the listener calls.</li>
   * <li>Alterations to the command line options passed to ANTLR 4 when
   * generating the parser may change the behavior of the listener calls.</li>
   * <li>Changing the version of the ANTLR Tool used to generate the parser
   * may change the behavior of the listener calls.</li>
   * </ul>
   *
   * @param listener the listener to add
   *
   * @throws NullPointerException if {@code} listener is {@code null}
   */
  addParseListener(listener) {
    if (listener === null) {
      throw "listener";
    }
    if (this._parseListeners === null) {
      this._parseListeners = [];
    }
    this._parseListeners.push(listener);
  }
  /**
   * Remove {@code listener} from the list of parse listeners.
   *
   * <p>If {@code listener} is {@code null} or has not been added as a parse
   * listener, this method does nothing.</p>
   * @param listener the listener to remove
   */
  removeParseListener(listener) {
    if (this._parseListeners !== null) {
      const idx = this._parseListeners.indexOf(listener);
      if (idx >= 0) {
        this._parseListeners.splice(idx, 1);
      }
      if (this._parseListeners.length === 0) {
        this._parseListeners = null;
      }
    }
  }
  // Remove all parse listeners.
  removeParseListeners() {
    this._parseListeners = null;
  }
  // Notify any parse listeners of an enter rule event.
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;
      this._parseListeners.forEach(function(listener) {
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      });
    }
  }
  /**
   * Notify any parse listeners of an exit rule event.
   * @see //addParseListener
   */
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function(listener) {
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  // Tell our token source and error strategy about a new way to create tokens.
  setTokenFactory(factory) {
    this._input.tokenSource._factory = factory;
  }
  /**
   * The ATN with bypass alternatives is expensive to create so we create it
   * lazily.
   *
   * @throws UnsupportedOperationException if the current parser does not
   * implement the {@link //getSerializedATN()} method.
   */
  getATNWithBypassAlts() {
    const serializedAtn = this.getSerializedATN();
    if (serializedAtn === null) {
      throw "The current parser does not support an ATN with bypass alternatives.";
    }
    let result = this.bypassAltsAtnCache[serializedAtn];
    if (result === null) {
      const deserializationOptions = new ATNDeserializationOptions();
      deserializationOptions.generateRuleBypassTransitions = true;
      result = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
      this.bypassAltsAtnCache[serializedAtn] = result;
    }
    return result;
  }
  getInputStream() {
    return this.getTokenStream();
  }
  setInputStream(input) {
    this.setTokenStream(input);
  }
  getTokenStream() {
    return this._input;
  }
  // Set the token stream and reset the parser.
  setTokenStream(input) {
    this._input = null;
    this.reset();
    this._input = input;
  }
  /**
   * Match needs to return the current input symbol, which gets put
   * into the label for the associated token ref; e.g., x=ID.
   */
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(msg, offendingToken, err) {
    offendingToken = offendingToken || null;
    err = err || null;
    if (offendingToken === null) {
      offendingToken = this.getCurrentToken();
    }
    this._syntaxErrors += 1;
    const line = offendingToken.line;
    const column = offendingToken.column;
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, offendingToken, line, column, msg, err);
  }
  /**
   * Consume and return the {@linkplain //getCurrentToken current symbol}.
   *
   * <p>E.g., given the following input with {@code A} being the current
   * lookahead symbol, this function moves the cursor to {@code B} and returns
   * {@code A}.</p>
   *
   * <pre>
   * A B
   * ^
   * </pre>
   *
   * If the parser is not in error recovery mode, the consumed symbol is added
   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
   * If the parser <em>is</em> in error recovery mode, the consumed symbol is
   * added to the parse tree using
   * {@link ParserRuleContext//addErrorNode(Token)}, and
   * {@link ParseTreeListener//visitErrorNode} is called on any parse
   * listeners.
   */
  consume() {
    const o = this.getCurrentToken();
    if (o.type !== Token.EOF) {
      this.getInputStream().consume();
    }
    const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || hasListener) {
      let node;
      if (this._errHandler.inErrorRecoveryMode(this)) {
        node = this._ctx.addErrorNode(o);
      } else {
        node = this._ctx.addTokenNode(o);
      }
      node.invokingState = this.state;
      if (hasListener) {
        this._parseListeners.forEach(function(listener) {
          if (node instanceof ErrorNode || node.isErrorNode !== void 0 && node.isErrorNode()) {
            listener.visitErrorNode(node);
          } else if (node instanceof TerminalNode) {
            listener.visitTerminal(node);
          }
        });
      }
    }
    return o;
  }
  addContextToParseTree() {
    if (this._ctx.parentCtx !== null) {
      this._ctx.parentCtx.addChild(this._ctx);
    }
  }
  /**
   * Always called by generated parsers upon entry to a rule. Access field
   * {@link //_ctx} get the current context.
   */
  enterRule(localctx, state, ruleIndex) {
    this.state = state;
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    if (this.buildParseTrees) {
      this.addContextToParseTree();
    }
    this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1);
    this.triggerExitRuleEvent();
    this.state = this._ctx.invokingState;
    this._ctx = this._ctx.parentCtx;
  }
  enterOuterAlt(localctx, altNum) {
    localctx.setAltNumber(altNum);
    if (this.buildParseTrees && this._ctx !== localctx) {
      if (this._ctx.parentCtx !== null) {
        this._ctx.parentCtx.removeLastChild();
        this._ctx.parentCtx.addChild(localctx);
      }
    }
    this._ctx = localctx;
  }
  /**
   * Get the precedence level for the top-most precedence rule.
   *
   * @return The precedence level for the top-most precedence rule, or -1 if
   * the parser context is not nested within a precedence rule.
   */
  getPrecedence() {
    if (this._precedenceStack.length === 0) {
      return -1;
    } else {
      return this._precedenceStack[this._precedenceStack.length - 1];
    }
  }
  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.state = state;
    this._precedenceStack.push(precedence);
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    this.triggerEnterRuleEvent();
  }
  // Like {@link //enterRule} but for recursive rules.
  pushNewRecursionContext(localctx, state, ruleIndex) {
    const previous = this._ctx;
    previous.parentCtx = localctx;
    previous.invokingState = state;
    previous.stop = this._input.LT(-1);
    this._ctx = localctx;
    this._ctx.start = previous.start;
    if (this.buildParseTrees) {
      this._ctx.addChild(previous);
    }
    this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(parentCtx) {
    this._precedenceStack.pop();
    this._ctx.stop = this._input.LT(-1);
    const retCtx = this._ctx;
    const parseListeners = this.getParseListeners();
    if (parseListeners !== null && parseListeners.length > 0) {
      while (this._ctx !== parentCtx) {
        this.triggerExitRuleEvent();
        this._ctx = this._ctx.parentCtx;
      }
    } else {
      this._ctx = parentCtx;
    }
    retCtx.parentCtx = parentCtx;
    if (this.buildParseTrees && parentCtx !== null) {
      parentCtx.addChild(retCtx);
    }
  }
  getInvokingContext(ruleIndex) {
    let ctx = this._ctx;
    while (ctx !== null) {
      if (ctx.ruleIndex === ruleIndex) {
        return ctx;
      }
      ctx = ctx.parentCtx;
    }
    return null;
  }
  precpred(localctx, precedence) {
    return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(context) {
    return false;
  }
  /**
   * Checks whether or not {@code symbol} can follow the current state in the
   * ATN. The behavior of this method is equivalent to the following, but is
   * implemented such that the complete context-sensitive follow set does not
   * need to be explicitly constructed.
   *
   * <pre>
   * return getExpectedTokens().contains(symbol);
   * </pre>
   *
   * @param symbol the symbol type to check
   * @return {@code true} if {@code symbol} can follow the current state in
   * the ATN, otherwise {@code false}.
   */
  isExpectedToken(symbol) {
    const atn3 = this._interp.atn;
    let ctx = this._ctx;
    const s = atn3.states[this.state];
    let following = atn3.nextTokens(s);
    if (following.contains(symbol)) {
      return true;
    }
    if (!following.contains(Token.EPSILON)) {
      return false;
    }
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = atn3.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = atn3.nextTokens(rt.followState);
      if (following.contains(symbol)) {
        return true;
      }
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Computes the set of input symbols which could follow the current parser
   * state and context, as given by {@link //getState} and {@link //getContext},
   * respectively.
   *
   * @see ATN//getExpectedTokens(int, RuleContext)
   */
  getExpectedTokens() {
    return this._interp.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    const atn3 = this._interp.atn;
    const s = atn3.states[this.state];
    return atn3.nextTokens(s);
  }
  // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.
  getRuleIndex(ruleName) {
    const ruleIndex = this.getRuleIndexMap()[ruleName];
    if (ruleIndex !== null) {
      return ruleIndex;
    } else {
      return -1;
    }
  }
  /**
   * Return List&lt;String&gt; of the rule names in your parser instance
   * leading up to a call to the current rule. You could override if
   * you want more details such as the file/line info of where
   * in the ATN a rule is invoked.
   *
   * this is very useful for error messages.
   */
  getRuleInvocationStack(p) {
    p = p || null;
    if (p === null) {
      p = this._ctx;
    }
    const stack = [];
    while (p !== null) {
      const ruleIndex = p.ruleIndex;
      if (ruleIndex < 0) {
        stack.push("n/a");
      } else {
        stack.push(this.ruleNames[ruleIndex]);
      }
      p = p.parentCtx;
    }
    return stack;
  }
  // For debugging and other purposes.
  getDFAStrings() {
    return this._interp.decisionToDFA.toString();
  }
  // For debugging and other purposes.
  dumpDFA() {
    let seenOne = false;
    for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
      const dfa = this._interp.decisionToDFA[i];
      if (dfa.states.length > 0) {
        if (seenOne) {
          console.log();
        }
        this.printer.println("Decision " + dfa.decision + ":");
        this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
        seenOne = true;
      }
    }
  }
  /*
      "			printer = function() {\r\n" +
      "				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
      "				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
      "			};\r\n" +
      */
  getSourceName() {
    return this._input.sourceName;
  }
  /**
   * During a parse is sometimes useful to listen in on the rule entry and exit
   * events as well as token matches. this is for quick and dirty debugging.
   */
  setTrace(trace) {
    if (!trace) {
      this.removeParseListener(this._tracer);
      this._tracer = null;
    } else {
      if (this._tracer !== null) {
        this.removeParseListener(this._tracer);
      }
      this._tracer = new TraceListener(this);
      this.addParseListener(this._tracer);
    }
  }
};
Parser.bypassAltsAtnCache = {};

// node_modules/antlr4/src/antlr4/atn/PredictionContextCache.js
var PredictionContextCache = class {
  constructor() {
    this.cache = new HashMap();
  }
  /**
   * Add a context to the cache and return it. If the context already exists,
   * return that one instead and do not add a new context to the cache.
   * Protect shared cache from unsafe thread access.
   */
  add(ctx) {
    if (ctx === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    const existing = this.cache.get(ctx) || null;
    if (existing !== null) {
      return existing;
    }
    this.cache.set(ctx, ctx);
    return ctx;
  }
  get(ctx) {
    return this.cache.get(ctx) || null;
  }
  get length() {
    return this.cache.length;
  }
};

// node_modules/antlr4/src/antlr4/tree/TerminalNodeImpl.js
var TerminalNodeImpl = class extends TerminalNode {
  constructor(symbol) {
    super();
    this.parentCtx = null;
    this.symbol = symbol;
  }
  getChild(i) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  getParent() {
    return this.parentCtx;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null) {
      return Interval.INVALID_INTERVAL;
    }
    const tokenIndex = this.symbol.tokenIndex;
    return new Interval(tokenIndex, tokenIndex);
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    if (this.symbol.type === Token.EOF) {
      return "<EOF>";
    } else {
      return this.symbol.text;
    }
  }
};

// node_modules/antlr4/src/antlr4/tree/ErrorNodeImpl.js
var ErrorNodeImpl = class extends TerminalNodeImpl {
  constructor(token) {
    super(token);
  }
  isErrorNode() {
    return true;
  }
  accept(visitor) {
    return visitor.visitErrorNode(this);
  }
};

// node_modules/antlr4/src/antlr4/context/ParserRuleContext.js
var ParserRuleContext = class extends RuleContext {
  constructor(parent, invokingStateNumber) {
    parent = parent || null;
    invokingStateNumber = invokingStateNumber || null;
    super(parent, invokingStateNumber);
    this.ruleIndex = -1;
    this.children = null;
    this.start = null;
    this.stop = null;
    this.exception = null;
  }
  // COPY a ctx (I'm deliberately not using copy constructor)
  copyFrom(ctx) {
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    if (ctx.children) {
      this.children = [];
      ctx.children.map(function(child) {
        if (child instanceof ErrorNodeImpl) {
          this.children.push(child);
          child.parentCtx = this;
        }
      }, this);
    }
  }
  // Double dispatch methods for listeners
  enterRule(listener) {
  }
  exitRule(listener) {
  }
  // Does not set parent link; other add methods do that
  addChild(child) {
    if (this.children === null) {
      this.children = [];
    }
    this.children.push(child);
    return child;
  }
  /** Used by enterOuterAlt to toss out a RuleContext previously added as
   * we entered a rule. If we have // label, we will need to remove
   * generic ruleContext object.
   */
  removeLastChild() {
    if (this.children !== null) {
      this.children.pop();
    }
  }
  addTokenNode(token) {
    const node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }
  addErrorNode(badToken) {
    const node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }
  getChild(i, type) {
    type = type || null;
    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }
    if (type === null) {
      return this.children[i];
    } else {
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof type) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
      return null;
    }
  }
  getToken(ttype, i) {
    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }
    for (let j = 0; j < this.children.length; j++) {
      const child = this.children[j];
      if (child instanceof TerminalNode) {
        if (child.symbol.type === ttype) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
    }
    return null;
  }
  getTokens(ttype) {
    if (this.children === null) {
      return [];
    } else {
      const tokens = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof TerminalNode) {
          if (child.symbol.type === ttype) {
            tokens.push(child);
          }
        }
      }
      return tokens;
    }
  }
  getTypedRuleContext(ctxType, i) {
    return this.getChild(i, ctxType);
  }
  getTypedRuleContexts(ctxType) {
    if (this.children === null) {
      return [];
    } else {
      const contexts = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof ctxType) {
          contexts.push(child);
        }
      }
      return contexts;
    }
  }
  getChildCount() {
    if (this.children === null) {
      return 0;
    } else {
      return this.children.length;
    }
  }
  getSourceInterval() {
    if (this.start === null || this.stop === null) {
      return Interval.INVALID_INTERVAL;
    } else {
      return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }
};
RuleContext.EMPTY = new ParserRuleContext();

// node_modules/antlr4/src/antlr4/utils/index.js
var utils_default = { arrayToString };

// node_modules/antlr4/src/antlr4/index.js
var antlr4 = {
  atn: atn_default,
  dfa: dfa_default,
  tree: tree_default,
  error: error_default,
  Token,
  CommonToken,
  CharStreams: CharStreams_default,
  InputStream,
  FileStream,
  CommonTokenStream,
  Lexer,
  Parser,
  PredictionContextCache,
  ParserRuleContext,
  Interval,
  IntervalSet,
  LL1Analyzer,
  Utils: utils_default
};
var antlr4_default = antlr4;

// src/parser/visitor.ts
var import_chalk2 = __toESM(require_source());
var import_fs4 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
var LambdaSuffix = "$$lambda";
function generateTsDef(context, ifs, typeRoot) {
  import_fs4.default.mkdirSync(typeRoot, { recursive: true });
  const references = [];
  const topNamespaces = {};
  for (const c of context.classOrInterface()) {
    let filename = "";
    const frontBuffer = [];
    const endBuffer = [];
    const lambdaBuffer = "";
    if (c.classDeclaration()) {
      const classModifier = c.classDeclaration().classModifier();
      const type = c.classDeclaration().type(0);
      const extend = c.classDeclaration().type(1);
      const implement = c.classDeclaration().typeList();
      const classBody = c.classDeclaration().classBody();
      filename = qualifiedName(type) + ".d.ts";
      topNamespaces[type.packageName().Identifier(0).getText()] = true;
      const nsDeclaration = declareNamespaces(type);
      frontBuffer.push(nsDeclaration[0]);
      endBuffer.push(nsDeclaration[1]);
      const modifier = classModifier.some((it) => it.getText() === "abstract") ? "abstract " : "";
      frontBuffer.push(modifier + "class " + header(type, extend && [extend], implement?.type()) + " {");
      endBuffer.push("}\n");
      for (const member of classBody.classMember()) {
        if (member.constructorDeclaration()) {
          frontBuffer.push("  " + declareConstructor(member.constructorDeclaration(), ifs));
        } else if (member.fieldDeclaration()) {
          frontBuffer.push("  " + declareField(member.fieldDeclaration()));
        } else if (member.methodDeclaration()) {
          frontBuffer.push("  " + declareMethod(member.methodDeclaration(), ifs, true));
        }
      }
    } else if (c.interfaceDeclaration()) {
      const type = c.interfaceDeclaration().type();
      const extend = c.interfaceDeclaration().typeList();
      const interfaceBody = c.interfaceDeclaration().interfaceBody();
      filename = qualifiedName(type) + ".d.ts";
      topNamespaces[type.packageName().Identifier(0).getText()] = true;
      const nsDeclaration = declareNamespaces(type);
      frontBuffer.push(nsDeclaration[0]);
      endBuffer.push(nsDeclaration[1]);
      if (isLambda(ifs, type)) {
        if (interfaceBody.interfaceMember()?.some((it) => it.methodDeclaration())) {
          const method = interfaceBody.interfaceMember().filter((it) => it.methodDeclaration())[0].methodDeclaration();
          frontBuffer.push(
            "interface " + type.Identifier().getText() + LambdaSuffix + typeArgumentsToString(type.typeArguments()) + " {\n(" + methodArgumentsToString(method.methodArguments(), ifs) + "): " + methodArgumentToString(method.type(), ifs) + "\n}\n"
          );
        } else {
          extend.type().filter((it) => isLambda(ifs, it)).forEach((it) => {
            frontBuffer.push(
              "type " + type.Identifier().getText() + LambdaSuffix + typeArgumentsToString(type.typeArguments()) + " = " + qualifiedName(it, true) + LambdaSuffix + typeArgumentsToString(it.typeArguments()) + "\n"
            );
          });
        }
      }
      frontBuffer.push("interface " + header(type, extend?.type()) + " {");
      endBuffer.push("}\n");
      for (const member of interfaceBody.interfaceMember()) {
        if (member.fieldDeclaration()) {
          frontBuffer.push("  " + declareField(member.fieldDeclaration()));
        } else if (member.methodDeclaration()) {
          frontBuffer.push("  " + declareMethod(member.methodDeclaration(), ifs));
        }
      }
    } else {
      console.error("Cannot find class or interface declaration");
      continue;
    }
    if (filename) {
      const content = [...frontBuffer, ...endBuffer.reverse()].join("\n");
      import_fs4.default.writeFileSync(import_path3.default.join(typeRoot, filename), content + lambdaBuffer);
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      process.stdout.write(`Generated lib/@types/${filename}`);
      references.push(filename);
    }
  }
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
  import_fs4.default.writeFileSync(
    import_path3.default.join(typeRoot, "index.d.ts"),
    references.map((it) => `/// <reference path="${it}" />`).sort().join("\n")
  );
  console.log(import_chalk2.default.green("Generated " + import_path3.default.join(typeRoot, "index.d.ts")));
  import_fs4.default.writeFileSync(import_path3.default.join(typeRoot, "namespace.json"), JSON.stringify(topNamespaces, null, 2));
  console.log(import_chalk2.default.green("Generated " + import_path3.default.join(typeRoot, "namespace.json")));
  return true;
}
function declareConstructor(constructor, ifs) {
  let result = "";
  constructor.modifier()?.forEach((it) => result += convertMemberModifier(it.getText()) + " ");
  result += "constructor";
  result += "(" + methodArgumentsToString(constructor.methodArguments(), ifs) + ")";
  return result;
}
function declareField(field) {
  if (field.Identifier().getText() === "constructor")
    return "";
  let result = "";
  field.modifier()?.forEach((it) => result += convertMemberModifier(it.getText(), true) + " ");
  result += field.Identifier().getText();
  result += ": " + typeToString(field.type());
  return result;
}
function declareMethod(method, ifs, isClass = false) {
  let result = "";
  if (isClass) {
    method.modifier()?.forEach((it) => result += convertMemberModifier(it.getText()) + " ");
  }
  result += method.Identifier().getText();
  result += typeArgumentsToString(method.typeArguments());
  result += "(" + methodArgumentsToString(method.methodArguments(), ifs) + ")";
  result += ": " + typeToString(method.type(), true);
  return result;
}
function methodArgumentToString(type, ifs) {
  if (isLambda(ifs, type)) {
    return [
      typeToString(type),
      qualifiedName(type, true) + LambdaSuffix + typeArgumentsToString(type.typeArguments())
    ].join(" | ");
  } else {
    return typeAlias(qualifiedName(type, true)).map((it) => it + typeArgumentsToString(type.typeArguments())).join(" | ");
  }
}
function methodArgumentsToString(methodArgs, ifs) {
  const result = [];
  for (const type of methodArgs.typeList()?.type() || []) {
    result.push("arg" + result.length + ": " + methodArgumentToString(type, ifs));
  }
  if (methodArgs.varargs()) {
    result.push("...vargs: (" + methodArgumentToString(methodArgs.varargs().type(), ifs) + ")[]");
  }
  return result.join(", ");
}
function header(type, extend, implement) {
  let result = type.Identifier().getText() + typeArgumentsToString(type.typeArguments());
  if (extend && extend.length) {
    result += " extends " + extend.map((it) => typeToString(it)).join(", ");
  }
  if (implement && implement.length) {
    result += " implements " + implement.map((it) => typeToString(it)).join(", ");
  }
  return result;
}
function typeArgumentsToString(typeArgs) {
  if (!typeArgs) {
    return "";
  } else if (typeArgs.typeArgument().length) {
    const args = typeArgs.typeArgument().map((it) => typeArgumentToString(it));
    return "<" + args.join(",") + ">" + (typeArgs.arrayBrackets()?.map((it) => it.getText()).join("") || "");
  } else {
    return typeArgs.getText();
  }
}
function typeArgumentToString(typeArg) {
  if (typeArg.getChild(1)?.getText() === "extends") {
    if (typeArg.Identifier()) {
      return typeArg.Identifier().getText() + " extends " + typeArg.type().map((it) => typeToString(it)).join(" & ");
    } else {
      return typeArg.type().map((it) => typeToString(it)).join(" & ");
    }
  } else if (typeArg.getChild(1)?.getText() === "super") {
    return "unknown";
  } else if (typeArg.type(0)) {
    return typeToString(typeArg.type(0));
  } else {
    return "unknown";
  }
}
function typeToString(type, alias = false) {
  if (type.subType()) {
    return "unknown";
  } else if (alias) {
    return typeAlias(qualifiedName(type, true))[0] + typeArgumentsToString(type.typeArguments());
  } else {
    return qualifiedName(type, true) + typeArgumentsToString(type.typeArguments());
  }
}
function declareNamespaces(type) {
  const result = ["", ""];
  for (const id of type.packageName().Identifier()) {
    const ns = convertNamespace(id.getText());
    result[0] += `namespace ${ns} {
`;
    result[1] += "}\n";
  }
  return result[0] ? ["declare " + result[0], result[1]] : result;
}
function typeAlias(type) {
  switch (type) {
    case "boolean":
      return ["boolean", "java.lang.Boolean"];
    case "byte":
      return ["number", "java.lang.Byte"];
    case "char":
      return ["string", "java.lang.Character"];
    case "double":
      return ["number", "java.lang.Double"];
    case "float":
      return ["number", "java.lang.Float"];
    case "int":
      return ["number", "java.lang.Integer"];
    case "long":
      return ["number", "java.lang.Long"];
    case "short":
      return ["number", "java.lang.Short"];
    case "java.lang.Boolean":
      return ["boolean", "java.lang.Boolean"];
    case "java.lang.Byte":
      return ["number", "java.lang.Byte"];
    case "java.lang.CharSequence":
      return ["string", "java.lang.CharSequence"];
    case "java.lang.Character":
      return ["string", "java.lang.Character"];
    case "java.lang.Double":
      return ["number", "java.lang.Double"];
    case "java.lang.Float":
      return ["number", "java.lang.Float"];
    case "java.lang.Integer":
      return ["number", "java.lang.Integer"];
    case "java.lang.Long":
      return ["number", "java.lang.Long"];
    case "java.lang.Object":
      return ["java.lang.Object", "any"];
    case "java.lang.Short":
      return ["number", "java.lang.Short"];
    case "java.lang.String":
      return ["java.lang.String", "string"];
    default:
      return [type];
  }
}
function convertMemberModifier(modifier, isField = false) {
  if (modifier === "abstract")
    return modifier;
  if (modifier === "final" && isField)
    return "readonly";
  if (modifier === "private")
    return modifier;
  if (modifier === "protected")
    return modifier;
  if (modifier === "public")
    return modifier;
  if (modifier === "static")
    return modifier;
  return "";
}
function convertNamespace(namespace) {
  const invalid = ["debugger", "enum", "export", "function", "in", "is", "var"];
  return invalid.indexOf(namespace) < 0 ? namespace : namespace + "$";
}
function qualifiedName(type, safe = false) {
  if (safe) {
    const packages = type.packageName()?.Identifier().map((it) => convertNamespace(it.getText())) || [];
    return [...packages, type.Identifier().getText()].join(".");
  } else {
    return (type.packageName()?.getText().concat(".") || "") + type.Identifier().getText();
  }
}
function isLambda(stat, type) {
  let count = 0;
  const bfs = [qualifiedName(type)];
  if (bfs[0] === "java.util.function.Consumer")
    return true;
  for (let i = 0; i < bfs.length; i++) {
    const current = bfs[i];
    if (stat[current]) {
      count += stat[current][0];
      stat[current].slice(1).forEach((it) => {
        if (bfs.indexOf(it) < 0)
          bfs.push(it);
      });
    }
  }
  return count === 1;
}

// src/parser/javap/JavapLexer.js
var serializedATN = [
  "\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786",
  "\u5964'\u0125\b		",
  "			\x07",
  "	\x07\b	\b			\n	\n\v	\v",
  "\f	\f\r	\r		",
  "				",
  "			",
  "				",
  "\x1B	\x1B		",
  '		 	 !	!"	"#',
  "	#$	$%	%&	&",
  "",
  "",
  "",
  "",
  "",
  "",
  "\x07\x07\x07\x07",
  "\x07\x07\x07\x07\x07\x07",
  "\b\b\b\b\b\b\b	",
  "							\n\n",
  "\n\n\n\n\n\n\n\n\v",
  "\v\v\v\v\v\v",
  "\v\v\f\f\f\f\f",
  "\f\r\r",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\x1B\x1B\x1B\x1B",
  "\x1B\x1B\x1B\x1B\x1B\x1B",
  "\x1B\x1B\x1B",
  "",
  "",
  "",
  '  !!"',
  '""""""###',
  "#$$$%%\x07%\u011A\n%\f%%\u011D",
  "\v%&&\u0120\n&\r&&\u0121&&",
  "'\x07	\v\x07\r\b",
  "	\n\v\f\r\x1B",
  "!#%')+-",
  `/13\x1B579;= ?!A"C#E$G%I&K'`,
  "&&C\\aac|\x07&&2;C\\aac|",
  '\v\f""\u0126',
  "\x07",
  "	\v",
  "\r",
  "",
  "",
  "\x1B",
  "",
  "!#",
  "%'",
  ")+-",
  "/1",
  "35",
  "79",
  ";=",
  "?AC",
  "EG",
  "IK",
  "M[",
  "\x07]	c\vk",
  "\rv\x80",
  "\x87\x8F",
  "\x99\xA2",
  "\xA8\x1B\xAA",
  "\xAD\xAF",
  "!\xB1#\xB3",
  "%\xB5'\xB7",
  ")\xBD+\xBF-\xC1",
  "/\xC91\xD0",
  "3\xD75\xE0",
  "7\xED9\xF7",
  ";\u0100=\u0103",
  "?\u0105A\u0107C\u0109",
  "E\u0110G\u0114",
  "I\u0117K\u011F",
  "MN\x07ENO\x07qOP\x07o",
  "PQ\x07rQR\x07kRS\x07n",
  'ST\x07gTU\x07fUV\x07"VW\x07',
  "hWX\x07tXY\x07qYZ\x07o",
  "Z[\\\x07$\\",
  "]^\x07e^_\x07n_",
  "`\x07c`a\x07uab\x07ub\b",
  "cd\x07gde\x07zef\x07",
  "vfg\x07ggh\x07phi\x07f",
  "ij\x07uj\nkl\x07k",
  "lm\x07omn\x07rno\x07n",
  "op\x07gpq\x07oqr\x07grs\x07",
  "pst\x07vtu\x07uu\f",
  "vw\x07kwx\x07pxy\x07v",
  "yz\x07gz{\x07t{|\x07h",
  "|}\x07c}~\x07e~\x7F\x07g",
  "\x7F\x80\x81\x07r",
  "\x81\x82\x07w\x82\x83\x07d\x83",
  "\x84\x07n\x84\x85\x07k\x85\x86",
  "\x07e\x86\x87\x88",
  "\x07r\x88\x89\x07t\x89\x8A\x07",
  "k\x8A\x8B\x07x\x8B\x8C\x07c",
  "\x8C\x8D\x07v\x8D\x8E\x07g",
  "\x8E\x8F\x90\x07r",
  "\x90\x91\x07t\x91\x92\x07q\x92",
  "\x93\x07v\x93\x94\x07g\x94\x95",
  "\x07e\x95\x96\x07v\x96\x97\x07",
  "g\x97\x98\x07f\x98",
  "\x99\x9A\x07c\x9A\x9B\x07d",
  "\x9B\x9C\x07u\x9C\x9D\x07v",
  "\x9D\x9E\x07t\x9E\x9F\x07c\x9F",
  "\xA0\x07e\xA0\xA1\x07v\xA1",
  "\xA2\xA3\x07h\xA3\xA4",
  "\x07k\xA4\xA5\x07p\xA5\xA6\x07",
  "c\xA6\xA7\x07n\xA7",
  "\xA8\xA9\x07.\xA9",
  '\xAA\xAB\x07.\xAB\xAC\x07"',
  "\xAC\xAD\xAE\x070",
  "\xAE\xAF\xB0\x07>",
  "\xB0 \xB1\xB2\x07@",
  '\xB2"\xB3\xB4\x07(\xB4',
  "$\xB5\xB6\x07A\xB6&",
  "\xB7\xB8\x07u\xB8\xB9\x07",
  "w\xB9\xBA\x07r\xBA\xBB\x07g",
  "\xBB\xBC\x07t\xBC(",
  "\xBD\xBE\x07}\xBE*\xBF",
  "\xC0\x07\x7F\xC0,\xC1",
  "\xC2\x07f\xC2\xC3\x07g\xC3\xC4",
  "\x07h\xC4\xC5\x07c\xC5\xC6\x07",
  "w\xC6\xC7\x07n\xC7\xC8\x07v",
  "\xC8.\xC9\xCA\x07p",
  "\xCA\xCB\x07c\xCB\xCC\x07v\xCC",
  "\xCD\x07k\xCD\xCE\x07x\xCE\xCF",
  "\x07g\xCF0\xD0\xD1\x07",
  "u\xD1\xD2\x07v\xD2\xD3\x07c",
  "\xD3\xD4\x07v\xD4\xD5\x07k",
  "\xD5\xD6\x07e\xD62\xD7",
  "\xD8\x07u\xD8\xD9\x07v\xD9\xDA",
  "\x07t\xDA\xDB\x07k\xDB\xDC\x07",
  "e\xDC\xDD\x07v\xDD\xDE\x07h",
  "\xDE\xDF\x07r\xDF4",
  "\xE0\xE1\x07u\xE1\xE2\x07{\xE2",
  "\xE3\x07p\xE3\xE4\x07e\xE4\xE5",
  "\x07j\xE5\xE6\x07t\xE6\xE7\x07",
  "q\xE7\xE8\x07p\xE8\xE9\x07k",
  "\xE9\xEA\x07|\xEA\xEB\x07g",
  "\xEB\xEC\x07f\xEC6\xED",
  "\xEE\x07v\xEE\xEF\x07t\xEF\xF0",
  "\x07c\xF0\xF1\x07p\xF1\xF2\x07",
  "u\xF2\xF3\x07k\xF3\xF4\x07g",
  "\xF4\xF5\x07p\xF5\xF6\x07v",
  "\xF68\xF7\xF8\x07x\xF8",
  "\xF9\x07q\xF9\xFA\x07n\xFA\xFB",
  "\x07c\xFB\xFC\x07v\xFC\xFD\x07",
  "k\xFD\xFE\x07n\xFE\xFF\x07g",
  "\xFF:\u0100\u0101\x07}",
  "\u0101\u0102\x07\x7F\u0102<",
  "\u0103\u0104\x07=\u0104>\u0105",
  "\u0106\x07*\u0106@\u0107\u0108",
  "\x07+\u0108B\u0109\u010A\x07",
  "v\u010A\u010B\x07j\u010B\u010C\x07t",
  "\u010C\u010D\x07q\u010D\u010E\x07y",
  "\u010E\u010F\x07u\u010FD\u0110",
  "\u0111\x070\u0111\u0112\x070\u0112\u0113",
  "\x070\u0113F\u0114\u0115\x07",
  "]\u0115\u0116\x07_\u0116H",
  "\u0117\u011B	\u0118\u011A	",
  "\u0119\u0118\u011A\u011D",
  "\u011B\u0119\u011B\u011C",
  "\u011CJ\u011D\u011B",
  "\u011E\u0120	\u011F\u011E",
  "\u0120\u0121\u0121\u011F",
  "\u0121\u0122\u0122\u0123",
  "\u0123\u0124\b&\u0124L",
  "\u011B\u0121\b"
].join("");
var atn = new antlr4_default.atn.ATNDeserializer().deserialize(serializedATN);
var decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4_default.dfa.DFA(ds, index));
var JavapLexer = class extends antlr4_default.Lexer {
  constructor(input) {
    super(input);
    this._interp = new antlr4_default.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4_default.PredictionContextCache());
  }
  get atn() {
    return atn;
  }
};
__publicField(JavapLexer, "grammarFileName", "Javap.g4");
__publicField(JavapLexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);
__publicField(JavapLexer, "modeNames", ["DEFAULT_MODE"]);
__publicField(JavapLexer, "literalNames", [
  null,
  "'Compiled from'",
  `'"'`,
  "'class'",
  "'extends'",
  "'implements'",
  "'interface'",
  "'public'",
  "'private'",
  "'protected'",
  "'abstract'",
  "'final'",
  "','",
  "', '",
  "'.'",
  "'<'",
  "'>'",
  "'&'",
  "'?'",
  "'super'",
  "'{'",
  "'}'",
  "'default'",
  "'native'",
  "'static'",
  "'strictfp'",
  "'synchronized'",
  "'transient'",
  "'volatile'",
  "'{}'",
  "';'",
  "'('",
  "')'",
  "'throws'",
  "'...'",
  "'[]'"
]);
__publicField(JavapLexer, "symbolicNames", [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "Identifier",
  "WS"
]);
__publicField(JavapLexer, "ruleNames", [
  "T__0",
  "T__1",
  "T__2",
  "T__3",
  "T__4",
  "T__5",
  "T__6",
  "T__7",
  "T__8",
  "T__9",
  "T__10",
  "T__11",
  "T__12",
  "T__13",
  "T__14",
  "T__15",
  "T__16",
  "T__17",
  "T__18",
  "T__19",
  "T__20",
  "T__21",
  "T__22",
  "T__23",
  "T__24",
  "T__25",
  "T__26",
  "T__27",
  "T__28",
  "T__29",
  "T__30",
  "T__31",
  "T__32",
  "T__33",
  "T__34",
  "Identifier",
  "WS"
]);
JavapLexer.EOF = antlr4_default.Token.EOF;
JavapLexer.T__0 = 1;
JavapLexer.T__1 = 2;
JavapLexer.T__2 = 3;
JavapLexer.T__3 = 4;
JavapLexer.T__4 = 5;
JavapLexer.T__5 = 6;
JavapLexer.T__6 = 7;
JavapLexer.T__7 = 8;
JavapLexer.T__8 = 9;
JavapLexer.T__9 = 10;
JavapLexer.T__10 = 11;
JavapLexer.T__11 = 12;
JavapLexer.T__12 = 13;
JavapLexer.T__13 = 14;
JavapLexer.T__14 = 15;
JavapLexer.T__15 = 16;
JavapLexer.T__16 = 17;
JavapLexer.T__17 = 18;
JavapLexer.T__18 = 19;
JavapLexer.T__19 = 20;
JavapLexer.T__20 = 21;
JavapLexer.T__21 = 22;
JavapLexer.T__22 = 23;
JavapLexer.T__23 = 24;
JavapLexer.T__24 = 25;
JavapLexer.T__25 = 26;
JavapLexer.T__26 = 27;
JavapLexer.T__27 = 28;
JavapLexer.T__28 = 29;
JavapLexer.T__29 = 30;
JavapLexer.T__30 = 31;
JavapLexer.T__31 = 32;
JavapLexer.T__32 = 33;
JavapLexer.T__33 = 34;
JavapLexer.T__34 = 35;
JavapLexer.Identifier = 36;
JavapLexer.WS = 37;

// src/parser/javap/JavapListener.js
var JavapListener = class extends antlr4_default.tree.ParseTreeListener {
  // Enter a parse tree produced by JavapParser#compilationUnit.
  enterCompilationUnit(ctx) {
  }
  // Exit a parse tree produced by JavapParser#compilationUnit.
  exitCompilationUnit(ctx) {
  }
  // Enter a parse tree produced by JavapParser#sourceDeclaration.
  enterSourceDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#sourceDeclaration.
  exitSourceDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#classOrInterface.
  enterClassOrInterface(ctx) {
  }
  // Exit a parse tree produced by JavapParser#classOrInterface.
  exitClassOrInterface(ctx) {
  }
  // Enter a parse tree produced by JavapParser#classDeclaration.
  enterClassDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#classDeclaration.
  exitClassDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#interfaceDeclaration.
  enterInterfaceDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#interfaceDeclaration.
  exitInterfaceDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#classModifier.
  enterClassModifier(ctx) {
  }
  // Exit a parse tree produced by JavapParser#classModifier.
  exitClassModifier(ctx) {
  }
  // Enter a parse tree produced by JavapParser#interfaceModifier.
  enterInterfaceModifier(ctx) {
  }
  // Exit a parse tree produced by JavapParser#interfaceModifier.
  exitInterfaceModifier(ctx) {
  }
  // Enter a parse tree produced by JavapParser#typeList.
  enterTypeList(ctx) {
  }
  // Exit a parse tree produced by JavapParser#typeList.
  exitTypeList(ctx) {
  }
  // Enter a parse tree produced by JavapParser#type.
  enterType(ctx) {
  }
  // Exit a parse tree produced by JavapParser#type.
  exitType(ctx) {
  }
  // Enter a parse tree produced by JavapParser#subType.
  enterSubType(ctx) {
  }
  // Exit a parse tree produced by JavapParser#subType.
  exitSubType(ctx) {
  }
  // Enter a parse tree produced by JavapParser#packageName.
  enterPackageName(ctx) {
  }
  // Exit a parse tree produced by JavapParser#packageName.
  exitPackageName(ctx) {
  }
  // Enter a parse tree produced by JavapParser#typeArguments.
  enterTypeArguments(ctx) {
  }
  // Exit a parse tree produced by JavapParser#typeArguments.
  exitTypeArguments(ctx) {
  }
  // Enter a parse tree produced by JavapParser#typeArgument.
  enterTypeArgument(ctx) {
  }
  // Exit a parse tree produced by JavapParser#typeArgument.
  exitTypeArgument(ctx) {
  }
  // Enter a parse tree produced by JavapParser#classBody.
  enterClassBody(ctx) {
  }
  // Exit a parse tree produced by JavapParser#classBody.
  exitClassBody(ctx) {
  }
  // Enter a parse tree produced by JavapParser#interfaceBody.
  enterInterfaceBody(ctx) {
  }
  // Exit a parse tree produced by JavapParser#interfaceBody.
  exitInterfaceBody(ctx) {
  }
  // Enter a parse tree produced by JavapParser#modifier.
  enterModifier(ctx) {
  }
  // Exit a parse tree produced by JavapParser#modifier.
  exitModifier(ctx) {
  }
  // Enter a parse tree produced by JavapParser#classMember.
  enterClassMember(ctx) {
  }
  // Exit a parse tree produced by JavapParser#classMember.
  exitClassMember(ctx) {
  }
  // Enter a parse tree produced by JavapParser#interfaceMember.
  enterInterfaceMember(ctx) {
  }
  // Exit a parse tree produced by JavapParser#interfaceMember.
  exitInterfaceMember(ctx) {
  }
  // Enter a parse tree produced by JavapParser#constructorDeclaration.
  enterConstructorDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#constructorDeclaration.
  exitConstructorDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#fieldDeclaration.
  enterFieldDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#fieldDeclaration.
  exitFieldDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#methodDeclaration.
  enterMethodDeclaration(ctx) {
  }
  // Exit a parse tree produced by JavapParser#methodDeclaration.
  exitMethodDeclaration(ctx) {
  }
  // Enter a parse tree produced by JavapParser#throwsException.
  enterThrowsException(ctx) {
  }
  // Exit a parse tree produced by JavapParser#throwsException.
  exitThrowsException(ctx) {
  }
  // Enter a parse tree produced by JavapParser#varargs.
  enterVarargs(ctx) {
  }
  // Exit a parse tree produced by JavapParser#varargs.
  exitVarargs(ctx) {
  }
  // Enter a parse tree produced by JavapParser#methodArguments.
  enterMethodArguments(ctx) {
  }
  // Exit a parse tree produced by JavapParser#methodArguments.
  exitMethodArguments(ctx) {
  }
  // Enter a parse tree produced by JavapParser#arrayBrackets.
  enterArrayBrackets(ctx) {
  }
  // Exit a parse tree produced by JavapParser#arrayBrackets.
  exitArrayBrackets(ctx) {
  }
};

// src/parser/javap/JavapVisitor.js
var JavapVisitor = class extends antlr4_default.tree.ParseTreeVisitor {
  // Visit a parse tree produced by JavapParser#compilationUnit.
  visitCompilationUnit(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#sourceDeclaration.
  visitSourceDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#classOrInterface.
  visitClassOrInterface(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#classDeclaration.
  visitClassDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#interfaceDeclaration.
  visitInterfaceDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#classModifier.
  visitClassModifier(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#interfaceModifier.
  visitInterfaceModifier(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#typeList.
  visitTypeList(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#type.
  visitType(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#subType.
  visitSubType(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#packageName.
  visitPackageName(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#typeArguments.
  visitTypeArguments(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#typeArgument.
  visitTypeArgument(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#classBody.
  visitClassBody(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#interfaceBody.
  visitInterfaceBody(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#modifier.
  visitModifier(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#classMember.
  visitClassMember(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#interfaceMember.
  visitInterfaceMember(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#constructorDeclaration.
  visitConstructorDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#fieldDeclaration.
  visitFieldDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#methodDeclaration.
  visitMethodDeclaration(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#throwsException.
  visitThrowsException(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#varargs.
  visitVarargs(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#methodArguments.
  visitMethodArguments(ctx) {
    return this.visitChildren(ctx);
  }
  // Visit a parse tree produced by JavapParser#arrayBrackets.
  visitArrayBrackets(ctx) {
    return this.visitChildren(ctx);
  }
};

// src/parser/javap/JavapParser.js
var serializedATN2 = [
  "\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786",
  "\u5964'\u0128		",
  "			\x07	\x07",
  "\b	\b			\n	\n\v	\v\f	\f",
  "\r	\r			",
  "			",
  "				",
  "			",
  "\x077\n\f:\v",
  "=\n\x07",
  "B\n\fE\v",
  "K\n\x07",
  "N\n\fQ\v",
  "W\n",
  "[\n\x07`\n",
  "\fc\v",
  "i\n\x07",
  "\x07\b\b			\x07	t\n	\f",
  "		w\v	\n\n\n\n|\n\n\n",
  "\n\n\x80\n\n\n\n\x83\n\n\v\v",
  "\v\v\x88\n\v\f\f\f\x07",
  "\f\x8D\n\f\f\f\f\x90\v\f\r\r\x93\n\r\r\r",
  "\r\x94\r\r\r\r\x07\r\x9B\n\r\f\r",
  "\r\x9E\v\r\r\r\x07\r\xA2\n\r\f\r\r",
  "\xA5\v\r\r\xA7\n\r",
  "\x07\xAF\n\f",
  "\xB2\v",
  "\x07\xB9\n\f\xBC",
  "\v",
  "\xC2\n\x07\xC6\n\f",
  "\xC9\v",
  "\x07\xCF\n\f\xD2\v",
  "",
  "\xDE\n",
  "",
  "\xE5\n\x07\xE8\n\f",
  "\xEB\v\xEE\n",
  "\xF5",
  "\n\x07\xFA\n",
  "\f\xFD\v",
  "\x07\u0104\n\f",
  "\u0107\v\u010A\n",
  "",
  "\u0112\n",
  "",
  "\u011D\n",
  "\u0124\n",
  "C\x1B\b\n\f",
  ' "$&(*,.02	',
  "\r	\v	\r",
  "\u01398>",
  "J\bO",
  "\na\fln",
  "p{",
  "\x84\x89",
  "\xA6\xC1",
  "\xC3\xCC",
  ' \xD5"\xDD',
  "$\xE4&\xE9",
  "(\xFB*\u0105,\u0115",
  ".\u01180\u0123",
  "2\u012547",
  "576465",
  "7:8689",
  "9<:8",
  ";=\x07<;<=",
  "=>?\x07?C\x07",
  "@B\vA@",
  "BECDCA",
  "DFECFG\x07",
  "GHK\bIK",
  "\nJHJI",
  "K\x07LN\f\x07ML",
  "NQOMOP",
  "PRQO",
  "RS\x07SV\nTU\x07",
  "UW\nVTVW",
  "WZXY\x07\x07Y[",
  "	ZXZ[[",
  "\\\\]]	",
  "^`\b_^`c",
  "a_ab",
  "bdcade\x07\b",
  "eh\nfg\x07gi",
  "	hfhiij",
  "jkk\v",
  "lm	m\rno	",
  "opu\nqr	",
  "rt\nsqtw",
  "usuv",
  "vwuxy",
  "\fyz\x07z|{x",
  "{||}",
  "}\x7F\x07&~\x80\r\x7F~",
  "\x7F\x80\x80\x82",
  "\x81\x83\v\x82\x81",
  "\x82\x83\x83",
  "\x84\x85\x07\x85\x87\x07&",
  "\x86\x88\r\x87\x86",
  "\x87\x88\x88",
  "\x89\x8E\x07&\x8A\x8B\x07",
  "\x8B\x8D\x07&\x8C\x8A",
  "\x8D\x90\x8E\x8C",
  "\x8E\x8F\x8F",
  "\x90\x8E\x91\x932",
  "\x92\x91\x93\x94",
  "\x94\x92\x94\x95",
  "\x95\xA7\x96\x97\x07",
  "\x97\x9C\x98\x99	",
  "\x99\x9B\x9A\x98",
  "\x9B\x9E\x9C\x9A",
  "\x9C\x9D\x9D\x9F",
  "\x9E\x9C\x9F\xA3\x07",
  "\xA0\xA22\xA1\xA0",
  "\xA2\xA5\xA3\xA1",
  "\xA3\xA4\xA4\xA7",
  "\xA5\xA3\xA6\x92",
  "\xA6\x96\xA7",
  "\xA8\xC2\n\xA9\xAA\x07&",
  "\xAA\xAB\x07\xAB\xB0\n",
  "\xAC\xAD\x07\xAD\xAF\n",
  "\xAE\xAC\xAF\xB2",
  "\xB0\xAE\xB0\xB1",
  "\xB1\xC2\xB2\xB0",
  "\xB3\xB4\x07\xB4\xB5\x07",
  "\xB5\xBA\n\xB6\xB7\x07",
  "\xB7\xB9\n\xB8\xB6",
  "\xB9\xBC\xBA\xB8",
  "\xBA\xBB\xBB\xC2",
  "\xBC\xBA\xBD\xBE\x07",
  "\xBE\xBF\x07\xBF\xC2\n",
  "\xC0\xC2\x07\xC1\xA8",
  "\xC1\xA9\xC1\xB3",
  "\xC1\xBD\xC1\xC0",
  "\xC2\x1B\xC3\xC7\x07",
  '\xC4\xC6"\xC5\xC4',
  "\xC6\xC9\xC7\xC5",
  "\xC7\xC8\xC8\xCA",
  "\xC9\xC7\xCA\xCB\x07",
  "\xCB\xCC\xD0\x07",
  "\xCD\xCF$\xCE\xCD",
  "\xCF\xD2\xD0\xCE",
  "\xD0\xD1\xD1\xD3",
  "\xD2\xD0\xD3\xD4\x07",
  "\xD4\xD5\xD6	",
  "\xD6!\xD7\xDE&",
  "\xD8\xDE(\xD9\xDE*\xDA",
  "\xDB\x07\xDB\xDC\x07\xDC",
  "\xDE\x07 \xDD\xD7\xDD",
  "\xD8\xDD\xD9\xDD",
  "\xDA\xDE#\xDF",
  "\xE5(\xE0\xE5*\xE1\xE2",
  "\x07\xE2\xE3\x07\xE3\xE5",
  "\x07 \xE4\xDF\xE4\xE0",
  "\xE4\xE1\xE5%",
  "\xE6\xE8 \xE7\xE6",
  "\xE8\xEB\xE9\xE7",
  "\xE9\xEA\xEA\xED",
  "\xEB\xE9\xEC\xEE",
  "\r\xED\xEC\xED\xEE",
  "\xEE\xEF\xEF\xF0",
  "\n\xF0\xF1\x07!\xF1\xF2",
  '0\xF2\xF4\x07"\xF3\xF5,',
  "\xF4\xF3\xF4\xF5",
  "\xF5\xF6\xF6\xF7\x07 ",
  "\xF7'\xF8\xFA ",
  "\xF9\xF8\xFA\xFD",
  "\xFB\xF9\xFB\xFC",
  "\xFC\xFE\xFD\xFB",
  "\xFE\xFF\n\xFF\u0100\x07&\u0100",
  "\u0101\x07 \u0101)\u0102\u0104",
  " \u0103\u0102\u0104\u0107",
  "\u0105\u0103\u0105\u0106",
  "\u0106\u0109\u0107\u0105",
  "\u0108\u010A\r\u0109\u0108",
  "\u0109\u010A\u010A\u010B",
  "\u010B\u010C\n\u010C\u010D",
  "\x07&\u010D\u010E\x07!\u010E\u010F",
  '0\u010F\u0111\x07"\u0110\u0112,',
  "\u0111\u0110\u0111\u0112",
  "\u0112\u0113\u0113\u0114\x07 ",
  "\u0114+\u0115\u0116\x07#",
  "\u0116\u0117	\u0117-\u0118",
  "\u0119\n\u0119\u011A\x07$\u011A/",
  "\u011B\u011D	\u011C\u011B",
  "\u011C\u011D\u011D\u0124",
  "\u011E\u011F	\u011F\u0120	",
  "\u0120\u0121.\u0121\u0124",
  "\u0122\u0124.\u0123\u011C",
  "\u0123\u011E\u0123\u0122",
  "\u01241\u0125\u0126\x07%",
  "\u01263&68<CJOVZahu{\x7F\x82\x87",
  "\x8E\x94\x9C\xA3\xA6\xB0\xBA\xC1\xC7\xD0\xDD\xE4",
  "\xE9\xED\xF4\xFB\u0105\u0109\u0111\u011C\u0123"
].join("");
var atn2 = new antlr4_default.atn.ATNDeserializer().deserialize(serializedATN2);
var decisionsToDFA2 = atn2.decisionToState.map((ds, index) => new antlr4_default.dfa.DFA(ds, index));
var sharedContextCache = new antlr4_default.PredictionContextCache();
var _JavapParser = class extends antlr4_default.Parser {
  constructor(input) {
    super(input);
    this._interp = new antlr4_default.atn.ParserATNSimulator(this, atn2, decisionsToDFA2, sharedContextCache);
    this.ruleNames = _JavapParser.ruleNames;
    this.literalNames = _JavapParser.literalNames;
    this.symbolicNames = _JavapParser.symbolicNames;
  }
  get atn() {
    return atn2;
  }
  compilationUnit() {
    let localctx = new CompilationUnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, _JavapParser.RULE_compilationUnit);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 54;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__0 | 1 << _JavapParser.T__2 | 1 << _JavapParser.T__5 | 1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10)) !== 0) {
        this.state = 52;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _JavapParser.T__0:
            this.state = 50;
            this.sourceDeclaration();
            break;
          case _JavapParser.T__2:
          case _JavapParser.T__5:
          case _JavapParser.T__6:
          case _JavapParser.T__7:
          case _JavapParser.T__8:
          case _JavapParser.T__9:
          case _JavapParser.T__10:
            this.state = 51;
            this.classOrInterface();
            break;
          default:
            throw new antlr4_default.error.NoViableAltException(this);
        }
        this.state = 56;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 58;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 2, this._ctx);
      if (la_ === 1) {
        this.state = 57;
        this.match(_JavapParser.EOF);
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  sourceDeclaration() {
    let localctx = new SourceDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, _JavapParser.RULE_sourceDeclaration);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 60;
      this.match(_JavapParser.T__0);
      this.state = 61;
      this.match(_JavapParser.T__1);
      this.state = 65;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 3, this._ctx);
      while (_alt != 1 && _alt != antlr4_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1 + 1) {
          this.state = 62;
          this.matchWildcard();
        }
        this.state = 67;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 3, this._ctx);
      }
      this.state = 68;
      this.match(_JavapParser.T__1);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  classOrInterface() {
    let localctx = new ClassOrInterfaceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, _JavapParser.RULE_classOrInterface);
    try {
      this.state = 72;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 4, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 70;
          this.classDeclaration();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 71;
          this.interfaceDeclaration();
          break;
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  classDeclaration() {
    let localctx = new ClassDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, _JavapParser.RULE_classDeclaration);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 77;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10)) !== 0) {
        this.state = 74;
        this.classModifier();
        this.state = 79;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 80;
      this.match(_JavapParser.T__2);
      this.state = 81;
      this.type();
      this.state = 84;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__3) {
        this.state = 82;
        this.match(_JavapParser.T__3);
        this.state = 83;
        this.type();
      }
      this.state = 88;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__4) {
        this.state = 86;
        this.match(_JavapParser.T__4);
        this.state = 87;
        this.typeList();
      }
      this.state = 90;
      this.classBody();
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  interfaceDeclaration() {
    let localctx = new InterfaceDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, _JavapParser.RULE_interfaceDeclaration);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 95;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8)) !== 0) {
        this.state = 92;
        this.interfaceModifier();
        this.state = 97;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 98;
      this.match(_JavapParser.T__5);
      this.state = 99;
      this.type();
      this.state = 102;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__3) {
        this.state = 100;
        this.match(_JavapParser.T__3);
        this.state = 101;
        this.typeList();
      }
      this.state = 104;
      this.interfaceBody();
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  classModifier() {
    let localctx = new ClassModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, _JavapParser.RULE_classModifier);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 106;
      _la = this._input.LA(1);
      if (!((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  interfaceModifier() {
    let localctx = new InterfaceModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, _JavapParser.RULE_interfaceModifier);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 108;
      _la = this._input.LA(1);
      if (!((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  typeList() {
    let localctx = new TypeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, _JavapParser.RULE_typeList);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 110;
      this.type();
      this.state = 115;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 10, this._ctx);
      while (_alt != 2 && _alt != antlr4_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 111;
          _la = this._input.LA(1);
          if (!(_la === _JavapParser.T__11 || _la === _JavapParser.T__12)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 112;
          this.type();
        }
        this.state = 117;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 10, this._ctx);
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  type() {
    let localctx = new TypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, _JavapParser.RULE_type);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 121;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 11, this._ctx);
      if (la_ === 1) {
        this.state = 118;
        this.packageName();
        this.state = 119;
        this.match(_JavapParser.T__13);
      }
      this.state = 123;
      this.match(_JavapParser.Identifier);
      this.state = 125;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__14 || _la === _JavapParser.T__34) {
        this.state = 124;
        this.typeArguments();
      }
      this.state = 128;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__13) {
        this.state = 127;
        this.subType();
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  subType() {
    let localctx = new SubTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, _JavapParser.RULE_subType);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 130;
      this.match(_JavapParser.T__13);
      this.state = 131;
      this.match(_JavapParser.Identifier);
      this.state = 133;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__14 || _la === _JavapParser.T__34) {
        this.state = 132;
        this.typeArguments();
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  packageName() {
    let localctx = new PackageNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, _JavapParser.RULE_packageName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 135;
      this.match(_JavapParser.Identifier);
      this.state = 140;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 15, this._ctx);
      while (_alt != 2 && _alt != antlr4_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 136;
          this.match(_JavapParser.T__13);
          this.state = 137;
          this.match(_JavapParser.Identifier);
        }
        this.state = 142;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 15, this._ctx);
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  typeArguments() {
    let localctx = new TypeArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, _JavapParser.RULE_typeArguments);
    var _la = 0;
    try {
      this.state = 164;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _JavapParser.T__34:
          this.enterOuterAlt(localctx, 1);
          this.state = 144;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          do {
            this.state = 143;
            this.arrayBrackets();
            this.state = 146;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          } while (_la === _JavapParser.T__34);
          break;
        case _JavapParser.T__14:
          this.enterOuterAlt(localctx, 2);
          this.state = 148;
          this.match(_JavapParser.T__14);
          this.state = 149;
          this.typeArgument();
          this.state = 154;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _JavapParser.T__11 || _la === _JavapParser.T__12) {
            this.state = 150;
            _la = this._input.LA(1);
            if (!(_la === _JavapParser.T__11 || _la === _JavapParser.T__12)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 151;
            this.typeArgument();
            this.state = 156;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 157;
          this.match(_JavapParser.T__15);
          this.state = 161;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _JavapParser.T__34) {
            this.state = 158;
            this.arrayBrackets();
            this.state = 163;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          break;
        default:
          throw new antlr4_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  typeArgument() {
    let localctx = new TypeArgumentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, _JavapParser.RULE_typeArgument);
    var _la = 0;
    try {
      this.state = 191;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 22, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 166;
          this.type();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 167;
          this.match(_JavapParser.Identifier);
          this.state = 168;
          this.match(_JavapParser.T__3);
          this.state = 169;
          this.type();
          this.state = 174;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _JavapParser.T__16) {
            this.state = 170;
            this.match(_JavapParser.T__16);
            this.state = 171;
            this.type();
            this.state = 176;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 177;
          this.match(_JavapParser.T__17);
          this.state = 178;
          this.match(_JavapParser.T__3);
          this.state = 179;
          this.type();
          this.state = 184;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _JavapParser.T__16) {
            this.state = 180;
            this.match(_JavapParser.T__16);
            this.state = 181;
            this.type();
            this.state = 186;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 187;
          this.match(_JavapParser.T__17);
          this.state = 188;
          this.match(_JavapParser.T__18);
          this.state = 189;
          this.type();
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 190;
          this.match(_JavapParser.T__17);
          break;
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  classBody() {
    let localctx = new ClassBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, _JavapParser.RULE_classBody);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 193;
      this.match(_JavapParser.T__19);
      this.state = 197;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la - 7 & ~31) == 0 && (1 << _la - 7 & (1 << _JavapParser.T__6 - 7 | 1 << _JavapParser.T__7 - 7 | 1 << _JavapParser.T__8 - 7 | 1 << _JavapParser.T__9 - 7 | 1 << _JavapParser.T__10 - 7 | 1 << _JavapParser.T__14 - 7 | 1 << _JavapParser.T__21 - 7 | 1 << _JavapParser.T__22 - 7 | 1 << _JavapParser.T__23 - 7 | 1 << _JavapParser.T__24 - 7 | 1 << _JavapParser.T__25 - 7 | 1 << _JavapParser.T__26 - 7 | 1 << _JavapParser.T__27 - 7 | 1 << _JavapParser.T__34 - 7 | 1 << _JavapParser.Identifier - 7)) !== 0) {
        this.state = 194;
        this.classMember();
        this.state = 199;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 200;
      this.match(_JavapParser.T__20);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  interfaceBody() {
    let localctx = new InterfaceBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, _JavapParser.RULE_interfaceBody);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 202;
      this.match(_JavapParser.T__19);
      this.state = 206;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la - 7 & ~31) == 0 && (1 << _la - 7 & (1 << _JavapParser.T__6 - 7 | 1 << _JavapParser.T__7 - 7 | 1 << _JavapParser.T__8 - 7 | 1 << _JavapParser.T__9 - 7 | 1 << _JavapParser.T__10 - 7 | 1 << _JavapParser.T__14 - 7 | 1 << _JavapParser.T__21 - 7 | 1 << _JavapParser.T__22 - 7 | 1 << _JavapParser.T__23 - 7 | 1 << _JavapParser.T__24 - 7 | 1 << _JavapParser.T__25 - 7 | 1 << _JavapParser.T__26 - 7 | 1 << _JavapParser.T__27 - 7 | 1 << _JavapParser.T__34 - 7 | 1 << _JavapParser.Identifier - 7)) !== 0) {
        this.state = 203;
        this.interfaceMember();
        this.state = 208;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 209;
      this.match(_JavapParser.T__20);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  modifier() {
    let localctx = new ModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, _JavapParser.RULE_modifier);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 211;
      _la = this._input.LA(1);
      if (!((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10 | 1 << _JavapParser.T__21 | 1 << _JavapParser.T__22 | 1 << _JavapParser.T__23 | 1 << _JavapParser.T__24 | 1 << _JavapParser.T__25 | 1 << _JavapParser.T__26 | 1 << _JavapParser.T__27)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  classMember() {
    let localctx = new ClassMemberContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, _JavapParser.RULE_classMember);
    try {
      this.state = 219;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 25, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 213;
          this.constructorDeclaration();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 214;
          this.fieldDeclaration();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 215;
          this.methodDeclaration();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 216;
          this.match(_JavapParser.T__23);
          this.state = 217;
          this.match(_JavapParser.T__28);
          this.state = 218;
          this.match(_JavapParser.T__29);
          break;
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  interfaceMember() {
    let localctx = new InterfaceMemberContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, _JavapParser.RULE_interfaceMember);
    try {
      this.state = 226;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 26, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 221;
          this.fieldDeclaration();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 222;
          this.methodDeclaration();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 223;
          this.match(_JavapParser.T__23);
          this.state = 224;
          this.match(_JavapParser.T__28);
          this.state = 225;
          this.match(_JavapParser.T__29);
          break;
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  constructorDeclaration() {
    let localctx = new ConstructorDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, _JavapParser.RULE_constructorDeclaration);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 231;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10 | 1 << _JavapParser.T__21 | 1 << _JavapParser.T__22 | 1 << _JavapParser.T__23 | 1 << _JavapParser.T__24 | 1 << _JavapParser.T__25 | 1 << _JavapParser.T__26 | 1 << _JavapParser.T__27)) !== 0) {
        this.state = 228;
        this.modifier();
        this.state = 233;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 235;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__14 || _la === _JavapParser.T__34) {
        this.state = 234;
        this.typeArguments();
      }
      this.state = 237;
      this.type();
      this.state = 238;
      this.match(_JavapParser.T__30);
      this.state = 239;
      this.methodArguments();
      this.state = 240;
      this.match(_JavapParser.T__31);
      this.state = 242;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__32) {
        this.state = 241;
        this.throwsException();
      }
      this.state = 244;
      this.match(_JavapParser.T__29);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  fieldDeclaration() {
    let localctx = new FieldDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, _JavapParser.RULE_fieldDeclaration);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 249;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10 | 1 << _JavapParser.T__21 | 1 << _JavapParser.T__22 | 1 << _JavapParser.T__23 | 1 << _JavapParser.T__24 | 1 << _JavapParser.T__25 | 1 << _JavapParser.T__26 | 1 << _JavapParser.T__27)) !== 0) {
        this.state = 246;
        this.modifier();
        this.state = 251;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 252;
      this.type();
      this.state = 253;
      this.match(_JavapParser.Identifier);
      this.state = 254;
      this.match(_JavapParser.T__29);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  methodDeclaration() {
    let localctx = new MethodDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, _JavapParser.RULE_methodDeclaration);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 259;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la & ~31) == 0 && (1 << _la & (1 << _JavapParser.T__6 | 1 << _JavapParser.T__7 | 1 << _JavapParser.T__8 | 1 << _JavapParser.T__9 | 1 << _JavapParser.T__10 | 1 << _JavapParser.T__21 | 1 << _JavapParser.T__22 | 1 << _JavapParser.T__23 | 1 << _JavapParser.T__24 | 1 << _JavapParser.T__25 | 1 << _JavapParser.T__26 | 1 << _JavapParser.T__27)) !== 0) {
        this.state = 256;
        this.modifier();
        this.state = 261;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 263;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__14 || _la === _JavapParser.T__34) {
        this.state = 262;
        this.typeArguments();
      }
      this.state = 265;
      this.type();
      this.state = 266;
      this.match(_JavapParser.Identifier);
      this.state = 267;
      this.match(_JavapParser.T__30);
      this.state = 268;
      this.methodArguments();
      this.state = 269;
      this.match(_JavapParser.T__31);
      this.state = 271;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _JavapParser.T__32) {
        this.state = 270;
        this.throwsException();
      }
      this.state = 273;
      this.match(_JavapParser.T__29);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  throwsException() {
    let localctx = new ThrowsExceptionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, _JavapParser.RULE_throwsException);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 275;
      this.match(_JavapParser.T__32);
      this.state = 276;
      this.typeList();
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  varargs() {
    let localctx = new VarargsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, _JavapParser.RULE_varargs);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 278;
      this.type();
      this.state = 279;
      this.match(_JavapParser.T__33);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  methodArguments() {
    let localctx = new MethodArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, _JavapParser.RULE_methodArguments);
    var _la = 0;
    try {
      this.state = 289;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 35, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 282;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _JavapParser.Identifier) {
            this.state = 281;
            this.typeList();
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 284;
          this.typeList();
          this.state = 285;
          _la = this._input.LA(1);
          if (!(_la === _JavapParser.T__11 || _la === _JavapParser.T__12)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 286;
          this.varargs();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 288;
          this.varargs();
          break;
      }
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  arrayBrackets() {
    let localctx = new ArrayBracketsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, _JavapParser.RULE_arrayBrackets);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 291;
      this.match(_JavapParser.T__34);
    } catch (re) {
      if (re instanceof antlr4_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
};
var JavapParser = _JavapParser;
__publicField(JavapParser, "grammarFileName", "Javap.g4");
__publicField(JavapParser, "literalNames", [
  null,
  "'Compiled from'",
  `'"'`,
  "'class'",
  "'extends'",
  "'implements'",
  "'interface'",
  "'public'",
  "'private'",
  "'protected'",
  "'abstract'",
  "'final'",
  "','",
  "', '",
  "'.'",
  "'<'",
  "'>'",
  "'&'",
  "'?'",
  "'super'",
  "'{'",
  "'}'",
  "'default'",
  "'native'",
  "'static'",
  "'strictfp'",
  "'synchronized'",
  "'transient'",
  "'volatile'",
  "'{}'",
  "';'",
  "'('",
  "')'",
  "'throws'",
  "'...'",
  "'[]'"
]);
__publicField(JavapParser, "symbolicNames", [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "Identifier",
  "WS"
]);
__publicField(JavapParser, "ruleNames", [
  "compilationUnit",
  "sourceDeclaration",
  "classOrInterface",
  "classDeclaration",
  "interfaceDeclaration",
  "classModifier",
  "interfaceModifier",
  "typeList",
  "type",
  "subType",
  "packageName",
  "typeArguments",
  "typeArgument",
  "classBody",
  "interfaceBody",
  "modifier",
  "classMember",
  "interfaceMember",
  "constructorDeclaration",
  "fieldDeclaration",
  "methodDeclaration",
  "throwsException",
  "varargs",
  "methodArguments",
  "arrayBrackets"
]);
JavapParser.EOF = antlr4_default.Token.EOF;
JavapParser.T__0 = 1;
JavapParser.T__1 = 2;
JavapParser.T__2 = 3;
JavapParser.T__3 = 4;
JavapParser.T__4 = 5;
JavapParser.T__5 = 6;
JavapParser.T__6 = 7;
JavapParser.T__7 = 8;
JavapParser.T__8 = 9;
JavapParser.T__9 = 10;
JavapParser.T__10 = 11;
JavapParser.T__11 = 12;
JavapParser.T__12 = 13;
JavapParser.T__13 = 14;
JavapParser.T__14 = 15;
JavapParser.T__15 = 16;
JavapParser.T__16 = 17;
JavapParser.T__17 = 18;
JavapParser.T__18 = 19;
JavapParser.T__19 = 20;
JavapParser.T__20 = 21;
JavapParser.T__21 = 22;
JavapParser.T__22 = 23;
JavapParser.T__23 = 24;
JavapParser.T__24 = 25;
JavapParser.T__25 = 26;
JavapParser.T__26 = 27;
JavapParser.T__27 = 28;
JavapParser.T__28 = 29;
JavapParser.T__29 = 30;
JavapParser.T__30 = 31;
JavapParser.T__31 = 32;
JavapParser.T__32 = 33;
JavapParser.T__33 = 34;
JavapParser.T__34 = 35;
JavapParser.Identifier = 36;
JavapParser.WS = 37;
JavapParser.RULE_compilationUnit = 0;
JavapParser.RULE_sourceDeclaration = 1;
JavapParser.RULE_classOrInterface = 2;
JavapParser.RULE_classDeclaration = 3;
JavapParser.RULE_interfaceDeclaration = 4;
JavapParser.RULE_classModifier = 5;
JavapParser.RULE_interfaceModifier = 6;
JavapParser.RULE_typeList = 7;
JavapParser.RULE_type = 8;
JavapParser.RULE_subType = 9;
JavapParser.RULE_packageName = 10;
JavapParser.RULE_typeArguments = 11;
JavapParser.RULE_typeArgument = 12;
JavapParser.RULE_classBody = 13;
JavapParser.RULE_interfaceBody = 14;
JavapParser.RULE_modifier = 15;
JavapParser.RULE_classMember = 16;
JavapParser.RULE_interfaceMember = 17;
JavapParser.RULE_constructorDeclaration = 18;
JavapParser.RULE_fieldDeclaration = 19;
JavapParser.RULE_methodDeclaration = 20;
JavapParser.RULE_throwsException = 21;
JavapParser.RULE_varargs = 22;
JavapParser.RULE_methodArguments = 23;
JavapParser.RULE_arrayBrackets = 24;
var CompilationUnitContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "sourceDeclaration", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(SourceDeclarationContext);
      } else {
        return this.getTypedRuleContext(SourceDeclarationContext, i);
      }
    });
    __publicField(this, "classOrInterface", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ClassOrInterfaceContext);
      } else {
        return this.getTypedRuleContext(ClassOrInterfaceContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_compilationUnit;
  }
  EOF() {
    return this.getToken(JavapParser.EOF, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterCompilationUnit(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitCompilationUnit(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitCompilationUnit(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SourceDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_sourceDeclaration;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterSourceDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitSourceDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitSourceDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ClassOrInterfaceContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_classOrInterface;
  }
  classDeclaration() {
    return this.getTypedRuleContext(ClassDeclarationContext, 0);
  }
  interfaceDeclaration() {
    return this.getTypedRuleContext(InterfaceDeclarationContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterClassOrInterface(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitClassOrInterface(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitClassOrInterface(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ClassDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "type", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(TypeContext);
      } else {
        return this.getTypedRuleContext(TypeContext, i);
      }
    });
    __publicField(this, "classModifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ClassModifierContext);
      } else {
        return this.getTypedRuleContext(ClassModifierContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_classDeclaration;
  }
  classBody() {
    return this.getTypedRuleContext(ClassBodyContext, 0);
  }
  typeList() {
    return this.getTypedRuleContext(TypeListContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterClassDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitClassDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitClassDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InterfaceDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "interfaceModifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(InterfaceModifierContext);
      } else {
        return this.getTypedRuleContext(InterfaceModifierContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_interfaceDeclaration;
  }
  type() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  interfaceBody() {
    return this.getTypedRuleContext(InterfaceBodyContext, 0);
  }
  typeList() {
    return this.getTypedRuleContext(TypeListContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterInterfaceDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitInterfaceDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitInterfaceDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ClassModifierContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_classModifier;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterClassModifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitClassModifier(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitClassModifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InterfaceModifierContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_interfaceModifier;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterInterfaceModifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitInterfaceModifier(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitInterfaceModifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeListContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "type", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(TypeContext);
      } else {
        return this.getTypedRuleContext(TypeContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_typeList;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterTypeList(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitTypeList(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitTypeList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_type;
  }
  Identifier() {
    return this.getToken(JavapParser.Identifier, 0);
  }
  packageName() {
    return this.getTypedRuleContext(PackageNameContext, 0);
  }
  typeArguments() {
    return this.getTypedRuleContext(TypeArgumentsContext, 0);
  }
  subType() {
    return this.getTypedRuleContext(SubTypeContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterType(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitType(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitType(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SubTypeContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_subType;
  }
  Identifier() {
    return this.getToken(JavapParser.Identifier, 0);
  }
  typeArguments() {
    return this.getTypedRuleContext(TypeArgumentsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterSubType(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitSubType(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitSubType(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PackageNameContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "Identifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTokens(JavapParser.Identifier);
      } else {
        return this.getToken(JavapParser.Identifier, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_packageName;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterPackageName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitPackageName(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitPackageName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeArgumentsContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "arrayBrackets", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ArrayBracketsContext);
      } else {
        return this.getTypedRuleContext(ArrayBracketsContext, i);
      }
    });
    __publicField(this, "typeArgument", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(TypeArgumentContext);
      } else {
        return this.getTypedRuleContext(TypeArgumentContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_typeArguments;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterTypeArguments(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitTypeArguments(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitTypeArguments(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeArgumentContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "type", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(TypeContext);
      } else {
        return this.getTypedRuleContext(TypeContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_typeArgument;
  }
  Identifier() {
    return this.getToken(JavapParser.Identifier, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterTypeArgument(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitTypeArgument(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitTypeArgument(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ClassBodyContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "classMember", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ClassMemberContext);
      } else {
        return this.getTypedRuleContext(ClassMemberContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_classBody;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterClassBody(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitClassBody(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitClassBody(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InterfaceBodyContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "interfaceMember", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(InterfaceMemberContext);
      } else {
        return this.getTypedRuleContext(InterfaceMemberContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_interfaceBody;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterInterfaceBody(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitInterfaceBody(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitInterfaceBody(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ModifierContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_modifier;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterModifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitModifier(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitModifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ClassMemberContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_classMember;
  }
  constructorDeclaration() {
    return this.getTypedRuleContext(ConstructorDeclarationContext, 0);
  }
  fieldDeclaration() {
    return this.getTypedRuleContext(FieldDeclarationContext, 0);
  }
  methodDeclaration() {
    return this.getTypedRuleContext(MethodDeclarationContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterClassMember(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitClassMember(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitClassMember(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InterfaceMemberContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_interfaceMember;
  }
  fieldDeclaration() {
    return this.getTypedRuleContext(FieldDeclarationContext, 0);
  }
  methodDeclaration() {
    return this.getTypedRuleContext(MethodDeclarationContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterInterfaceMember(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitInterfaceMember(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitInterfaceMember(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ConstructorDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "modifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ModifierContext);
      } else {
        return this.getTypedRuleContext(ModifierContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_constructorDeclaration;
  }
  type() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  methodArguments() {
    return this.getTypedRuleContext(MethodArgumentsContext, 0);
  }
  typeArguments() {
    return this.getTypedRuleContext(TypeArgumentsContext, 0);
  }
  throwsException() {
    return this.getTypedRuleContext(ThrowsExceptionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterConstructorDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitConstructorDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitConstructorDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FieldDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "modifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ModifierContext);
      } else {
        return this.getTypedRuleContext(ModifierContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_fieldDeclaration;
  }
  type() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  Identifier() {
    return this.getToken(JavapParser.Identifier, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterFieldDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitFieldDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitFieldDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MethodDeclarationContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    __publicField(this, "modifier", function(i) {
      if (i === void 0) {
        i = null;
      }
      if (i === null) {
        return this.getTypedRuleContexts(ModifierContext);
      } else {
        return this.getTypedRuleContext(ModifierContext, i);
      }
    });
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_methodDeclaration;
  }
  type() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  Identifier() {
    return this.getToken(JavapParser.Identifier, 0);
  }
  methodArguments() {
    return this.getTypedRuleContext(MethodArgumentsContext, 0);
  }
  typeArguments() {
    return this.getTypedRuleContext(TypeArgumentsContext, 0);
  }
  throwsException() {
    return this.getTypedRuleContext(ThrowsExceptionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterMethodDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitMethodDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitMethodDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ThrowsExceptionContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_throwsException;
  }
  typeList() {
    return this.getTypedRuleContext(TypeListContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterThrowsException(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitThrowsException(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitThrowsException(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VarargsContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_varargs;
  }
  type() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterVarargs(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitVarargs(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitVarargs(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MethodArgumentsContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_methodArguments;
  }
  typeList() {
    return this.getTypedRuleContext(TypeListContext, 0);
  }
  varargs() {
    return this.getTypedRuleContext(VarargsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterMethodArguments(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitMethodArguments(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitMethodArguments(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ArrayBracketsContext = class extends antlr4_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavapParser.RULE_arrayBrackets;
  }
  enterRule(listener) {
    if (listener instanceof JavapListener) {
      listener.enterArrayBrackets(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof JavapListener) {
      listener.exitArrayBrackets(this);
    }
  }
  accept(visitor) {
    if (visitor instanceof JavapVisitor) {
      return visitor.visitArrayBrackets(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
JavapParser.CompilationUnitContext = CompilationUnitContext;
JavapParser.SourceDeclarationContext = SourceDeclarationContext;
JavapParser.ClassOrInterfaceContext = ClassOrInterfaceContext;
JavapParser.ClassDeclarationContext = ClassDeclarationContext;
JavapParser.InterfaceDeclarationContext = InterfaceDeclarationContext;
JavapParser.ClassModifierContext = ClassModifierContext;
JavapParser.InterfaceModifierContext = InterfaceModifierContext;
JavapParser.TypeListContext = TypeListContext;
JavapParser.TypeContext = TypeContext;
JavapParser.SubTypeContext = SubTypeContext;
JavapParser.PackageNameContext = PackageNameContext;
JavapParser.TypeArgumentsContext = TypeArgumentsContext;
JavapParser.TypeArgumentContext = TypeArgumentContext;
JavapParser.ClassBodyContext = ClassBodyContext;
JavapParser.InterfaceBodyContext = InterfaceBodyContext;
JavapParser.ModifierContext = ModifierContext;
JavapParser.ClassMemberContext = ClassMemberContext;
JavapParser.InterfaceMemberContext = InterfaceMemberContext;
JavapParser.ConstructorDeclarationContext = ConstructorDeclarationContext;
JavapParser.FieldDeclarationContext = FieldDeclarationContext;
JavapParser.MethodDeclarationContext = MethodDeclarationContext;
JavapParser.ThrowsExceptionContext = ThrowsExceptionContext;
JavapParser.VarargsContext = VarargsContext;
JavapParser.MethodArgumentsContext = MethodArgumentsContext;
JavapParser.ArrayBracketsContext = ArrayBracketsContext;

// src/parser/index.ts
var PARSE_CHUNK = 500;
function parse(classPaths, counter, classList, typeRoot) {
  const context = parseClasses(
    classPaths,
    classList.filter((it) => !it.startsWith("kotlin."))
  );
  if (context === null)
    return false;
  const interfaces = context.classOrInterface().map((it) => it.interfaceDeclaration()).filter((it) => it);
  for (const it of interfaces) {
    const className = qualifiedName(it.type());
    const count = it.interfaceBody().interfaceMember().filter((it2) => it2.methodDeclaration()).length;
    if (it.typeList()) {
      counter[className] = [
        count,
        ...it.typeList().type().map((it2) => qualifiedName(it2))
      ];
    } else {
      counter[className] = [count];
    }
  }
  if (typeRoot) {
    return generateTsDef(context, counter, typeRoot);
  } else {
    return true;
  }
}
function parseClasses(classPaths, classList) {
  const buffer = [];
  for (let i = 0; i < classList.length; i += PARSE_CHUNK) {
    const output = javap(classPaths, classList.slice(i, i + PARSE_CHUNK));
    if (output === null) {
      return null;
    } else {
      buffer.push(output);
    }
  }
  const input = buffer.join("\n");
  const lexer = new JavapLexer(new antlr4_default.InputStream(input));
  const tokens = new antlr4_default.CommonTokenStream(lexer);
  const parser = new JavapParser(tokens);
  return parser.compilationUnit();
}

// src/jdk/interfaces.json
var interfaces_default = {
  "com.sun.jarsigner.ContentSignerParameters": [
    10
  ],
  "com.sun.java.accessibility.util.GUIInitializedListener": [
    1,
    "java.util.EventListener"
  ],
  "com.sun.java.accessibility.util.TopLevelWindowListener": [
    2,
    "java.util.EventListener"
  ],
  "com.sun.javadoc.AnnotatedType": [
    2,
    "com.sun.javadoc.Type"
  ],
  "com.sun.javadoc.AnnotationDesc": [
    3
  ],
  "com.sun.javadoc.AnnotationDesc$ElementValuePair": [
    2
  ],
  "com.sun.javadoc.AnnotationTypeDoc": [
    1,
    "com.sun.javadoc.ClassDoc"
  ],
  "com.sun.javadoc.AnnotationTypeElementDoc": [
    1,
    "com.sun.javadoc.MethodDoc"
  ],
  "com.sun.javadoc.AnnotationValue": [
    2
  ],
  "com.sun.javadoc.ClassDoc": [
    25,
    "com.sun.javadoc.ProgramElementDoc",
    "com.sun.javadoc.Type"
  ],
  "com.sun.javadoc.ConstructorDoc": [
    0,
    "com.sun.javadoc.ExecutableMemberDoc"
  ],
  "com.sun.javadoc.Doc": [
    24,
    "java.lang.Comparable"
  ],
  "com.sun.javadoc.DocErrorReporter": [
    6
  ],
  "com.sun.javadoc.ExecutableMemberDoc": [
    13,
    "com.sun.javadoc.MemberDoc"
  ],
  "com.sun.javadoc.FieldDoc": [
    6,
    "com.sun.javadoc.MemberDoc"
  ],
  "com.sun.javadoc.MemberDoc": [
    1,
    "com.sun.javadoc.ProgramElementDoc"
  ],
  "com.sun.javadoc.MethodDoc": [
    7,
    "com.sun.javadoc.ExecutableMemberDoc"
  ],
  "com.sun.javadoc.PackageDoc": [
    10,
    "com.sun.javadoc.Doc"
  ],
  "com.sun.javadoc.ParamTag": [
    3,
    "com.sun.javadoc.Tag"
  ],
  "com.sun.javadoc.Parameter": [
    5
  ],
  "com.sun.javadoc.ParameterizedType": [
    5,
    "com.sun.javadoc.Type"
  ],
  "com.sun.javadoc.ProgramElementDoc": [
    12,
    "com.sun.javadoc.Doc"
  ],
  "com.sun.javadoc.RootDoc": [
    6,
    "com.sun.javadoc.Doc",
    "com.sun.javadoc.DocErrorReporter"
  ],
  "com.sun.javadoc.SeeTag": [
    6,
    "com.sun.javadoc.Tag"
  ],
  "com.sun.javadoc.SerialFieldTag": [
    5,
    "com.sun.javadoc.Tag",
    "java.lang.Comparable"
  ],
  "com.sun.javadoc.SourcePosition": [
    4
  ],
  "com.sun.javadoc.Tag": [
    8
  ],
  "com.sun.javadoc.ThrowsTag": [
    4,
    "com.sun.javadoc.Tag"
  ],
  "com.sun.javadoc.Type": [
    13
  ],
  "com.sun.javadoc.TypeVariable": [
    3,
    "com.sun.javadoc.Type"
  ],
  "com.sun.javadoc.WildcardType": [
    2,
    "com.sun.javadoc.Type"
  ],
  "com.sun.jdi.Accessible": [
    5
  ],
  "com.sun.jdi.ArrayReference": [
    7,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.ArrayType": [
    4,
    "com.sun.jdi.ReferenceType"
  ],
  "com.sun.jdi.BooleanType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.BooleanValue": [
    3,
    "com.sun.jdi.PrimitiveValue"
  ],
  "com.sun.jdi.ByteType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.ByteValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.CharType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.CharValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.ClassLoaderReference": [
    2,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.ClassObjectReference": [
    1,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.ClassType": [
    9,
    "com.sun.jdi.ReferenceType"
  ],
  "com.sun.jdi.DoubleType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.DoubleValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.Field": [
    7,
    "com.sun.jdi.TypeComponent",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.FloatType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.FloatValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.IntegerType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.IntegerValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.InterfaceType": [
    4,
    "com.sun.jdi.ReferenceType"
  ],
  "com.sun.jdi.LocalVariable": [
    9,
    "com.sun.jdi.Mirror",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.Locatable": [
    1
  ],
  "com.sun.jdi.Location": [
    11,
    "com.sun.jdi.Mirror",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.LongType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.LongValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.Method": [
    25,
    "com.sun.jdi.TypeComponent",
    "com.sun.jdi.Locatable",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.Mirror": [
    2
  ],
  "com.sun.jdi.ModuleReference": [
    2,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.MonitorInfo": [
    3,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.ObjectReference": [
    15,
    "com.sun.jdi.Value"
  ],
  "com.sun.jdi.PathSearchingVirtualMachine": [
    3,
    "com.sun.jdi.VirtualMachine"
  ],
  "com.sun.jdi.PrimitiveType": [
    0,
    "com.sun.jdi.Type"
  ],
  "com.sun.jdi.PrimitiveValue": [
    8,
    "com.sun.jdi.Value"
  ],
  "com.sun.jdi.ReferenceType": [
    41,
    "com.sun.jdi.Type",
    "java.lang.Comparable",
    "com.sun.jdi.Accessible"
  ],
  "com.sun.jdi.ShortType": [
    0,
    "com.sun.jdi.PrimitiveType"
  ],
  "com.sun.jdi.ShortValue": [
    3,
    "com.sun.jdi.PrimitiveValue",
    "java.lang.Comparable"
  ],
  "com.sun.jdi.StackFrame": [
    9,
    "com.sun.jdi.Mirror",
    "com.sun.jdi.Locatable"
  ],
  "com.sun.jdi.StringReference": [
    1,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.ThreadGroupReference": [
    6,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.ThreadReference": [
    19,
    "com.sun.jdi.ObjectReference"
  ],
  "com.sun.jdi.Type": [
    2,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.TypeComponent": [
    7,
    "com.sun.jdi.Mirror",
    "com.sun.jdi.Accessible"
  ],
  "com.sun.jdi.Value": [
    1,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.VirtualMachine": [
    54,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.VirtualMachineManager": [
    10
  ],
  "com.sun.jdi.VoidType": [
    0,
    "com.sun.jdi.Type"
  ],
  "com.sun.jdi.VoidValue": [
    2,
    "com.sun.jdi.Value"
  ],
  "com.sun.jdi.connect.AttachingConnector": [
    1,
    "com.sun.jdi.connect.Connector"
  ],
  "com.sun.jdi.connect.Connector": [
    4
  ],
  "com.sun.jdi.connect.Connector$Argument": [
    7,
    "java.io.Serializable"
  ],
  "com.sun.jdi.connect.Connector$BooleanArgument": [
    4,
    "com.sun.jdi.connect.Connector$Argument"
  ],
  "com.sun.jdi.connect.Connector$IntegerArgument": [
    7,
    "com.sun.jdi.connect.Connector$Argument"
  ],
  "com.sun.jdi.connect.Connector$SelectedArgument": [
    2,
    "com.sun.jdi.connect.Connector$Argument"
  ],
  "com.sun.jdi.connect.Connector$StringArgument": [
    1,
    "com.sun.jdi.connect.Connector$Argument"
  ],
  "com.sun.jdi.connect.LaunchingConnector": [
    1,
    "com.sun.jdi.connect.Connector"
  ],
  "com.sun.jdi.connect.ListeningConnector": [
    4,
    "com.sun.jdi.connect.Connector"
  ],
  "com.sun.jdi.connect.Transport": [
    1
  ],
  "com.sun.jdi.event.AccessWatchpointEvent": [
    0,
    "com.sun.jdi.event.WatchpointEvent"
  ],
  "com.sun.jdi.event.BreakpointEvent": [
    0,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.ClassPrepareEvent": [
    2,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.ClassUnloadEvent": [
    2,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.Event": [
    1,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.event.EventIterator": [
    1,
    "java.util.Iterator"
  ],
  "com.sun.jdi.event.EventQueue": [
    2,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.event.EventSet": [
    3,
    "com.sun.jdi.Mirror",
    "java.util.Set"
  ],
  "com.sun.jdi.event.ExceptionEvent": [
    2,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.LocatableEvent": [
    1,
    "com.sun.jdi.event.Event",
    "com.sun.jdi.Locatable"
  ],
  "com.sun.jdi.event.MethodEntryEvent": [
    1,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.MethodExitEvent": [
    2,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.ModificationWatchpointEvent": [
    1,
    "com.sun.jdi.event.WatchpointEvent"
  ],
  "com.sun.jdi.event.MonitorContendedEnterEvent": [
    2,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.MonitorContendedEnteredEvent": [
    2,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.MonitorWaitEvent": [
    3,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.MonitorWaitedEvent": [
    3,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.StepEvent": [
    0,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.event.ThreadDeathEvent": [
    1,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.ThreadStartEvent": [
    1,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.VMDeathEvent": [
    0,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.VMDisconnectEvent": [
    0,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.VMStartEvent": [
    1,
    "com.sun.jdi.event.Event"
  ],
  "com.sun.jdi.event.WatchpointEvent": [
    3,
    "com.sun.jdi.event.LocatableEvent"
  ],
  "com.sun.jdi.request.AccessWatchpointRequest": [
    0,
    "com.sun.jdi.request.WatchpointRequest"
  ],
  "com.sun.jdi.request.BreakpointRequest": [
    3,
    "com.sun.jdi.request.EventRequest",
    "com.sun.jdi.Locatable"
  ],
  "com.sun.jdi.request.ClassPrepareRequest": [
    4,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.ClassUnloadRequest": [
    2,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.EventRequest": [
    9,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.request.EventRequestManager": [
    35,
    "com.sun.jdi.Mirror"
  ],
  "com.sun.jdi.request.ExceptionRequest": [
    8,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.MethodEntryRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.MethodExitRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.ModificationWatchpointRequest": [
    0,
    "com.sun.jdi.request.WatchpointRequest"
  ],
  "com.sun.jdi.request.MonitorContendedEnterRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.MonitorContendedEnteredRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.MonitorWaitRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.MonitorWaitedRequest": [
    5,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.StepRequest": [
    7,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.ThreadDeathRequest": [
    1,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.ThreadStartRequest": [
    1,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.VMDeathRequest": [
    0,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.jdi.request.WatchpointRequest": [
    6,
    "com.sun.jdi.request.EventRequest"
  ],
  "com.sun.management.DiagnosticCommandMBean": [
    0,
    "javax.management.DynamicMBean"
  ],
  "com.sun.management.GarbageCollectorMXBean": [
    1,
    "java.lang.management.GarbageCollectorMXBean"
  ],
  "com.sun.management.HotSpotDiagnosticMXBean": [
    4,
    "java.lang.management.PlatformManagedObject"
  ],
  "com.sun.management.OperatingSystemMXBean": [
    8,
    "java.lang.management.OperatingSystemMXBean"
  ],
  "com.sun.management.ThreadMXBean": [
    8,
    "java.lang.management.ThreadMXBean"
  ],
  "com.sun.management.UnixOperatingSystemMXBean": [
    2,
    "com.sun.management.OperatingSystemMXBean"
  ],
  "com.sun.net.httpserver.HttpHandler": [
    1
  ],
  "com.sun.nio.sctp.Notification": [
    1
  ],
  "com.sun.nio.sctp.NotificationHandler": [
    1
  ],
  "com.sun.nio.sctp.SctpSocketOption": [
    0,
    "java.net.SocketOption"
  ],
  "com.sun.security.auth.PrincipalComparator": [
    1
  ],
  "com.sun.security.jgss.ExtendedGSSContext": [
    3,
    "org.ietf.jgss.GSSContext"
  ],
  "com.sun.security.jgss.ExtendedGSSCredential": [
    1,
    "org.ietf.jgss.GSSCredential"
  ],
  "com.sun.source.doctree.AttributeTree": [
    3,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.AuthorTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.BlockTagTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.CommentTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.DeprecatedTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.DocCommentTree": [
    6,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.DocRootTree": [
    0,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.DocTree": [
    2
  ],
  "com.sun.source.doctree.DocTreeVisitor": [
    35
  ],
  "com.sun.source.doctree.DocTypeTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.EndElementTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.EntityTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.ErroneousTree": [
    1,
    "com.sun.source.doctree.TextTree"
  ],
  "com.sun.source.doctree.HiddenTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.IdentifierTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.IndexTree": [
    2,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.InheritDocTree": [
    0,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.InlineTagTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.LinkTree": [
    2,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.LiteralTree": [
    1,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.ParamTree": [
    3,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.ProvidesTree": [
    2,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.ReferenceTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.ReturnTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.SeeTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.SerialDataTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.SerialFieldTree": [
    3,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.SerialTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.SinceTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.StartElementTree": [
    3,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.SummaryTree": [
    1,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.TextTree": [
    1,
    "com.sun.source.doctree.DocTree"
  ],
  "com.sun.source.doctree.ThrowsTree": [
    2,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.UnknownBlockTagTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.UnknownInlineTagTree": [
    1,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.UsesTree": [
    2,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.doctree.ValueTree": [
    1,
    "com.sun.source.doctree.InlineTagTree"
  ],
  "com.sun.source.doctree.VersionTree": [
    1,
    "com.sun.source.doctree.BlockTagTree"
  ],
  "com.sun.source.tree.AnnotatedTypeTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.AnnotationTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.ArrayAccessTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.ArrayTypeTree": [
    1,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.AssertTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.AssignmentTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.BinaryTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.BlockTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.BreakTree": [
    1,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.CaseTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.CatchTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ClassTree": [
    6,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.CompilationUnitTree": [
    7,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.CompoundAssignmentTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.ConditionalExpressionTree": [
    3,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.ContinueTree": [
    1,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.DirectiveTree": [
    0,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.DoWhileLoopTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.EmptyStatementTree": [
    0,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.EnhancedForLoopTree": [
    3,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.ErroneousTree": [
    1,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.ExportsTree": [
    2,
    "com.sun.source.tree.DirectiveTree"
  ],
  "com.sun.source.tree.ExpressionStatementTree": [
    1,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.ExpressionTree": [
    0,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ForLoopTree": [
    4,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.IdentifierTree": [
    1,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.IfTree": [
    3,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.ImportTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.InstanceOfTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.IntersectionTypeTree": [
    1,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.LabeledStatementTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.LambdaExpressionTree": [
    3,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.LineMap": [
    4
  ],
  "com.sun.source.tree.LiteralTree": [
    1,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.MemberReferenceTree": [
    4,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.MemberSelectTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.MethodInvocationTree": [
    3,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.MethodTree": [
    9,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ModifiersTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ModuleTree": [
    4,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.NewArrayTree": [
    5,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.NewClassTree": [
    5,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.OpensTree": [
    2,
    "com.sun.source.tree.DirectiveTree"
  ],
  "com.sun.source.tree.PackageTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ParameterizedTypeTree": [
    2,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ParenthesizedTree": [
    1,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.PrimitiveTypeTree": [
    1,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.ProvidesTree": [
    2,
    "com.sun.source.tree.DirectiveTree"
  ],
  "com.sun.source.tree.RequiresTree": [
    3,
    "com.sun.source.tree.DirectiveTree"
  ],
  "com.sun.source.tree.ReturnTree": [
    1,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.Scope": [
    4
  ],
  "com.sun.source.tree.StatementTree": [
    0,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.SwitchTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.SynchronizedTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.ThrowTree": [
    1,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.Tree": [
    2
  ],
  "com.sun.source.tree.TreeVisitor": [
    60
  ],
  "com.sun.source.tree.TryTree": [
    4,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.TypeCastTree": [
    2,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.TypeParameterTree": [
    3,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.UnaryTree": [
    1,
    "com.sun.source.tree.ExpressionTree"
  ],
  "com.sun.source.tree.UnionTypeTree": [
    1,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.tree.UsesTree": [
    1,
    "com.sun.source.tree.DirectiveTree"
  ],
  "com.sun.source.tree.VariableTree": [
    5,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.WhileLoopTree": [
    2,
    "com.sun.source.tree.StatementTree"
  ],
  "com.sun.source.tree.WildcardTree": [
    1,
    "com.sun.source.tree.Tree"
  ],
  "com.sun.source.util.DocSourcePositions": [
    2,
    "com.sun.source.util.SourcePositions"
  ],
  "com.sun.source.util.DocTreeFactory": [
    40
  ],
  "com.sun.source.util.Plugin": [
    2
  ],
  "com.sun.source.util.SourcePositions": [
    2
  ],
  "com.sun.source.util.TaskListener": [
    2
  ],
  "com.sun.tools.jconsole.JConsoleContext": [
    4
  ],
  "java.applet.AppletContext": [
    10
  ],
  "java.applet.AppletStub": [
    6
  ],
  "java.applet.AudioClip": [
    3
  ],
  "java.awt.ActiveEvent": [
    1
  ],
  "java.awt.Adjustable": [
    15
  ],
  "java.awt.Composite": [
    1
  ],
  "java.awt.CompositeContext": [
    2
  ],
  "java.awt.ItemSelectable": [
    3
  ],
  "java.awt.KeyEventDispatcher": [
    1
  ],
  "java.awt.KeyEventPostProcessor": [
    1
  ],
  "java.awt.LayoutManager": [
    5
  ],
  "java.awt.LayoutManager2": [
    5,
    "java.awt.LayoutManager"
  ],
  "java.awt.MenuContainer": [
    3
  ],
  "java.awt.Paint": [
    1,
    "java.awt.Transparency"
  ],
  "java.awt.PaintContext": [
    3
  ],
  "java.awt.PrintGraphics": [
    1
  ],
  "java.awt.SecondaryLoop": [
    2
  ],
  "java.awt.Shape": [
    10
  ],
  "java.awt.Stroke": [
    1
  ],
  "java.awt.Transparency": [
    1
  ],
  "java.awt.datatransfer.ClipboardOwner": [
    1
  ],
  "java.awt.datatransfer.FlavorListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.datatransfer.FlavorMap": [
    2
  ],
  "java.awt.datatransfer.FlavorTable": [
    2,
    "java.awt.datatransfer.FlavorMap"
  ],
  "java.awt.datatransfer.Transferable": [
    3
  ],
  "java.awt.desktop.AboutHandler": [
    1
  ],
  "java.awt.desktop.AppForegroundListener": [
    2,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.desktop.AppHiddenListener": [
    2,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.desktop.AppReopenedListener": [
    1,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.desktop.OpenFilesHandler": [
    1
  ],
  "java.awt.desktop.OpenURIHandler": [
    1
  ],
  "java.awt.desktop.PreferencesHandler": [
    1
  ],
  "java.awt.desktop.PrintFilesHandler": [
    1
  ],
  "java.awt.desktop.QuitHandler": [
    1
  ],
  "java.awt.desktop.QuitResponse": [
    2
  ],
  "java.awt.desktop.ScreenSleepListener": [
    2,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.desktop.SystemEventListener": [
    0,
    "java.util.EventListener"
  ],
  "java.awt.desktop.SystemSleepListener": [
    2,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.desktop.UserSessionListener": [
    2,
    "java.awt.desktop.SystemEventListener"
  ],
  "java.awt.dnd.Autoscroll": [
    2
  ],
  "java.awt.dnd.DragGestureListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.dnd.DragSourceListener": [
    5,
    "java.util.EventListener"
  ],
  "java.awt.dnd.DragSourceMotionListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.dnd.DropTargetListener": [
    5,
    "java.util.EventListener"
  ],
  "java.awt.event.AWTEventListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.ActionListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.AdjustmentListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.ComponentListener": [
    4,
    "java.util.EventListener"
  ],
  "java.awt.event.ContainerListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.FocusListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.HierarchyBoundsListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.HierarchyListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.InputMethodListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.ItemListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.KeyListener": [
    3,
    "java.util.EventListener"
  ],
  "java.awt.event.MouseListener": [
    5,
    "java.util.EventListener"
  ],
  "java.awt.event.MouseMotionListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.MouseWheelListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.TextListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.event.WindowFocusListener": [
    2,
    "java.util.EventListener"
  ],
  "java.awt.event.WindowListener": [
    7,
    "java.util.EventListener"
  ],
  "java.awt.event.WindowStateListener": [
    1,
    "java.util.EventListener"
  ],
  "java.awt.font.MultipleMaster": [
    6
  ],
  "java.awt.font.OpenType": [
    7
  ],
  "java.awt.geom.PathIterator": [
    5
  ],
  "java.awt.im.InputMethodRequests": [
    7
  ],
  "java.awt.im.spi.InputMethod": [
    16
  ],
  "java.awt.im.spi.InputMethodContext": [
    4,
    "java.awt.im.InputMethodRequests"
  ],
  "java.awt.im.spi.InputMethodDescriptor": [
    5
  ],
  "java.awt.image.BufferedImageOp": [
    5
  ],
  "java.awt.image.ImageConsumer": [
    7
  ],
  "java.awt.image.ImageObserver": [
    1
  ],
  "java.awt.image.ImageProducer": [
    5
  ],
  "java.awt.image.MultiResolutionImage": [
    2
  ],
  "java.awt.image.RasterOp": [
    5
  ],
  "java.awt.image.RenderedImage": [
    21
  ],
  "java.awt.image.TileObserver": [
    1
  ],
  "java.awt.image.WritableRenderedImage": [
    8,
    "java.awt.image.RenderedImage"
  ],
  "java.awt.image.renderable.ContextualRenderedImageFactory": [
    6,
    "java.awt.image.renderable.RenderedImageFactory"
  ],
  "java.awt.image.renderable.RenderableImage": [
    11
  ],
  "java.awt.image.renderable.RenderedImageFactory": [
    1
  ],
  "java.awt.print.Pageable": [
    3
  ],
  "java.awt.print.Printable": [
    1
  ],
  "java.awt.print.PrinterGraphics": [
    1
  ],
  "java.beans.AppletInitializer": [
    2
  ],
  "java.beans.BeanInfo": [
    8
  ],
  "java.beans.BeanProperty": [
    8,
    "java.lang.annotation.Annotation"
  ],
  "java.beans.ConstructorProperties": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.beans.Customizer": [
    3
  ],
  "java.beans.DesignMode": [
    2
  ],
  "java.beans.ExceptionListener": [
    1
  ],
  "java.beans.JavaBean": [
    3,
    "java.lang.annotation.Annotation"
  ],
  "java.beans.PropertyChangeListener": [
    1,
    "java.util.EventListener"
  ],
  "java.beans.PropertyEditor": [
    12
  ],
  "java.beans.Transient": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.beans.VetoableChangeListener": [
    1,
    "java.util.EventListener"
  ],
  "java.beans.Visibility": [
    4
  ],
  "java.beans.beancontext.BeanContext": [
    5,
    "java.beans.beancontext.BeanContextChild",
    "java.util.Collection",
    "java.beans.DesignMode",
    "java.beans.Visibility"
  ],
  "java.beans.beancontext.BeanContextChild": [
    6
  ],
  "java.beans.beancontext.BeanContextChildComponentProxy": [
    1
  ],
  "java.beans.beancontext.BeanContextContainerProxy": [
    1
  ],
  "java.beans.beancontext.BeanContextMembershipListener": [
    2,
    "java.util.EventListener"
  ],
  "java.beans.beancontext.BeanContextProxy": [
    1
  ],
  "java.beans.beancontext.BeanContextServiceProvider": [
    3
  ],
  "java.beans.beancontext.BeanContextServiceProviderBeanInfo": [
    1,
    "java.beans.BeanInfo"
  ],
  "java.beans.beancontext.BeanContextServiceRevokedListener": [
    1,
    "java.util.EventListener"
  ],
  "java.beans.beancontext.BeanContextServices": [
    9,
    "java.beans.beancontext.BeanContext",
    "java.beans.beancontext.BeanContextServicesListener"
  ],
  "java.beans.beancontext.BeanContextServicesListener": [
    1,
    "java.beans.beancontext.BeanContextServiceRevokedListener"
  ],
  "java.io.Closeable": [
    1,
    "java.lang.AutoCloseable"
  ],
  "java.io.DataInput": [
    15
  ],
  "java.io.DataOutput": [
    14
  ],
  "java.io.Externalizable": [
    2,
    "java.io.Serializable"
  ],
  "java.io.FileFilter": [
    1
  ],
  "java.io.FilenameFilter": [
    1
  ],
  "java.io.Flushable": [
    1
  ],
  "java.io.ObjectInput": [
    7,
    "java.io.DataInput",
    "java.lang.AutoCloseable"
  ],
  "java.io.ObjectInputFilter": [
    1
  ],
  "java.io.ObjectInputFilter$FilterInfo": [
    5
  ],
  "java.io.ObjectInputValidation": [
    1
  ],
  "java.io.ObjectOutput": [
    6,
    "java.io.DataOutput",
    "java.lang.AutoCloseable"
  ],
  "java.io.ObjectStreamConstants": [
    0
  ],
  "java.io.Serializable": [
    0
  ],
  "java.lang.Appendable": [
    3
  ],
  "java.lang.AutoCloseable": [
    1
  ],
  "java.lang.CharSequence": [
    7
  ],
  "java.lang.Cloneable": [
    0
  ],
  "java.lang.Comparable": [
    1
  ],
  "java.lang.Deprecated": [
    2,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.FunctionalInterface": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.Iterable": [
    3
  ],
  "java.lang.Override": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.ProcessHandle": [
    17,
    "java.lang.Comparable"
  ],
  "java.lang.ProcessHandle$Info": [
    6
  ],
  "java.lang.Readable": [
    1
  ],
  "java.lang.Runnable": [
    1
  ],
  "java.lang.SafeVarargs": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.StackWalker$StackFrame": [
    10
  ],
  "java.lang.SuppressWarnings": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.System$Logger": [
    10
  ],
  "java.lang.Thread$UncaughtExceptionHandler": [
    1
  ],
  "java.lang.annotation.Annotation": [
    4
  ],
  "java.lang.annotation.Documented": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.annotation.Inherited": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.annotation.Native": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.annotation.Repeatable": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.annotation.Retention": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.annotation.Target": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "java.lang.instrument.ClassFileTransformer": [
    2
  ],
  "java.lang.instrument.Instrumentation": [
    17
  ],
  "java.lang.invoke.MethodHandleInfo": [
    9
  ],
  "java.lang.management.BufferPoolMXBean": [
    4,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.ClassLoadingMXBean": [
    5,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.CompilationMXBean": [
    3,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.GarbageCollectorMXBean": [
    2,
    "java.lang.management.MemoryManagerMXBean"
  ],
  "java.lang.management.MemoryMXBean": [
    6,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.MemoryManagerMXBean": [
    3,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.MemoryPoolMXBean": [
    18,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.OperatingSystemMXBean": [
    5,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.PlatformLoggingMXBean": [
    4,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.PlatformManagedObject": [
    1
  ],
  "java.lang.management.RuntimeMXBean": [
    17,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.management.ThreadMXBean": [
    29,
    "java.lang.management.PlatformManagedObject"
  ],
  "java.lang.module.ModuleFinder": [
    5
  ],
  "java.lang.module.ModuleReader": [
    6,
    "java.io.Closeable"
  ],
  "java.lang.ref.Cleaner$Cleanable": [
    1
  ],
  "java.lang.reflect.AnnotatedArrayType": [
    2,
    "java.lang.reflect.AnnotatedType"
  ],
  "java.lang.reflect.AnnotatedElement": [
    7
  ],
  "java.lang.reflect.AnnotatedParameterizedType": [
    2,
    "java.lang.reflect.AnnotatedType"
  ],
  "java.lang.reflect.AnnotatedType": [
    2,
    "java.lang.reflect.AnnotatedElement"
  ],
  "java.lang.reflect.AnnotatedTypeVariable": [
    2,
    "java.lang.reflect.AnnotatedType"
  ],
  "java.lang.reflect.AnnotatedWildcardType": [
    3,
    "java.lang.reflect.AnnotatedType"
  ],
  "java.lang.reflect.GenericArrayType": [
    1,
    "java.lang.reflect.Type"
  ],
  "java.lang.reflect.GenericDeclaration": [
    1,
    "java.lang.reflect.AnnotatedElement"
  ],
  "java.lang.reflect.InvocationHandler": [
    1
  ],
  "java.lang.reflect.Member": [
    4
  ],
  "java.lang.reflect.ParameterizedType": [
    3,
    "java.lang.reflect.Type"
  ],
  "java.lang.reflect.Type": [
    1
  ],
  "java.lang.reflect.TypeVariable": [
    4,
    "java.lang.reflect.Type",
    "java.lang.reflect.AnnotatedElement"
  ],
  "java.lang.reflect.WildcardType": [
    2,
    "java.lang.reflect.Type"
  ],
  "java.net.ContentHandlerFactory": [
    1
  ],
  "java.net.CookiePolicy": [
    1
  ],
  "java.net.CookieStore": [
    6
  ],
  "java.net.DatagramSocketImplFactory": [
    1
  ],
  "java.net.FileNameMap": [
    1
  ],
  "java.net.ProtocolFamily": [
    1
  ],
  "java.net.SocketImplFactory": [
    1
  ],
  "java.net.SocketOption": [
    2
  ],
  "java.net.SocketOptions": [
    2
  ],
  "java.net.URLStreamHandlerFactory": [
    1
  ],
  "java.net.http.HttpClient$Builder": [
    11
  ],
  "java.net.http.HttpRequest$BodyPublisher": [
    1,
    "java.util.concurrent.Flow$Publisher"
  ],
  "java.net.http.HttpRequest$Builder": [
    14
  ],
  "java.net.http.HttpResponse": [
    8
  ],
  "java.net.http.HttpResponse$BodyHandler": [
    1
  ],
  "java.net.http.HttpResponse$BodySubscriber": [
    1,
    "java.util.concurrent.Flow$Subscriber"
  ],
  "java.net.http.HttpResponse$PushPromiseHandler": [
    2
  ],
  "java.net.http.HttpResponse$ResponseInfo": [
    3
  ],
  "java.net.http.WebSocket": [
    10
  ],
  "java.net.http.WebSocket$Builder": [
    4
  ],
  "java.net.http.WebSocket$Listener": [
    7
  ],
  "java.nio.channels.AsynchronousByteChannel": [
    4,
    "java.nio.channels.AsynchronousChannel"
  ],
  "java.nio.channels.AsynchronousChannel": [
    1,
    "java.nio.channels.Channel"
  ],
  "java.nio.channels.ByteChannel": [
    0,
    "java.nio.channels.ReadableByteChannel",
    "java.nio.channels.WritableByteChannel"
  ],
  "java.nio.channels.Channel": [
    2,
    "java.io.Closeable"
  ],
  "java.nio.channels.CompletionHandler": [
    2
  ],
  "java.nio.channels.GatheringByteChannel": [
    2,
    "java.nio.channels.WritableByteChannel"
  ],
  "java.nio.channels.InterruptibleChannel": [
    1,
    "java.nio.channels.Channel"
  ],
  "java.nio.channels.MulticastChannel": [
    3,
    "java.nio.channels.NetworkChannel"
  ],
  "java.nio.channels.NetworkChannel": [
    5,
    "java.nio.channels.Channel"
  ],
  "java.nio.channels.ReadableByteChannel": [
    1,
    "java.nio.channels.Channel"
  ],
  "java.nio.channels.ScatteringByteChannel": [
    2,
    "java.nio.channels.ReadableByteChannel"
  ],
  "java.nio.channels.SeekableByteChannel": [
    6,
    "java.nio.channels.ByteChannel"
  ],
  "java.nio.channels.WritableByteChannel": [
    1,
    "java.nio.channels.Channel"
  ],
  "java.nio.file.CopyOption": [
    0
  ],
  "java.nio.file.DirectoryStream": [
    1,
    "java.io.Closeable",
    "java.lang.Iterable"
  ],
  "java.nio.file.DirectoryStream$Filter": [
    1
  ],
  "java.nio.file.FileVisitor": [
    4
  ],
  "java.nio.file.OpenOption": [
    0
  ],
  "java.nio.file.Path": [
    32,
    "java.lang.Comparable",
    "java.lang.Iterable",
    "java.nio.file.Watchable"
  ],
  "java.nio.file.PathMatcher": [
    1
  ],
  "java.nio.file.SecureDirectoryStream": [
    7,
    "java.nio.file.DirectoryStream"
  ],
  "java.nio.file.WatchEvent": [
    3
  ],
  "java.nio.file.WatchEvent$Kind": [
    2
  ],
  "java.nio.file.WatchEvent$Modifier": [
    1
  ],
  "java.nio.file.WatchKey": [
    5
  ],
  "java.nio.file.WatchService": [
    4,
    "java.io.Closeable"
  ],
  "java.nio.file.Watchable": [
    2
  ],
  "java.nio.file.attribute.AclFileAttributeView": [
    3,
    "java.nio.file.attribute.FileOwnerAttributeView"
  ],
  "java.nio.file.attribute.AttributeView": [
    1
  ],
  "java.nio.file.attribute.BasicFileAttributeView": [
    3,
    "java.nio.file.attribute.FileAttributeView"
  ],
  "java.nio.file.attribute.BasicFileAttributes": [
    9
  ],
  "java.nio.file.attribute.DosFileAttributeView": [
    7,
    "java.nio.file.attribute.BasicFileAttributeView"
  ],
  "java.nio.file.attribute.DosFileAttributes": [
    4,
    "java.nio.file.attribute.BasicFileAttributes"
  ],
  "java.nio.file.attribute.FileAttribute": [
    2
  ],
  "java.nio.file.attribute.FileAttributeView": [
    0,
    "java.nio.file.attribute.AttributeView"
  ],
  "java.nio.file.attribute.FileOwnerAttributeView": [
    3,
    "java.nio.file.attribute.FileAttributeView"
  ],
  "java.nio.file.attribute.FileStoreAttributeView": [
    0,
    "java.nio.file.attribute.AttributeView"
  ],
  "java.nio.file.attribute.GroupPrincipal": [
    0,
    "java.nio.file.attribute.UserPrincipal"
  ],
  "java.nio.file.attribute.PosixFileAttributeView": [
    5,
    "java.nio.file.attribute.BasicFileAttributeView",
    "java.nio.file.attribute.FileOwnerAttributeView"
  ],
  "java.nio.file.attribute.PosixFileAttributes": [
    3,
    "java.nio.file.attribute.BasicFileAttributes"
  ],
  "java.nio.file.attribute.UserDefinedFileAttributeView": [
    6,
    "java.nio.file.attribute.FileAttributeView"
  ],
  "java.nio.file.attribute.UserPrincipal": [
    0,
    "java.security.Principal"
  ],
  "java.rmi.Remote": [
    0
  ],
  "java.rmi.activation.ActivationInstantiator": [
    1,
    "java.rmi.Remote"
  ],
  "java.rmi.activation.ActivationMonitor": [
    3,
    "java.rmi.Remote"
  ],
  "java.rmi.activation.ActivationSystem": [
    10,
    "java.rmi.Remote"
  ],
  "java.rmi.activation.Activator": [
    1,
    "java.rmi.Remote"
  ],
  "java.rmi.dgc.DGC": [
    2,
    "java.rmi.Remote"
  ],
  "java.rmi.registry.Registry": [
    5,
    "java.rmi.Remote"
  ],
  "java.rmi.registry.RegistryHandler": [
    2
  ],
  "java.rmi.server.LoaderHandler": [
    3
  ],
  "java.rmi.server.RMIClientSocketFactory": [
    1
  ],
  "java.rmi.server.RMIFailureHandler": [
    1
  ],
  "java.rmi.server.RMIServerSocketFactory": [
    1
  ],
  "java.rmi.server.RemoteCall": [
    7
  ],
  "java.rmi.server.RemoteRef": [
    8,
    "java.io.Externalizable"
  ],
  "java.rmi.server.ServerRef": [
    2,
    "java.rmi.server.RemoteRef"
  ],
  "java.rmi.server.Skeleton": [
    2
  ],
  "java.rmi.server.Unreferenced": [
    1
  ],
  "java.security.AlgorithmConstraints": [
    3
  ],
  "java.security.Certificate": [
    7
  ],
  "java.security.DomainCombiner": [
    1
  ],
  "java.security.Guard": [
    1
  ],
  "java.security.Key": [
    3,
    "java.io.Serializable"
  ],
  "java.security.KeyStore$Entry": [
    1
  ],
  "java.security.KeyStore$Entry$Attribute": [
    2
  ],
  "java.security.KeyStore$LoadStoreParameter": [
    1
  ],
  "java.security.KeyStore$ProtectionParameter": [
    0
  ],
  "java.security.Policy$Parameters": [
    0
  ],
  "java.security.Principal": [
    5
  ],
  "java.security.PrivateKey": [
    0,
    "java.security.Key",
    "javax.security.auth.Destroyable"
  ],
  "java.security.PrivilegedAction": [
    1
  ],
  "java.security.PrivilegedExceptionAction": [
    1
  ],
  "java.security.PublicKey": [
    0,
    "java.security.Key"
  ],
  "java.security.SecureRandomParameters": [
    0
  ],
  "java.security.acl.Acl": [
    8,
    "java.security.acl.Owner"
  ],
  "java.security.acl.AclEntry": [
    10,
    "java.lang.Cloneable"
  ],
  "java.security.acl.Group": [
    4,
    "java.security.Principal"
  ],
  "java.security.acl.Owner": [
    3
  ],
  "java.security.acl.Permission": [
    2
  ],
  "java.security.cert.CRLSelector": [
    2,
    "java.lang.Cloneable"
  ],
  "java.security.cert.CertPathBuilderResult": [
    2,
    "java.lang.Cloneable"
  ],
  "java.security.cert.CertPathChecker": [
    3
  ],
  "java.security.cert.CertPathParameters": [
    1,
    "java.lang.Cloneable"
  ],
  "java.security.cert.CertPathValidatorException$Reason": [
    0,
    "java.io.Serializable"
  ],
  "java.security.cert.CertPathValidatorResult": [
    1,
    "java.lang.Cloneable"
  ],
  "java.security.cert.CertSelector": [
    2,
    "java.lang.Cloneable"
  ],
  "java.security.cert.CertStoreParameters": [
    1,
    "java.lang.Cloneable"
  ],
  "java.security.cert.Extension": [
    4
  ],
  "java.security.cert.PolicyNode": [
    7
  ],
  "java.security.cert.X509Extension": [
    4
  ],
  "java.security.interfaces.DSAKey": [
    1
  ],
  "java.security.interfaces.DSAKeyPairGenerator": [
    2
  ],
  "java.security.interfaces.DSAParams": [
    3
  ],
  "java.security.interfaces.DSAPrivateKey": [
    1,
    "java.security.interfaces.DSAKey",
    "java.security.PrivateKey"
  ],
  "java.security.interfaces.DSAPublicKey": [
    1,
    "java.security.interfaces.DSAKey",
    "java.security.PublicKey"
  ],
  "java.security.interfaces.ECKey": [
    1
  ],
  "java.security.interfaces.ECPrivateKey": [
    1,
    "java.security.PrivateKey",
    "java.security.interfaces.ECKey"
  ],
  "java.security.interfaces.ECPublicKey": [
    1,
    "java.security.PublicKey",
    "java.security.interfaces.ECKey"
  ],
  "java.security.interfaces.RSAKey": [
    2
  ],
  "java.security.interfaces.RSAMultiPrimePrivateCrtKey": [
    7,
    "java.security.interfaces.RSAPrivateKey"
  ],
  "java.security.interfaces.RSAPrivateCrtKey": [
    6,
    "java.security.interfaces.RSAPrivateKey"
  ],
  "java.security.interfaces.RSAPrivateKey": [
    1,
    "java.security.PrivateKey",
    "java.security.interfaces.RSAKey"
  ],
  "java.security.interfaces.RSAPublicKey": [
    1,
    "java.security.PublicKey",
    "java.security.interfaces.RSAKey"
  ],
  "java.security.interfaces.XECKey": [
    1
  ],
  "java.security.interfaces.XECPrivateKey": [
    1,
    "java.security.interfaces.XECKey",
    "java.security.PrivateKey"
  ],
  "java.security.interfaces.XECPublicKey": [
    1,
    "java.security.interfaces.XECKey",
    "java.security.PublicKey"
  ],
  "java.security.spec.AlgorithmParameterSpec": [
    0
  ],
  "java.security.spec.ECField": [
    1
  ],
  "java.security.spec.KeySpec": [
    0
  ],
  "java.sql.Array": [
    11
  ],
  "java.sql.Blob": [
    11
  ],
  "java.sql.CallableStatement": [
    121,
    "java.sql.PreparedStatement"
  ],
  "java.sql.Clob": [
    13
  ],
  "java.sql.Connection": [
    58,
    "java.sql.Wrapper",
    "java.lang.AutoCloseable"
  ],
  "java.sql.ConnectionBuilder": [
    5
  ],
  "java.sql.DatabaseMetaData": [
    177,
    "java.sql.Wrapper"
  ],
  "java.sql.Driver": [
    7
  ],
  "java.sql.DriverAction": [
    1
  ],
  "java.sql.NClob": [
    0,
    "java.sql.Clob"
  ],
  "java.sql.ParameterMetaData": [
    9,
    "java.sql.Wrapper"
  ],
  "java.sql.PreparedStatement": [
    58,
    "java.sql.Statement"
  ],
  "java.sql.Ref": [
    4
  ],
  "java.sql.ResultSet": [
    193,
    "java.sql.Wrapper",
    "java.lang.AutoCloseable"
  ],
  "java.sql.ResultSetMetaData": [
    21,
    "java.sql.Wrapper"
  ],
  "java.sql.RowId": [
    4
  ],
  "java.sql.SQLData": [
    3
  ],
  "java.sql.SQLInput": [
    28
  ],
  "java.sql.SQLOutput": [
    28
  ],
  "java.sql.SQLType": [
    3
  ],
  "java.sql.SQLXML": [
    9
  ],
  "java.sql.Savepoint": [
    2
  ],
  "java.sql.ShardingKey": [
    0
  ],
  "java.sql.ShardingKeyBuilder": [
    2
  ],
  "java.sql.Statement": [
    54,
    "java.sql.Wrapper",
    "java.lang.AutoCloseable"
  ],
  "java.sql.Struct": [
    3
  ],
  "java.sql.Wrapper": [
    2
  ],
  "java.text.AttributedCharacterIterator": [
    9,
    "java.text.CharacterIterator"
  ],
  "java.text.CharacterIterator": [
    10,
    "java.lang.Cloneable"
  ],
  "java.time.chrono.ChronoLocalDate": [
    36,
    "java.time.temporal.Temporal",
    "java.time.temporal.TemporalAdjuster",
    "java.lang.Comparable"
  ],
  "java.time.chrono.ChronoLocalDateTime": [
    33,
    "java.time.temporal.Temporal",
    "java.time.temporal.TemporalAdjuster",
    "java.lang.Comparable"
  ],
  "java.time.chrono.ChronoPeriod": [
    16,
    "java.time.temporal.TemporalAmount"
  ],
  "java.time.chrono.ChronoZonedDateTime": [
    41,
    "java.time.temporal.Temporal",
    "java.lang.Comparable"
  ],
  "java.time.chrono.Chronology": [
    33,
    "java.lang.Comparable"
  ],
  "java.time.chrono.Era": [
    8,
    "java.time.temporal.TemporalAccessor",
    "java.time.temporal.TemporalAdjuster"
  ],
  "java.time.temporal.Temporal": [
    8,
    "java.time.temporal.TemporalAccessor"
  ],
  "java.time.temporal.TemporalAccessor": [
    5
  ],
  "java.time.temporal.TemporalAdjuster": [
    1
  ],
  "java.time.temporal.TemporalAmount": [
    4
  ],
  "java.time.temporal.TemporalField": [
    12
  ],
  "java.time.temporal.TemporalQuery": [
    1
  ],
  "java.time.temporal.TemporalUnit": [
    8
  ],
  "java.util.Collection": [
    20,
    "java.lang.Iterable"
  ],
  "java.util.Comparator": [
    18
  ],
  "java.util.Deque": [
    28,
    "java.util.Queue"
  ],
  "java.util.Enumeration": [
    3
  ],
  "java.util.EventListener": [
    0
  ],
  "java.util.Formattable": [
    1
  ],
  "java.util.Iterator": [
    4
  ],
  "java.util.List": [
    41,
    "java.util.Collection"
  ],
  "java.util.ListIterator": [
    9,
    "java.util.Iterator"
  ],
  "java.util.Map": [
    39
  ],
  "java.util.Map$Entry": [
    9
  ],
  "java.util.NavigableMap": [
    21,
    "java.util.SortedMap"
  ],
  "java.util.NavigableSet": [
    15,
    "java.util.SortedSet"
  ],
  "java.util.Observer": [
    1
  ],
  "java.util.PrimitiveIterator": [
    1,
    "java.util.Iterator"
  ],
  "java.util.PrimitiveIterator$OfDouble": [
    6,
    "java.util.PrimitiveIterator"
  ],
  "java.util.PrimitiveIterator$OfInt": [
    6,
    "java.util.PrimitiveIterator"
  ],
  "java.util.PrimitiveIterator$OfLong": [
    6,
    "java.util.PrimitiveIterator"
  ],
  "java.util.Queue": [
    6,
    "java.util.Collection"
  ],
  "java.util.RandomAccess": [
    0
  ],
  "java.util.ServiceLoader$Provider": [
    2,
    "java.util.function.Supplier"
  ],
  "java.util.Set": [
    29,
    "java.util.Collection"
  ],
  "java.util.SortedMap": [
    9,
    "java.util.Map"
  ],
  "java.util.SortedSet": [
    7,
    "java.util.Set"
  ],
  "java.util.Spliterator": [
    8
  ],
  "java.util.Spliterator$OfDouble": [
    9,
    "java.util.Spliterator$OfPrimitive"
  ],
  "java.util.Spliterator$OfInt": [
    9,
    "java.util.Spliterator$OfPrimitive"
  ],
  "java.util.Spliterator$OfLong": [
    9,
    "java.util.Spliterator$OfPrimitive"
  ],
  "java.util.Spliterator$OfPrimitive": [
    4,
    "java.util.Spliterator"
  ],
  "java.util.concurrent.BlockingDeque": [
    29,
    "java.util.concurrent.BlockingQueue",
    "java.util.Deque"
  ],
  "java.util.concurrent.BlockingQueue": [
    11,
    "java.util.Queue"
  ],
  "java.util.concurrent.Callable": [
    1
  ],
  "java.util.concurrent.CompletableFuture$AsynchronousCompletionTask": [
    0
  ],
  "java.util.concurrent.CompletionService": [
    5
  ],
  "java.util.concurrent.CompletionStage": [
    38
  ],
  "java.util.concurrent.ConcurrentMap": [
    11,
    "java.util.Map"
  ],
  "java.util.concurrent.ConcurrentNavigableMap": [
    18,
    "java.util.concurrent.ConcurrentMap",
    "java.util.NavigableMap"
  ],
  "java.util.concurrent.Delayed": [
    1,
    "java.lang.Comparable"
  ],
  "java.util.concurrent.Executor": [
    1
  ],
  "java.util.concurrent.ExecutorService": [
    12,
    "java.util.concurrent.Executor"
  ],
  "java.util.concurrent.Flow$Processor": [
    0,
    "java.util.concurrent.Flow$Subscriber",
    "java.util.concurrent.Flow$Publisher"
  ],
  "java.util.concurrent.Flow$Publisher": [
    1
  ],
  "java.util.concurrent.Flow$Subscriber": [
    4
  ],
  "java.util.concurrent.Flow$Subscription": [
    2
  ],
  "java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory": [
    1
  ],
  "java.util.concurrent.ForkJoinPool$ManagedBlocker": [
    2
  ],
  "java.util.concurrent.Future": [
    5
  ],
  "java.util.concurrent.RejectedExecutionHandler": [
    1
  ],
  "java.util.concurrent.RunnableFuture": [
    1,
    "java.lang.Runnable",
    "java.util.concurrent.Future"
  ],
  "java.util.concurrent.RunnableScheduledFuture": [
    1,
    "java.util.concurrent.RunnableFuture",
    "java.util.concurrent.ScheduledFuture"
  ],
  "java.util.concurrent.ScheduledExecutorService": [
    4,
    "java.util.concurrent.ExecutorService"
  ],
  "java.util.concurrent.ScheduledFuture": [
    0,
    "java.util.concurrent.Delayed",
    "java.util.concurrent.Future"
  ],
  "java.util.concurrent.ThreadFactory": [
    1
  ],
  "java.util.concurrent.TransferQueue": [
    5,
    "java.util.concurrent.BlockingQueue"
  ],
  "java.util.concurrent.locks.Condition": [
    7
  ],
  "java.util.concurrent.locks.Lock": [
    6
  ],
  "java.util.concurrent.locks.ReadWriteLock": [
    2
  ],
  "java.util.function.BiConsumer": [
    2
  ],
  "java.util.function.BiFunction": [
    2
  ],
  "java.util.function.BiPredicate": [
    4
  ],
  "java.util.function.BinaryOperator": [
    2,
    "java.util.function.BiFunction"
  ],
  "java.util.function.BooleanSupplier": [
    1
  ],
  "java.util.function.Consumer": [
    2
  ],
  "java.util.function.DoubleBinaryOperator": [
    1
  ],
  "java.util.function.DoubleConsumer": [
    2
  ],
  "java.util.function.DoubleFunction": [
    1
  ],
  "java.util.function.DoublePredicate": [
    4
  ],
  "java.util.function.DoubleSupplier": [
    1
  ],
  "java.util.function.DoubleToIntFunction": [
    1
  ],
  "java.util.function.DoubleToLongFunction": [
    1
  ],
  "java.util.function.DoubleUnaryOperator": [
    4
  ],
  "java.util.function.Function": [
    4
  ],
  "java.util.function.IntBinaryOperator": [
    1
  ],
  "java.util.function.IntConsumer": [
    2
  ],
  "java.util.function.IntFunction": [
    1
  ],
  "java.util.function.IntPredicate": [
    4
  ],
  "java.util.function.IntSupplier": [
    1
  ],
  "java.util.function.IntToDoubleFunction": [
    1
  ],
  "java.util.function.IntToLongFunction": [
    1
  ],
  "java.util.function.IntUnaryOperator": [
    4
  ],
  "java.util.function.LongBinaryOperator": [
    1
  ],
  "java.util.function.LongConsumer": [
    2
  ],
  "java.util.function.LongFunction": [
    1
  ],
  "java.util.function.LongPredicate": [
    4
  ],
  "java.util.function.LongSupplier": [
    1
  ],
  "java.util.function.LongToDoubleFunction": [
    1
  ],
  "java.util.function.LongToIntFunction": [
    1
  ],
  "java.util.function.LongUnaryOperator": [
    4
  ],
  "java.util.function.ObjDoubleConsumer": [
    1
  ],
  "java.util.function.ObjIntConsumer": [
    1
  ],
  "java.util.function.ObjLongConsumer": [
    1
  ],
  "java.util.function.Predicate": [
    6
  ],
  "java.util.function.Supplier": [
    1
  ],
  "java.util.function.ToDoubleBiFunction": [
    1
  ],
  "java.util.function.ToDoubleFunction": [
    1
  ],
  "java.util.function.ToIntBiFunction": [
    1
  ],
  "java.util.function.ToIntFunction": [
    1
  ],
  "java.util.function.ToLongBiFunction": [
    1
  ],
  "java.util.function.ToLongFunction": [
    1
  ],
  "java.util.function.UnaryOperator": [
    1,
    "java.util.function.Function"
  ],
  "java.util.jar.Pack200$Packer": [
    3
  ],
  "java.util.jar.Pack200$Unpacker": [
    3
  ],
  "java.util.logging.Filter": [
    1
  ],
  "java.util.logging.LoggingMXBean": [
    4
  ],
  "java.util.prefs.NodeChangeListener": [
    2,
    "java.util.EventListener"
  ],
  "java.util.prefs.PreferenceChangeListener": [
    1,
    "java.util.EventListener"
  ],
  "java.util.prefs.PreferencesFactory": [
    2
  ],
  "java.util.regex.MatchResult": [
    7
  ],
  "java.util.spi.ResourceBundleControlProvider": [
    1
  ],
  "java.util.spi.ResourceBundleProvider": [
    1
  ],
  "java.util.spi.ToolProvider": [
    4
  ],
  "java.util.stream.BaseStream": [
    8,
    "java.lang.AutoCloseable"
  ],
  "java.util.stream.Collector": [
    7
  ],
  "java.util.stream.DoubleStream": [
    47,
    "java.util.stream.BaseStream"
  ],
  "java.util.stream.DoubleStream$Builder": [
    3,
    "java.util.function.DoubleConsumer"
  ],
  "java.util.stream.IntStream": [
    51,
    "java.util.stream.BaseStream"
  ],
  "java.util.stream.IntStream$Builder": [
    3,
    "java.util.function.IntConsumer"
  ],
  "java.util.stream.LongStream": [
    50,
    "java.util.stream.BaseStream"
  ],
  "java.util.stream.LongStream$Builder": [
    3,
    "java.util.function.LongConsumer"
  ],
  "java.util.stream.Stream": [
    43,
    "java.util.stream.BaseStream"
  ],
  "java.util.stream.Stream$Builder": [
    3,
    "java.util.function.Consumer"
  ],
  "java.util.zip.Checksum": [
    6
  ],
  "javax.accessibility.Accessible": [
    1
  ],
  "javax.accessibility.AccessibleAction": [
    3
  ],
  "javax.accessibility.AccessibleComponent": [
    27
  ],
  "javax.accessibility.AccessibleEditableText": [
    9,
    "javax.accessibility.AccessibleText"
  ],
  "javax.accessibility.AccessibleExtendedComponent": [
    3,
    "javax.accessibility.AccessibleComponent"
  ],
  "javax.accessibility.AccessibleExtendedTable": [
    3,
    "javax.accessibility.AccessibleTable"
  ],
  "javax.accessibility.AccessibleExtendedText": [
    5
  ],
  "javax.accessibility.AccessibleHypertext": [
    3,
    "javax.accessibility.AccessibleText"
  ],
  "javax.accessibility.AccessibleIcon": [
    4
  ],
  "javax.accessibility.AccessibleKeyBinding": [
    2
  ],
  "javax.accessibility.AccessibleSelection": [
    7
  ],
  "javax.accessibility.AccessibleStreamable": [
    2
  ],
  "javax.accessibility.AccessibleTable": [
    22
  ],
  "javax.accessibility.AccessibleTableModelChange": [
    5
  ],
  "javax.accessibility.AccessibleText": [
    11
  ],
  "javax.accessibility.AccessibleValue": [
    4
  ],
  "javax.annotation.processing.Completion": [
    2
  ],
  "javax.annotation.processing.Filer": [
    4
  ],
  "javax.annotation.processing.Generated": [
    3,
    "java.lang.annotation.Annotation"
  ],
  "javax.annotation.processing.Messager": [
    4
  ],
  "javax.annotation.processing.ProcessingEnvironment": [
    7
  ],
  "javax.annotation.processing.Processor": [
    6
  ],
  "javax.annotation.processing.RoundEnvironment": [
    7
  ],
  "javax.annotation.processing.SupportedAnnotationTypes": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.annotation.processing.SupportedOptions": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.annotation.processing.SupportedSourceVersion": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.crypto.SecretKey": [
    0,
    "java.security.Key",
    "javax.security.auth.Destroyable"
  ],
  "javax.crypto.interfaces.DHKey": [
    1
  ],
  "javax.crypto.interfaces.DHPrivateKey": [
    1,
    "javax.crypto.interfaces.DHKey",
    "java.security.PrivateKey"
  ],
  "javax.crypto.interfaces.DHPublicKey": [
    1,
    "javax.crypto.interfaces.DHKey",
    "java.security.PublicKey"
  ],
  "javax.crypto.interfaces.PBEKey": [
    3,
    "javax.crypto.SecretKey"
  ],
  "javax.imageio.IIOParamController": [
    1
  ],
  "javax.imageio.ImageTranscoder": [
    2
  ],
  "javax.imageio.event.IIOReadProgressListener": [
    9,
    "java.util.EventListener"
  ],
  "javax.imageio.event.IIOReadUpdateListener": [
    6,
    "java.util.EventListener"
  ],
  "javax.imageio.event.IIOReadWarningListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.imageio.event.IIOWriteProgressListener": [
    7,
    "java.util.EventListener"
  ],
  "javax.imageio.event.IIOWriteWarningListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.imageio.metadata.IIOMetadataController": [
    1
  ],
  "javax.imageio.metadata.IIOMetadataFormat": [
    26
  ],
  "javax.imageio.spi.RegisterableService": [
    2
  ],
  "javax.imageio.spi.ServiceRegistry$Filter": [
    1
  ],
  "javax.imageio.stream.ImageInputStream": [
    45,
    "java.io.DataInput",
    "java.io.Closeable"
  ],
  "javax.imageio.stream.ImageOutputStream": [
    23,
    "javax.imageio.stream.ImageInputStream",
    "java.io.DataOutput"
  ],
  "javax.lang.model.AnnotatedConstruct": [
    3
  ],
  "javax.lang.model.element.AnnotationMirror": [
    2
  ],
  "javax.lang.model.element.AnnotationValue": [
    3
  ],
  "javax.lang.model.element.AnnotationValueVisitor": [
    16
  ],
  "javax.lang.model.element.Element": [
    11,
    "javax.lang.model.AnnotatedConstruct"
  ],
  "javax.lang.model.element.ElementVisitor": [
    9
  ],
  "javax.lang.model.element.ExecutableElement": [
    9,
    "javax.lang.model.element.Element",
    "javax.lang.model.element.Parameterizable"
  ],
  "javax.lang.model.element.ModuleElement": [
    7,
    "javax.lang.model.element.Element",
    "javax.lang.model.element.QualifiedNameable"
  ],
  "javax.lang.model.element.ModuleElement$Directive": [
    2
  ],
  "javax.lang.model.element.ModuleElement$DirectiveVisitor": [
    8
  ],
  "javax.lang.model.element.ModuleElement$ExportsDirective": [
    2,
    "javax.lang.model.element.ModuleElement$Directive"
  ],
  "javax.lang.model.element.ModuleElement$OpensDirective": [
    2,
    "javax.lang.model.element.ModuleElement$Directive"
  ],
  "javax.lang.model.element.ModuleElement$ProvidesDirective": [
    2,
    "javax.lang.model.element.ModuleElement$Directive"
  ],
  "javax.lang.model.element.ModuleElement$RequiresDirective": [
    3,
    "javax.lang.model.element.ModuleElement$Directive"
  ],
  "javax.lang.model.element.ModuleElement$UsesDirective": [
    1,
    "javax.lang.model.element.ModuleElement$Directive"
  ],
  "javax.lang.model.element.Name": [
    3,
    "java.lang.CharSequence"
  ],
  "javax.lang.model.element.PackageElement": [
    5,
    "javax.lang.model.element.Element",
    "javax.lang.model.element.QualifiedNameable"
  ],
  "javax.lang.model.element.Parameterizable": [
    1,
    "javax.lang.model.element.Element"
  ],
  "javax.lang.model.element.QualifiedNameable": [
    1,
    "javax.lang.model.element.Element"
  ],
  "javax.lang.model.element.TypeElement": [
    8,
    "javax.lang.model.element.Element",
    "javax.lang.model.element.Parameterizable",
    "javax.lang.model.element.QualifiedNameable"
  ],
  "javax.lang.model.element.TypeParameterElement": [
    3,
    "javax.lang.model.element.Element"
  ],
  "javax.lang.model.element.VariableElement": [
    3,
    "javax.lang.model.element.Element"
  ],
  "javax.lang.model.type.ArrayType": [
    1,
    "javax.lang.model.type.ReferenceType"
  ],
  "javax.lang.model.type.DeclaredType": [
    3,
    "javax.lang.model.type.ReferenceType"
  ],
  "javax.lang.model.type.ErrorType": [
    0,
    "javax.lang.model.type.DeclaredType"
  ],
  "javax.lang.model.type.ExecutableType": [
    5,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.IntersectionType": [
    1,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.NoType": [
    0,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.NullType": [
    0,
    "javax.lang.model.type.ReferenceType"
  ],
  "javax.lang.model.type.PrimitiveType": [
    0,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.ReferenceType": [
    0,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.TypeMirror": [
    5,
    "javax.lang.model.AnnotatedConstruct"
  ],
  "javax.lang.model.type.TypeVariable": [
    3,
    "javax.lang.model.type.ReferenceType"
  ],
  "javax.lang.model.type.TypeVisitor": [
    14
  ],
  "javax.lang.model.type.UnionType": [
    1,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.type.WildcardType": [
    2,
    "javax.lang.model.type.TypeMirror"
  ],
  "javax.lang.model.util.Elements": [
    26
  ],
  "javax.lang.model.util.Types": [
    19
  ],
  "javax.management.ConstructorParameters": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.management.Descriptor": [
    11,
    "java.io.Serializable",
    "java.lang.Cloneable"
  ],
  "javax.management.DescriptorAccess": [
    1,
    "javax.management.DescriptorRead"
  ],
  "javax.management.DescriptorKey": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.management.DescriptorRead": [
    1
  ],
  "javax.management.DynamicMBean": [
    6
  ],
  "javax.management.MBeanRegistration": [
    4
  ],
  "javax.management.MBeanServer": [
    36,
    "javax.management.MBeanServerConnection"
  ],
  "javax.management.MBeanServerConnection": [
    25
  ],
  "javax.management.MBeanServerDelegateMBean": [
    7
  ],
  "javax.management.MXBean": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "javax.management.NotificationBroadcaster": [
    3
  ],
  "javax.management.NotificationEmitter": [
    1,
    "javax.management.NotificationBroadcaster"
  ],
  "javax.management.NotificationFilter": [
    1,
    "java.io.Serializable"
  ],
  "javax.management.NotificationListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.management.PersistentMBean": [
    2
  ],
  "javax.management.QueryExp": [
    2,
    "java.io.Serializable"
  ],
  "javax.management.ValueExp": [
    2,
    "java.io.Serializable"
  ],
  "javax.management.loading.ClassLoaderRepository": [
    3
  ],
  "javax.management.loading.MLetMBean": [
    10
  ],
  "javax.management.loading.PrivateClassLoader": [
    0
  ],
  "javax.management.modelmbean.ModelMBean": [
    2,
    "javax.management.DynamicMBean",
    "javax.management.PersistentMBean",
    "javax.management.modelmbean.ModelMBeanNotificationBroadcaster"
  ],
  "javax.management.modelmbean.ModelMBeanInfo": [
    16
  ],
  "javax.management.modelmbean.ModelMBeanNotificationBroadcaster": [
    6,
    "javax.management.NotificationBroadcaster"
  ],
  "javax.management.monitor.CounterMonitorMBean": [
    17,
    "javax.management.monitor.MonitorMBean"
  ],
  "javax.management.monitor.GaugeMonitorMBean": [
    13,
    "javax.management.monitor.MonitorMBean"
  ],
  "javax.management.monitor.MonitorMBean": [
    13
  ],
  "javax.management.monitor.StringMonitorMBean": [
    10,
    "javax.management.monitor.MonitorMBean"
  ],
  "javax.management.openmbean.CompositeData": [
    9
  ],
  "javax.management.openmbean.CompositeDataView": [
    1
  ],
  "javax.management.openmbean.OpenMBeanAttributeInfo": [
    6,
    "javax.management.openmbean.OpenMBeanParameterInfo"
  ],
  "javax.management.openmbean.OpenMBeanConstructorInfo": [
    6
  ],
  "javax.management.openmbean.OpenMBeanInfo": [
    9
  ],
  "javax.management.openmbean.OpenMBeanOperationInfo": [
    9
  ],
  "javax.management.openmbean.OpenMBeanParameterInfo": [
    15
  ],
  "javax.management.openmbean.TabularData": [
    16
  ],
  "javax.management.relation.Relation": [
    12
  ],
  "javax.management.relation.RelationServiceMBean": [
    34
  ],
  "javax.management.relation.RelationSupportMBean": [
    2,
    "javax.management.relation.Relation"
  ],
  "javax.management.relation.RelationType": [
    3,
    "java.io.Serializable"
  ],
  "javax.management.remote.JMXAddressable": [
    1
  ],
  "javax.management.remote.JMXAuthenticator": [
    1
  ],
  "javax.management.remote.JMXConnector": [
    9,
    "java.io.Closeable"
  ],
  "javax.management.remote.JMXConnectorProvider": [
    1
  ],
  "javax.management.remote.JMXConnectorServerMBean": [
    8
  ],
  "javax.management.remote.JMXConnectorServerProvider": [
    1
  ],
  "javax.management.remote.MBeanServerForwarder": [
    2,
    "javax.management.MBeanServer"
  ],
  "javax.management.remote.rmi.RMIConnection": [
    27,
    "java.io.Closeable",
    "java.rmi.Remote"
  ],
  "javax.management.remote.rmi.RMIServer": [
    2,
    "java.rmi.Remote"
  ],
  "javax.management.timer.TimerMBean": [
    23
  ],
  "javax.naming.Context": [
    29
  ],
  "javax.naming.Name": [
    15,
    "java.lang.Cloneable",
    "java.io.Serializable",
    "java.lang.Comparable"
  ],
  "javax.naming.NameParser": [
    1
  ],
  "javax.naming.NamingEnumeration": [
    3,
    "java.util.Enumeration"
  ],
  "javax.naming.Referenceable": [
    1
  ],
  "javax.naming.directory.Attribute": [
    16,
    "java.lang.Cloneable",
    "java.io.Serializable"
  ],
  "javax.naming.directory.Attributes": [
    9,
    "java.lang.Cloneable",
    "java.io.Serializable"
  ],
  "javax.naming.directory.DirContext": [
    26,
    "javax.naming.Context"
  ],
  "javax.naming.event.EventContext": [
    4,
    "javax.naming.Context"
  ],
  "javax.naming.event.EventDirContext": [
    4,
    "javax.naming.event.EventContext",
    "javax.naming.directory.DirContext"
  ],
  "javax.naming.event.NamespaceChangeListener": [
    3,
    "javax.naming.event.NamingListener"
  ],
  "javax.naming.event.NamingListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.naming.event.ObjectChangeListener": [
    1,
    "javax.naming.event.NamingListener"
  ],
  "javax.naming.ldap.Control": [
    3,
    "java.io.Serializable"
  ],
  "javax.naming.ldap.ExtendedRequest": [
    3,
    "java.io.Serializable"
  ],
  "javax.naming.ldap.ExtendedResponse": [
    2,
    "java.io.Serializable"
  ],
  "javax.naming.ldap.HasControls": [
    1
  ],
  "javax.naming.ldap.LdapContext": [
    7,
    "javax.naming.directory.DirContext"
  ],
  "javax.naming.ldap.UnsolicitedNotification": [
    2,
    "javax.naming.ldap.ExtendedResponse",
    "javax.naming.ldap.HasControls"
  ],
  "javax.naming.ldap.UnsolicitedNotificationListener": [
    1,
    "javax.naming.event.NamingListener"
  ],
  "javax.naming.spi.DirObjectFactory": [
    1,
    "javax.naming.spi.ObjectFactory"
  ],
  "javax.naming.spi.DirStateFactory": [
    1,
    "javax.naming.spi.StateFactory"
  ],
  "javax.naming.spi.InitialContextFactory": [
    1
  ],
  "javax.naming.spi.InitialContextFactoryBuilder": [
    1
  ],
  "javax.naming.spi.ObjectFactory": [
    1
  ],
  "javax.naming.spi.ObjectFactoryBuilder": [
    1
  ],
  "javax.naming.spi.Resolver": [
    2
  ],
  "javax.naming.spi.StateFactory": [
    1
  ],
  "javax.net.ssl.HandshakeCompletedListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.net.ssl.HostnameVerifier": [
    1
  ],
  "javax.net.ssl.KeyManager": [
    0
  ],
  "javax.net.ssl.ManagerFactoryParameters": [
    0
  ],
  "javax.net.ssl.SSLSession": [
    21
  ],
  "javax.net.ssl.SSLSessionBindingListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.net.ssl.SSLSessionContext": [
    6
  ],
  "javax.net.ssl.TrustManager": [
    0
  ],
  "javax.net.ssl.X509KeyManager": [
    6,
    "javax.net.ssl.KeyManager"
  ],
  "javax.net.ssl.X509TrustManager": [
    3,
    "javax.net.ssl.TrustManager"
  ],
  "javax.print.AttributeException": [
    2
  ],
  "javax.print.CancelablePrintJob": [
    1,
    "javax.print.DocPrintJob"
  ],
  "javax.print.Doc": [
    5
  ],
  "javax.print.DocPrintJob": [
    7
  ],
  "javax.print.FlavorException": [
    1
  ],
  "javax.print.MultiDoc": [
    2
  ],
  "javax.print.MultiDocPrintJob": [
    1,
    "javax.print.DocPrintJob"
  ],
  "javax.print.MultiDocPrintService": [
    1,
    "javax.print.PrintService"
  ],
  "javax.print.PrintService": [
    17
  ],
  "javax.print.URIException": [
    2
  ],
  "javax.print.attribute.Attribute": [
    2,
    "java.io.Serializable"
  ],
  "javax.print.attribute.AttributeSet": [
    13
  ],
  "javax.print.attribute.DocAttribute": [
    0,
    "javax.print.attribute.Attribute"
  ],
  "javax.print.attribute.DocAttributeSet": [
    2,
    "javax.print.attribute.AttributeSet"
  ],
  "javax.print.attribute.PrintJobAttribute": [
    0,
    "javax.print.attribute.Attribute"
  ],
  "javax.print.attribute.PrintJobAttributeSet": [
    2,
    "javax.print.attribute.AttributeSet"
  ],
  "javax.print.attribute.PrintRequestAttribute": [
    0,
    "javax.print.attribute.Attribute"
  ],
  "javax.print.attribute.PrintRequestAttributeSet": [
    2,
    "javax.print.attribute.AttributeSet"
  ],
  "javax.print.attribute.PrintServiceAttribute": [
    0,
    "javax.print.attribute.Attribute"
  ],
  "javax.print.attribute.PrintServiceAttributeSet": [
    2,
    "javax.print.attribute.AttributeSet"
  ],
  "javax.print.attribute.SupportedValuesAttribute": [
    0,
    "javax.print.attribute.Attribute"
  ],
  "javax.print.event.PrintJobAttributeListener": [
    1
  ],
  "javax.print.event.PrintJobListener": [
    6
  ],
  "javax.print.event.PrintServiceAttributeListener": [
    1
  ],
  "javax.script.Bindings": [
    6,
    "java.util.Map"
  ],
  "javax.script.Compilable": [
    2
  ],
  "javax.script.Invocable": [
    4
  ],
  "javax.script.ScriptContext": [
    14
  ],
  "javax.script.ScriptEngine": [
    14
  ],
  "javax.script.ScriptEngineFactory": [
    12
  ],
  "javax.security.auth.Destroyable": [
    2
  ],
  "javax.security.auth.Refreshable": [
    2
  ],
  "javax.security.auth.callback.Callback": [
    0
  ],
  "javax.security.auth.callback.CallbackHandler": [
    1
  ],
  "javax.security.auth.login.Configuration$Parameters": [
    0
  ],
  "javax.security.auth.spi.LoginModule": [
    5
  ],
  "javax.security.sasl.SaslClient": [
    8
  ],
  "javax.security.sasl.SaslClientFactory": [
    2
  ],
  "javax.security.sasl.SaslServer": [
    8
  ],
  "javax.security.sasl.SaslServerFactory": [
    2
  ],
  "javax.sound.midi.ControllerEventListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.sound.midi.MetaEventListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.sound.midi.MidiChannel": [
    26
  ],
  "javax.sound.midi.MidiDevice": [
    11,
    "java.lang.AutoCloseable"
  ],
  "javax.sound.midi.MidiDeviceReceiver": [
    1,
    "javax.sound.midi.Receiver"
  ],
  "javax.sound.midi.MidiDeviceTransmitter": [
    1,
    "javax.sound.midi.Transmitter"
  ],
  "javax.sound.midi.Receiver": [
    2,
    "java.lang.AutoCloseable"
  ],
  "javax.sound.midi.Sequencer": [
    43,
    "javax.sound.midi.MidiDevice"
  ],
  "javax.sound.midi.Soundbank": [
    7
  ],
  "javax.sound.midi.Synthesizer": [
    15,
    "javax.sound.midi.MidiDevice"
  ],
  "javax.sound.midi.Transmitter": [
    3,
    "java.lang.AutoCloseable"
  ],
  "javax.sound.sampled.Clip": [
    8,
    "javax.sound.sampled.DataLine"
  ],
  "javax.sound.sampled.DataLine": [
    13,
    "javax.sound.sampled.Line"
  ],
  "javax.sound.sampled.Line": [
    9,
    "java.lang.AutoCloseable"
  ],
  "javax.sound.sampled.LineListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.sound.sampled.Mixer": [
    13,
    "javax.sound.sampled.Line"
  ],
  "javax.sound.sampled.Port": [
    0,
    "javax.sound.sampled.Line"
  ],
  "javax.sound.sampled.SourceDataLine": [
    3,
    "javax.sound.sampled.DataLine"
  ],
  "javax.sound.sampled.TargetDataLine": [
    3,
    "javax.sound.sampled.DataLine"
  ],
  "javax.sql.CommonDataSource": [
    6
  ],
  "javax.sql.ConnectionEventListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.sql.ConnectionPoolDataSource": [
    7,
    "javax.sql.CommonDataSource"
  ],
  "javax.sql.DataSource": [
    7,
    "javax.sql.CommonDataSource",
    "java.sql.Wrapper"
  ],
  "javax.sql.PooledConnection": [
    6
  ],
  "javax.sql.PooledConnectionBuilder": [
    5
  ],
  "javax.sql.RowSet": [
    115,
    "java.sql.ResultSet"
  ],
  "javax.sql.RowSetInternal": [
    5
  ],
  "javax.sql.RowSetListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.sql.RowSetMetaData": [
    17,
    "java.sql.ResultSetMetaData"
  ],
  "javax.sql.RowSetReader": [
    1
  ],
  "javax.sql.RowSetWriter": [
    1
  ],
  "javax.sql.StatementEventListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.sql.XAConnection": [
    1,
    "javax.sql.PooledConnection"
  ],
  "javax.sql.XAConnectionBuilder": [
    5
  ],
  "javax.sql.XADataSource": [
    7,
    "javax.sql.CommonDataSource"
  ],
  "javax.sql.rowset.CachedRowSet": [
    41,
    "javax.sql.RowSet",
    "javax.sql.rowset.Joinable"
  ],
  "javax.sql.rowset.FilteredRowSet": [
    2,
    "javax.sql.rowset.WebRowSet"
  ],
  "javax.sql.rowset.JdbcRowSet": [
    8,
    "javax.sql.RowSet",
    "javax.sql.rowset.Joinable"
  ],
  "javax.sql.rowset.JoinRowSet": [
    16,
    "javax.sql.rowset.WebRowSet"
  ],
  "javax.sql.rowset.Joinable": [
    10
  ],
  "javax.sql.rowset.Predicate": [
    3
  ],
  "javax.sql.rowset.RowSetFactory": [
    5
  ],
  "javax.sql.rowset.WebRowSet": [
    6,
    "javax.sql.rowset.CachedRowSet"
  ],
  "javax.sql.rowset.spi.SyncResolver": [
    7,
    "javax.sql.RowSet"
  ],
  "javax.sql.rowset.spi.TransactionalWriter": [
    3,
    "javax.sql.RowSetWriter"
  ],
  "javax.sql.rowset.spi.XmlReader": [
    1,
    "javax.sql.RowSetReader"
  ],
  "javax.sql.rowset.spi.XmlWriter": [
    1,
    "javax.sql.RowSetWriter"
  ],
  "javax.swing.Action": [
    7,
    "java.awt.event.ActionListener"
  ],
  "javax.swing.BoundedRangeModel": [
    13
  ],
  "javax.swing.ButtonModel": [
    22,
    "java.awt.ItemSelectable"
  ],
  "javax.swing.CellEditor": [
    7
  ],
  "javax.swing.ComboBoxEditor": [
    6
  ],
  "javax.swing.ComboBoxModel": [
    2,
    "javax.swing.ListModel"
  ],
  "javax.swing.DesktopManager": [
    15
  ],
  "javax.swing.Icon": [
    3
  ],
  "javax.swing.JComboBox$KeySelectionManager": [
    1
  ],
  "javax.swing.ListCellRenderer": [
    1
  ],
  "javax.swing.ListModel": [
    4
  ],
  "javax.swing.ListSelectionModel": [
    22
  ],
  "javax.swing.MenuElement": [
    5
  ],
  "javax.swing.MutableComboBoxModel": [
    4,
    "javax.swing.ComboBoxModel"
  ],
  "javax.swing.Painter": [
    1
  ],
  "javax.swing.Renderer": [
    2
  ],
  "javax.swing.RootPaneContainer": [
    7
  ],
  "javax.swing.ScrollPaneConstants": [
    0
  ],
  "javax.swing.Scrollable": [
    5
  ],
  "javax.swing.SingleSelectionModel": [
    6
  ],
  "javax.swing.SpinnerModel": [
    6
  ],
  "javax.swing.SwingConstants": [
    0
  ],
  "javax.swing.SwingContainer": [
    2,
    "java.lang.annotation.Annotation"
  ],
  "javax.swing.UIClientPropertyKey": [
    0
  ],
  "javax.swing.UIDefaults$ActiveValue": [
    1
  ],
  "javax.swing.UIDefaults$LazyValue": [
    1
  ],
  "javax.swing.WindowConstants": [
    0
  ],
  "javax.swing.border.Border": [
    3
  ],
  "javax.swing.colorchooser.ColorSelectionModel": [
    4
  ],
  "javax.swing.event.AncestorListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.CaretListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.CellEditorListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.swing.event.ChangeListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.DocumentEvent": [
    5
  ],
  "javax.swing.event.DocumentEvent$ElementChange": [
    4
  ],
  "javax.swing.event.DocumentListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.HyperlinkListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.InternalFrameListener": [
    7,
    "java.util.EventListener"
  ],
  "javax.swing.event.ListDataListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.ListSelectionListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.MenuDragMouseListener": [
    4,
    "java.util.EventListener"
  ],
  "javax.swing.event.MenuKeyListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.MenuListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.MouseInputListener": [
    0,
    "java.awt.event.MouseListener",
    "java.awt.event.MouseMotionListener"
  ],
  "javax.swing.event.PopupMenuListener": [
    3,
    "java.util.EventListener"
  ],
  "javax.swing.event.RowSorterListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.TableColumnModelListener": [
    5,
    "java.util.EventListener"
  ],
  "javax.swing.event.TableModelListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.TreeExpansionListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.swing.event.TreeModelListener": [
    4,
    "java.util.EventListener"
  ],
  "javax.swing.event.TreeSelectionListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.event.TreeWillExpandListener": [
    2,
    "java.util.EventListener"
  ],
  "javax.swing.event.UndoableEditListener": [
    1,
    "java.util.EventListener"
  ],
  "javax.swing.plaf.UIResource": [
    0
  ],
  "javax.swing.plaf.basic.ComboPopup": [
    8
  ],
  "javax.swing.plaf.synth.SynthConstants": [
    0
  ],
  "javax.swing.plaf.synth.SynthIcon": [
    6,
    "javax.swing.Icon"
  ],
  "javax.swing.plaf.synth.SynthUI": [
    2,
    "javax.swing.plaf.synth.SynthConstants"
  ],
  "javax.swing.table.TableCellEditor": [
    1,
    "javax.swing.CellEditor"
  ],
  "javax.swing.table.TableCellRenderer": [
    1
  ],
  "javax.swing.table.TableColumnModel": [
    19
  ],
  "javax.swing.table.TableModel": [
    9
  ],
  "javax.swing.text.AbstractDocument$AttributeContext": [
    7
  ],
  "javax.swing.text.AbstractDocument$Content": [
    6
  ],
  "javax.swing.text.AttributeSet": [
    9
  ],
  "javax.swing.text.AttributeSet$CharacterAttribute": [
    0
  ],
  "javax.swing.text.AttributeSet$ColorAttribute": [
    0
  ],
  "javax.swing.text.AttributeSet$FontAttribute": [
    0
  ],
  "javax.swing.text.AttributeSet$ParagraphAttribute": [
    0
  ],
  "javax.swing.text.Caret": [
    17
  ],
  "javax.swing.text.Document": [
    17
  ],
  "javax.swing.text.Element": [
    10
  ],
  "javax.swing.text.Highlighter": [
    8
  ],
  "javax.swing.text.Highlighter$Highlight": [
    3
  ],
  "javax.swing.text.Highlighter$HighlightPainter": [
    1
  ],
  "javax.swing.text.Keymap": [
    13
  ],
  "javax.swing.text.MutableAttributeSet": [
    6,
    "javax.swing.text.AttributeSet"
  ],
  "javax.swing.text.Position": [
    1
  ],
  "javax.swing.text.Style": [
    3,
    "javax.swing.text.MutableAttributeSet"
  ],
  "javax.swing.text.StyledDocument": [
    12,
    "javax.swing.text.Document"
  ],
  "javax.swing.text.TabExpander": [
    1
  ],
  "javax.swing.text.TabableView": [
    2
  ],
  "javax.swing.text.ViewFactory": [
    1
  ],
  "javax.swing.text.html.parser.DTDConstants": [
    0
  ],
  "javax.swing.tree.MutableTreeNode": [
    6,
    "javax.swing.tree.TreeNode"
  ],
  "javax.swing.tree.RowMapper": [
    1
  ],
  "javax.swing.tree.TreeCellEditor": [
    1,
    "javax.swing.CellEditor"
  ],
  "javax.swing.tree.TreeCellRenderer": [
    1
  ],
  "javax.swing.tree.TreeModel": [
    8
  ],
  "javax.swing.tree.TreeNode": [
    7
  ],
  "javax.swing.tree.TreeSelectionModel": [
    27
  ],
  "javax.swing.undo.StateEditable": [
    2
  ],
  "javax.swing.undo.UndoableEdit": [
    11
  ],
  "javax.tools.Diagnostic": [
    9
  ],
  "javax.tools.DiagnosticListener": [
    1
  ],
  "javax.tools.DocumentationTool": [
    2,
    "javax.tools.Tool",
    "javax.tools.OptionChecker"
  ],
  "javax.tools.DocumentationTool$DocumentationTask": [
    4,
    "java.util.concurrent.Callable"
  ],
  "javax.tools.FileObject": [
    9
  ],
  "javax.tools.JavaCompiler": [
    2,
    "javax.tools.Tool",
    "javax.tools.OptionChecker"
  ],
  "javax.tools.JavaCompiler$CompilationTask": [
    5,
    "java.util.concurrent.Callable"
  ],
  "javax.tools.JavaFileManager": [
    18,
    "java.io.Closeable",
    "java.io.Flushable",
    "javax.tools.OptionChecker"
  ],
  "javax.tools.JavaFileManager$Location": [
    3
  ],
  "javax.tools.JavaFileObject": [
    4,
    "javax.tools.FileObject"
  ],
  "javax.tools.OptionChecker": [
    1
  ],
  "javax.tools.StandardJavaFileManager": [
    14,
    "javax.tools.JavaFileManager"
  ],
  "javax.tools.StandardJavaFileManager$PathFactory": [
    1
  ],
  "javax.tools.Tool": [
    3
  ],
  "javax.transaction.xa.XAResource": [
    10
  ],
  "javax.transaction.xa.Xid": [
    3
  ],
  "javax.xml.catalog.Catalog": [
    4
  ],
  "javax.xml.catalog.CatalogResolver": [
    5,
    "org.xml.sax.EntityResolver",
    "javax.xml.stream.XMLResolver",
    "javax.xml.transform.URIResolver",
    "org.w3c.dom.ls.LSResourceResolver"
  ],
  "javax.xml.crypto.AlgorithmMethod": [
    2
  ],
  "javax.xml.crypto.Data": [
    0
  ],
  "javax.xml.crypto.KeySelectorResult": [
    1
  ],
  "javax.xml.crypto.NodeSetData": [
    1,
    "javax.xml.crypto.Data",
    "java.lang.Iterable"
  ],
  "javax.xml.crypto.URIDereferencer": [
    1
  ],
  "javax.xml.crypto.URIReference": [
    2
  ],
  "javax.xml.crypto.XMLCryptoContext": [
    14
  ],
  "javax.xml.crypto.XMLStructure": [
    1
  ],
  "javax.xml.crypto.dom.DOMURIReference": [
    1,
    "javax.xml.crypto.URIReference"
  ],
  "javax.xml.crypto.dsig.CanonicalizationMethod": [
    1,
    "javax.xml.crypto.dsig.Transform"
  ],
  "javax.xml.crypto.dsig.DigestMethod": [
    1,
    "javax.xml.crypto.XMLStructure",
    "javax.xml.crypto.AlgorithmMethod"
  ],
  "javax.xml.crypto.dsig.Manifest": [
    2,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.Reference": [
    8,
    "javax.xml.crypto.URIReference",
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.SignatureMethod": [
    1,
    "javax.xml.crypto.XMLStructure",
    "javax.xml.crypto.AlgorithmMethod"
  ],
  "javax.xml.crypto.dsig.SignatureProperties": [
    2,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.SignatureProperty": [
    3,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.SignedInfo": [
    5,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.Transform": [
    3,
    "javax.xml.crypto.XMLStructure",
    "javax.xml.crypto.AlgorithmMethod"
  ],
  "javax.xml.crypto.dsig.XMLObject": [
    4,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.XMLSignContext": [
    0,
    "javax.xml.crypto.XMLCryptoContext"
  ],
  "javax.xml.crypto.dsig.XMLSignature": [
    8,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.XMLSignature$SignatureValue": [
    3,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.XMLValidateContext": [
    0,
    "javax.xml.crypto.XMLCryptoContext"
  ],
  "javax.xml.crypto.dsig.keyinfo.KeyInfo": [
    3,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.KeyName": [
    1,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.KeyValue": [
    1,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.PGPData": [
    3,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.RetrievalMethod": [
    3,
    "javax.xml.crypto.URIReference",
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.X509Data": [
    1,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.keyinfo.X509IssuerSerial": [
    2,
    "javax.xml.crypto.XMLStructure"
  ],
  "javax.xml.crypto.dsig.spec.C14NMethodParameterSpec": [
    0,
    "javax.xml.crypto.dsig.spec.TransformParameterSpec"
  ],
  "javax.xml.crypto.dsig.spec.DigestMethodParameterSpec": [
    0,
    "java.security.spec.AlgorithmParameterSpec"
  ],
  "javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec": [
    0,
    "java.security.spec.AlgorithmParameterSpec"
  ],
  "javax.xml.crypto.dsig.spec.TransformParameterSpec": [
    0,
    "java.security.spec.AlgorithmParameterSpec"
  ],
  "javax.xml.namespace.NamespaceContext": [
    3
  ],
  "javax.xml.stream.EventFilter": [
    1
  ],
  "javax.xml.stream.Location": [
    5
  ],
  "javax.xml.stream.StreamFilter": [
    1
  ],
  "javax.xml.stream.XMLEventReader": [
    7,
    "java.util.Iterator"
  ],
  "javax.xml.stream.XMLEventWriter": [
    9,
    "javax.xml.stream.util.XMLEventConsumer"
  ],
  "javax.xml.stream.XMLReporter": [
    1
  ],
  "javax.xml.stream.XMLResolver": [
    1
  ],
  "javax.xml.stream.XMLStreamConstants": [
    0
  ],
  "javax.xml.stream.XMLStreamReader": [
    45,
    "javax.xml.stream.XMLStreamConstants"
  ],
  "javax.xml.stream.XMLStreamWriter": [
    32
  ],
  "javax.xml.stream.events.Attribute": [
    4,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.Characters": [
    4,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.Comment": [
    1,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.DTD": [
    4,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.EndDocument": [
    0,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.EndElement": [
    2,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.EntityDeclaration": [
    6,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.EntityReference": [
    2,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.Namespace": [
    3,
    "javax.xml.stream.events.Attribute"
  ],
  "javax.xml.stream.events.NotationDeclaration": [
    3,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.ProcessingInstruction": [
    2,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.StartDocument": [
    6,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.StartElement": [
    6,
    "javax.xml.stream.events.XMLEvent"
  ],
  "javax.xml.stream.events.XMLEvent": [
    16,
    "javax.xml.stream.XMLStreamConstants"
  ],
  "javax.xml.stream.util.XMLEventAllocator": [
    3
  ],
  "javax.xml.stream.util.XMLEventConsumer": [
    1
  ],
  "javax.xml.transform.ErrorListener": [
    3
  ],
  "javax.xml.transform.Result": [
    2
  ],
  "javax.xml.transform.Source": [
    3
  ],
  "javax.xml.transform.SourceLocator": [
    4
  ],
  "javax.xml.transform.Templates": [
    2
  ],
  "javax.xml.transform.URIResolver": [
    1
  ],
  "javax.xml.transform.dom.DOMLocator": [
    1,
    "javax.xml.transform.SourceLocator"
  ],
  "javax.xml.transform.sax.TemplatesHandler": [
    3,
    "org.xml.sax.ContentHandler"
  ],
  "javax.xml.transform.sax.TransformerHandler": [
    4,
    "org.xml.sax.ContentHandler",
    "org.xml.sax.ext.LexicalHandler",
    "org.xml.sax.DTDHandler"
  ],
  "javax.xml.xpath.XPath": [
    16
  ],
  "javax.xml.xpath.XPathEvaluationResult": [
    2
  ],
  "javax.xml.xpath.XPathExpression": [
    8
  ],
  "javax.xml.xpath.XPathFunction": [
    1
  ],
  "javax.xml.xpath.XPathFunctionResolver": [
    1
  ],
  "javax.xml.xpath.XPathNodes": [
    3,
    "java.lang.Iterable"
  ],
  "javax.xml.xpath.XPathVariableResolver": [
    1
  ],
  "jdk.dynalink.Namespace": [
    0
  ],
  "jdk.dynalink.Operation": [
    3
  ],
  "jdk.dynalink.RelinkableCallSite": [
    4
  ],
  "jdk.dynalink.beans.MissingMemberHandlerFactory": [
    1
  ],
  "jdk.dynalink.linker.ConversionComparator": [
    1
  ],
  "jdk.dynalink.linker.GuardedInvocationTransformer": [
    1
  ],
  "jdk.dynalink.linker.GuardingDynamicLinker": [
    1
  ],
  "jdk.dynalink.linker.GuardingTypeConverterFactory": [
    1
  ],
  "jdk.dynalink.linker.LinkRequest": [
    5
  ],
  "jdk.dynalink.linker.LinkerServices": [
    8
  ],
  "jdk.dynalink.linker.MethodHandleTransformer": [
    1
  ],
  "jdk.dynalink.linker.MethodTypeConversionStrategy": [
    1
  ],
  "jdk.dynalink.linker.TypeBasedGuardingDynamicLinker": [
    1,
    "jdk.dynalink.linker.GuardingDynamicLinker"
  ],
  "jdk.javadoc.doclet.Doclet": [
    5
  ],
  "jdk.javadoc.doclet.Doclet$Option": [
    6
  ],
  "jdk.javadoc.doclet.DocletEnvironment": [
    11
  ],
  "jdk.javadoc.doclet.Reporter": [
    3
  ],
  "jdk.javadoc.doclet.Taglet": [
    5
  ],
  "jdk.jfr.BooleanFlag": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Category": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.ContentType": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.DataAmount": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Description": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Enabled": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Experimental": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.FlightRecorderListener": [
    2
  ],
  "jdk.jfr.Frequency": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Label": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.MemoryAddress": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.MetadataDefinition": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Name": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Percentage": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Period": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Registered": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Relational": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.SettingDefinition": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.StackTrace": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Threshold": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Timespan": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Timestamp": [
    1,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.TransitionFrom": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.TransitionTo": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jfr.Unsigned": [
    0,
    "java.lang.annotation.Annotation"
  ],
  "jdk.jshell.SourceCodeAnalysis$CompletionInfo": [
    3
  ],
  "jdk.jshell.SourceCodeAnalysis$Documentation": [
    2
  ],
  "jdk.jshell.SourceCodeAnalysis$SnippetWrapper": [
    6
  ],
  "jdk.jshell.SourceCodeAnalysis$Suggestion": [
    2
  ],
  "jdk.jshell.execution.LoaderDelegate": [
    4
  ],
  "jdk.jshell.spi.ExecutionControl": [
    10,
    "java.lang.AutoCloseable"
  ],
  "jdk.jshell.spi.ExecutionControlProvider": [
    3
  ],
  "jdk.jshell.spi.ExecutionEnv": [
    5
  ],
  "jdk.jshell.tool.JavaShellToolBuilder": [
    14
  ],
  "jdk.management.jfr.FlightRecorderMXBean": [
    19,
    "java.lang.management.PlatformManagedObject"
  ],
  "jdk.nashorn.api.scripting.ClassFilter": [
    1
  ],
  "jdk.nashorn.api.scripting.JSObject": [
    20
  ],
  "jdk.nashorn.api.tree.ArrayAccessTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ArrayLiteralTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.AssignmentTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.BinaryTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.BlockTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.BreakTree": [
    1,
    "jdk.nashorn.api.tree.GotoTree"
  ],
  "jdk.nashorn.api.tree.CaseTree": [
    2,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.CatchTree": [
    3,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.ClassDeclarationTree": [
    4,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.ClassExpressionTree": [
    4,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.CompilationUnitTree": [
    5,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.CompoundAssignmentTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ConditionalExpressionTree": [
    3,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ConditionalLoopTree": [
    1,
    "jdk.nashorn.api.tree.LoopTree"
  ],
  "jdk.nashorn.api.tree.ContinueTree": [
    1,
    "jdk.nashorn.api.tree.GotoTree"
  ],
  "jdk.nashorn.api.tree.DebuggerTree": [
    0,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.Diagnostic": [
    7
  ],
  "jdk.nashorn.api.tree.DiagnosticListener": [
    1
  ],
  "jdk.nashorn.api.tree.DoWhileLoopTree": [
    2,
    "jdk.nashorn.api.tree.ConditionalLoopTree"
  ],
  "jdk.nashorn.api.tree.EmptyStatementTree": [
    0,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.ErroneousTree": [
    0,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ExportEntryTree": [
    4,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.ExpressionStatementTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.ExpressionTree": [
    0,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.ForInLoopTree": [
    4,
    "jdk.nashorn.api.tree.LoopTree"
  ],
  "jdk.nashorn.api.tree.ForLoopTree": [
    4,
    "jdk.nashorn.api.tree.ConditionalLoopTree"
  ],
  "jdk.nashorn.api.tree.ForOfLoopTree": [
    3,
    "jdk.nashorn.api.tree.LoopTree"
  ],
  "jdk.nashorn.api.tree.FunctionCallTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.FunctionDeclarationTree": [
    5,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.FunctionExpressionTree": [
    6,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.GotoTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.IdentifierTree": [
    7,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.IfTree": [
    3,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.ImportEntryTree": [
    3,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.InstanceOfTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.LabeledStatementTree": [
    2,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.LineMap": [
    2
  ],
  "jdk.nashorn.api.tree.LiteralTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.LoopTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.MemberSelectTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ModuleTree": [
    4,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.NewTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ObjectLiteralTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ParenthesizedTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.Parser": [
    7
  ],
  "jdk.nashorn.api.tree.PropertyTree": [
    6,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.RegExpLiteralTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ReturnTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.SpreadTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.StatementTree": [
    0,
    "jdk.nashorn.api.tree.Tree"
  ],
  "jdk.nashorn.api.tree.SwitchTree": [
    2,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.TemplateLiteralTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.ThrowTree": [
    1,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.Tree": [
    4
  ],
  "jdk.nashorn.api.tree.TreeVisitor": [
    51
  ],
  "jdk.nashorn.api.tree.TryTree": [
    3,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.UnaryTree": [
    1,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nashorn.api.tree.VariableTree": [
    4,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.WhileLoopTree": [
    2,
    "jdk.nashorn.api.tree.ConditionalLoopTree"
  ],
  "jdk.nashorn.api.tree.WithTree": [
    2,
    "jdk.nashorn.api.tree.StatementTree"
  ],
  "jdk.nashorn.api.tree.YieldTree": [
    2,
    "jdk.nashorn.api.tree.ExpressionTree"
  ],
  "jdk.nio.Channels$SelectableChannelCloser": [
    2
  ],
  "org.ietf.jgss.GSSContext": [
    40
  ],
  "org.ietf.jgss.GSSCredential": [
    12,
    "java.lang.Cloneable"
  ],
  "org.ietf.jgss.GSSName": [
    9
  ],
  "org.w3c.dom.Attr": [
    7,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.CDATASection": [
    0,
    "org.w3c.dom.Text"
  ],
  "org.w3c.dom.CharacterData": [
    8,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.Comment": [
    0,
    "org.w3c.dom.CharacterData"
  ],
  "org.w3c.dom.DOMConfiguration": [
    4
  ],
  "org.w3c.dom.DOMError": [
    6
  ],
  "org.w3c.dom.DOMErrorHandler": [
    1
  ],
  "org.w3c.dom.DOMImplementation": [
    4
  ],
  "org.w3c.dom.DOMImplementationList": [
    2
  ],
  "org.w3c.dom.DOMImplementationSource": [
    2
  ],
  "org.w3c.dom.DOMLocator": [
    6
  ],
  "org.w3c.dom.DOMStringList": [
    3
  ],
  "org.w3c.dom.Document": [
    31,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.DocumentFragment": [
    0,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.DocumentType": [
    6,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.Element": [
    20,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.ElementTraversal": [
    5
  ],
  "org.w3c.dom.Entity": [
    6,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.EntityReference": [
    0,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.NameList": [
    5
  ],
  "org.w3c.dom.NamedNodeMap": [
    8
  ],
  "org.w3c.dom.Node": [
    37
  ],
  "org.w3c.dom.NodeList": [
    2
  ],
  "org.w3c.dom.Notation": [
    2,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.ProcessingInstruction": [
    3,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.Text": [
    4,
    "org.w3c.dom.CharacterData"
  ],
  "org.w3c.dom.TypeInfo": [
    3
  ],
  "org.w3c.dom.UserDataHandler": [
    1
  ],
  "org.w3c.dom.css.CSS2Properties": [
    244
  ],
  "org.w3c.dom.css.CSSCharsetRule": [
    2,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSFontFaceRule": [
    1,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSImportRule": [
    3,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSMediaRule": [
    4,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSPageRule": [
    3,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSPrimitiveValue": [
    8,
    "org.w3c.dom.css.CSSValue"
  ],
  "org.w3c.dom.css.CSSRule": [
    5
  ],
  "org.w3c.dom.css.CSSRuleList": [
    2
  ],
  "org.w3c.dom.css.CSSStyleDeclaration": [
    10
  ],
  "org.w3c.dom.css.CSSStyleRule": [
    3,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSStyleSheet": [
    4,
    "org.w3c.dom.stylesheets.StyleSheet"
  ],
  "org.w3c.dom.css.CSSUnknownRule": [
    0,
    "org.w3c.dom.css.CSSRule"
  ],
  "org.w3c.dom.css.CSSValue": [
    3
  ],
  "org.w3c.dom.css.CSSValueList": [
    2,
    "org.w3c.dom.css.CSSValue"
  ],
  "org.w3c.dom.css.Counter": [
    3
  ],
  "org.w3c.dom.css.DOMImplementationCSS": [
    1,
    "org.w3c.dom.DOMImplementation"
  ],
  "org.w3c.dom.css.DocumentCSS": [
    1,
    "org.w3c.dom.stylesheets.DocumentStyle"
  ],
  "org.w3c.dom.css.ElementCSSInlineStyle": [
    1
  ],
  "org.w3c.dom.css.RGBColor": [
    3
  ],
  "org.w3c.dom.css.Rect": [
    4
  ],
  "org.w3c.dom.css.ViewCSS": [
    1,
    "org.w3c.dom.views.AbstractView"
  ],
  "org.w3c.dom.events.DocumentEvent": [
    1
  ],
  "org.w3c.dom.events.Event": [
    10
  ],
  "org.w3c.dom.events.EventListener": [
    1
  ],
  "org.w3c.dom.events.EventTarget": [
    3
  ],
  "org.w3c.dom.events.MouseEvent": [
    11,
    "org.w3c.dom.events.UIEvent"
  ],
  "org.w3c.dom.events.MutationEvent": [
    6,
    "org.w3c.dom.events.Event"
  ],
  "org.w3c.dom.events.UIEvent": [
    3,
    "org.w3c.dom.events.Event"
  ],
  "org.w3c.dom.html.HTMLAnchorElement": [
    26,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLAppletElement": [
    22,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLAreaElement": [
    16,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLBRElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLBaseElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLBaseFontElement": [
    6,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLBodyElement": [
    12,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLButtonElement": [
    12,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLCollection": [
    3
  ],
  "org.w3c.dom.html.HTMLDListElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLDOMImplementation": [
    1,
    "org.w3c.dom.DOMImplementation"
  ],
  "org.w3c.dom.html.HTMLDirectoryElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLDivElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLDocument": [
    19,
    "org.w3c.dom.Document"
  ],
  "org.w3c.dom.html.HTMLElement": [
    10,
    "org.w3c.dom.Element"
  ],
  "org.w3c.dom.html.HTMLFieldSetElement": [
    1,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLFontElement": [
    6,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLFormElement": [
    16,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLFrameElement": [
    17,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLFrameSetElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLHRElement": [
    8,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLHeadElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLHeadingElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLHtmlElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLIFrameElement": [
    21,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLImageElement": [
    26,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLInputElement": [
    38,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLIsIndexElement": [
    3,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLLIElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLLabelElement": [
    5,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLLegendElement": [
    5,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLLinkElement": [
    18,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLMapElement": [
    3,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLMenuElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLMetaElement": [
    8,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLModElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLOListElement": [
    6,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLObjectElement": [
    36,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLOptGroupElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLOptionElement": [
    13,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLParagraphElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLParamElement": [
    8,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLPreElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLQuoteElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLScriptElement": [
    14,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLSelectElement": [
    22,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLStyleElement": [
    6,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableCaptionElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableCellElement": [
    29,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableColElement": [
    12,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableElement": [
    34,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableRowElement": [
    15,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTableSectionElement": [
    11,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTextAreaElement": [
    23,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLTitleElement": [
    2,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.html.HTMLUListElement": [
    4,
    "org.w3c.dom.html.HTMLElement"
  ],
  "org.w3c.dom.ls.DOMImplementationLS": [
    4
  ],
  "org.w3c.dom.ls.LSInput": [
    16
  ],
  "org.w3c.dom.ls.LSLoadEvent": [
    2,
    "org.w3c.dom.events.Event"
  ],
  "org.w3c.dom.ls.LSOutput": [
    8
  ],
  "org.w3c.dom.ls.LSParser": [
    9
  ],
  "org.w3c.dom.ls.LSParserFilter": [
    3
  ],
  "org.w3c.dom.ls.LSProgressEvent": [
    3,
    "org.w3c.dom.events.Event"
  ],
  "org.w3c.dom.ls.LSResourceResolver": [
    1
  ],
  "org.w3c.dom.ls.LSSerializer": [
    8
  ],
  "org.w3c.dom.ls.LSSerializerFilter": [
    1,
    "org.w3c.dom.traversal.NodeFilter"
  ],
  "org.w3c.dom.ranges.DocumentRange": [
    1
  ],
  "org.w3c.dom.ranges.Range": [
    24
  ],
  "org.w3c.dom.stylesheets.DocumentStyle": [
    1
  ],
  "org.w3c.dom.stylesheets.LinkStyle": [
    1
  ],
  "org.w3c.dom.stylesheets.MediaList": [
    6
  ],
  "org.w3c.dom.stylesheets.StyleSheet": [
    8
  ],
  "org.w3c.dom.stylesheets.StyleSheetList": [
    2
  ],
  "org.w3c.dom.traversal.DocumentTraversal": [
    2
  ],
  "org.w3c.dom.traversal.NodeFilter": [
    1
  ],
  "org.w3c.dom.traversal.NodeIterator": [
    7
  ],
  "org.w3c.dom.traversal.TreeWalker": [
    13
  ],
  "org.w3c.dom.views.AbstractView": [
    1
  ],
  "org.w3c.dom.views.DocumentView": [
    1
  ],
  "org.w3c.dom.xpath.XPathEvaluator": [
    3
  ],
  "org.w3c.dom.xpath.XPathExpression": [
    1
  ],
  "org.w3c.dom.xpath.XPathNSResolver": [
    1
  ],
  "org.w3c.dom.xpath.XPathNamespace": [
    1,
    "org.w3c.dom.Node"
  ],
  "org.w3c.dom.xpath.XPathResult": [
    9
  ],
  "org.xml.sax.AttributeList": [
    6
  ],
  "org.xml.sax.Attributes": [
    12
  ],
  "org.xml.sax.ContentHandler": [
    11
  ],
  "org.xml.sax.DTDHandler": [
    2
  ],
  "org.xml.sax.DocumentHandler": [
    8
  ],
  "org.xml.sax.EntityResolver": [
    1
  ],
  "org.xml.sax.ErrorHandler": [
    3
  ],
  "org.xml.sax.Locator": [
    4
  ],
  "org.xml.sax.Parser": [
    7
  ],
  "org.xml.sax.XMLFilter": [
    2,
    "org.xml.sax.XMLReader"
  ],
  "org.xml.sax.XMLReader": [
    14
  ],
  "org.xml.sax.ext.Attributes2": [
    6,
    "org.xml.sax.Attributes"
  ],
  "org.xml.sax.ext.DeclHandler": [
    4
  ],
  "org.xml.sax.ext.EntityResolver2": [
    2,
    "org.xml.sax.EntityResolver"
  ],
  "org.xml.sax.ext.LexicalHandler": [
    7
  ],
  "org.xml.sax.ext.Locator2": [
    2,
    "org.xml.sax.Locator"
  ]
};

// src/commands/install.ts
async function install_default(offline) {
  if (!import_fs5.default.existsSync(PATH.PACKAGE)) {
    console.error(import_chalk3.default.red(PATH.PACKAGE + " does not exist."));
    process.exit(code.PROJECT_NOT_FOUND);
  }
  if (!offline) {
    npmInstall();
    gradleInstall();
  }
  const jars = listFilesByExt("lib", ".jar");
  if (jars.length > 0) {
    console.log("Parsing classes from the following libraries:");
    jars.map((it) => console.log("  * " + it));
    const classes = await listLibClasses(jars);
    console.log(`Found ${import_chalk3.default.green(classes.length)} classes`);
    console.log("Generating typescript definitions...");
    parse(jars, interfaces_default, classes, import_path4.default.join(process.cwd(), "lib", "@types"));
  }
}
async function listLibClasses(jars) {
  const classes = {};
  for (const jar of jars) {
    const data = import_fs5.default.readFileSync(jar);
    const files = (await import_jszip.default.loadAsync(data)).files;
    Object.keys(files).forEach((it) => {
      if (it.endsWith(".class")) {
        const key = it.replace(/(\$\d+)*\.class$/, "").replace(/\//g, ".");
        if (key.split(".").reverse()[0].indexOf("-") < 0) {
          classes[key] = true;
        }
      }
    });
  }
  return Object.keys(classes);
}
function npmInstall() {
  const child = (0, import_child_process3.spawnSync)("npm", ["install"], { stdio: "inherit" });
  if (child.status)
    process.exit(child.status);
}
function gradleInstall() {
  import_fs5.default.mkdirSync(import_path4.default.join("lib", "@types"), { recursive: true });
  import_fs5.default.writeFileSync(import_path4.default.join("lib", "@types", "index.d.ts"), "");
  const mvnDependencies = {};
  for (const it of [PATH.PACKAGE, ...new import_glob.GlobSync(import_path4.default.join("node_modules", "**", PATH.PACKAGE)).found]) {
    const pkg = JSON.parse(import_fs5.default.readFileSync(it, "utf-8"));
    Object.keys(pkg.mvnDependencies || {}).forEach((k) => {
      if (pkg.mvnDependencies[k] > (mvnDependencies[k] || ""))
        mvnDependencies[k] = pkg.mvnDependencies[k];
    });
  }
  const deps = Object.keys(mvnDependencies).map((it) => it + ":" + mvnDependencies[it]);
  import_fs5.default.writeFileSync(import_path4.default.join("lib", "build.gradle"), gradleTemplate(deps));
  const child = (0, import_child_process3.spawnSync)("gradle", ["-b", import_path4.default.join("lib", "build.gradle"), "--no-daemon", "install"], {
    stdio: "inherit"
  });
  if (child.status)
    process.exit(child.status);
}
var gradleTemplate = (deps) => (0, import_redent.default)(
  `
    apply plugin: "java"

    repositories {
      mavenCentral()
    }

    dependencies {
      ${deps.map((it) => `implementation "${it}"`).join("\n      ")}
    }

    tasks.register("install", Copy) {
      from sourceSets.main.runtimeClasspath
      into "."
    }
    `,
  0
).trimStart();

// src/commands/run.ts
var import_chalk4 = __toESM(require_source());
var import_fs6 = __toESM(require("fs"));
var import_redent2 = __toESM(require_redent());
var import_child_process4 = require("child_process");
function run_default(output, args, { inspectBrk, watch }) {
  if (!import_fs6.default.existsSync(output)) {
    console.error(import_chalk4.default.red(`The file '${output}' does not exist.`));
    process.exit(code.INVALID_ARGUMENT);
  }
  const [type, runner] = checkRuntime();
  const classPaths = listFilesByExt("lib", ".jar");
  const run = () => {
    const finalArgs = [];
    if (type === "nashorn") {
      finalArgs.push("-scripting", "--language=es6", "-cp", ":" + classPaths.join(":"), output, "--", ...args);
    } else if (type === "graaljs") {
      if (inspectBrk)
        finalArgs.push("--inspect-brk=" + inspectBrk);
      finalArgs.push(
        "--jvm",
        "--experimental-options",
        "--js.nashorn-compat=true",
        "--vm.cp=:" + classPaths.join(":"),
        output,
        ...args
      );
    }
    const child2 = (0, import_child_process4.spawn)(runner, finalArgs);
    child2.on("exit", (code2) => process.exit(code2 || 0));
    child2.stdout.on("data", (chunk) => process.stdout.write(chunk));
    child2.stderr.on("data", (chunk) => process.stderr.write(chunk));
    return child2;
  };
  let child = run();
  if (watch) {
    import_fs6.default.watchFile(output, () => {
      child.removeAllListeners();
      child.on("exit", () => child = run());
      child.kill("SIGHUP");
      console.log(import_chalk4.default.gray(`Restarting ${output}...`));
    });
  }
}
function checkRuntime() {
  const runtime = "nashorn";
  const [type] = locateJdk(runtime);
  if (type === "graaljs") {
    return ["graaljs", runtime];
  } else if (type === "nashorn") {
    return ["nashorn", runtime];
  } else if ((0, import_child_process4.spawnSync)("node", ["--version:graalvm"]).status === 0) {
    return ["graaljs", "node"];
  } else if ((0, import_child_process4.spawnSync)("jjs", ["-version"]).status === 0) {
    return ["nashorn", "jjs"];
  } else {
    console.error(`Please define the runtime in $PATH.ENV`);
    console.error(
      (0, import_redent2.default)(
        `
      runtime=/path/to/graalvm/bin/node
      // or
      runtime=/path/to/openjdk/bin/jjs
    `,
        0
      )
    );
    process.exit(code.UNKNOWN_RUNTIME);
  }
}

// src/commands/index.ts
var commands_default = {
  build: build_default,
  init: init_default,
  install: install_default,
  run: run_default
};

// src/main.ts
var { name, version } = readJSON(import_path5.default.join(PATH.INSTALL_DIR, PATH.PACKAGE));
import_commander.program.name(name).version(version);
import_commander.program.command("init").description("initialize a new project in the current directory").action(() => commands_default.init());
import_commander.program.command("install").description("install dependencies of current project").option("--offline", "generate lib/@types offline", false).action((command) => {
  commands_default.install(command.offline);
});
import_commander.program.command("build <entries...>").description("compile one or more typescript entries").option("-c <path>", "generate output in specific directory", ".").option("-w --watch", "watch changes and re-build", false).action((entries, { watch, c }) => {
  commands_default.build(entries, c, watch);
});
import_commander.program.command("run <output> [arguments...]").description("execute one of the build output").option("-w --watch", "watch changes and re-run", false).action((output, args, { watch }) => {
  commands_default.run(output, args, watch);
});
import_commander.program.parse(process.argv);
/*! Bundled license information:

antlr4/src/antlr4/polyfills/codepointat.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)

antlr4/src/antlr4/polyfills/fromcodepoint.js:
  (*! https://mths.be/fromcodepoint v0.2.1 by @mathias *)
*/
